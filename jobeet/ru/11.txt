День 11: Тестирование форм
==========================

**Внимание: перевод в работе! Пишите anna.tarasenko@equelli.com**

Вчера мы создали нашу первую форму с использованием Symfony. Пользователи теперь
имеют возможность разместить новую вакансию на Jobeet, но мы вышли за рамки 
отпущенного времени до того, как успели добавить немного тестов.

Это то, чем мы займемся сегодня. Попутно мы также изучим фреймворк форм глубже.

>**SIDEBAR**
>Использование Фреймворка форм без Symfony
>
>Компоненты Symfony связаны гибко. Это означает, что большинство из них может использоваться
>отдельно от полного MVC фреймворка. Это касается и фреймворка форм, который не имеет зависимостей
>от Symfony. Вы можете использовать его в любом PHP приложении, включив в него каталоги `lib/form/`, 
>`lib/widgets/` и`lib/validators/`.
>
>Другой компонент, допускающий отдельное использование, это фреймворк маршрутизации. Скопируйте каталог 
>`lib/routing/` в свой проект, не использующий Symfony, и свободно наслаждайтесь красивыми URL.
>
>Независимые компоненты формируют **платформу Symfony**:
>
>![The symfony platform](http://www.symfony-project.org/images/jobeet/1_2/11/platform.png)

Сохранение форм (submitting)
----------------------------

Давайте откроем файл `jobActionsTest`, чтобы добавить функциональные тесты для создания
вакансии и процесса валидации формы.

В конец файла добавьте следующий код, чтобы получить страницу создания вакансии:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()
    ;

Мы уже использовали метод `click()` для эмуляции перехода по ссылкам. Такой же
метод `click()` может быть использован для сохранения формы. Для формы Вы можете
задать значения каждого поля для сохранения в качестве второго аргумента метода. Так же,
как и настоящий браузер, объект класса `sfBrowser` объединяет значения по умолчанию с заданными Вами
значениями.

Но чтобы задать значения полей, Вы должны знать их имена. Если Вы откроете исходный код страницы,
либо воспользуетесь возможностью Firefox Web Developer Toolbar "Forms > Display Form
Details", Вы увидите, что имя поля для `company` на самом деле выглядит как `jobeet_job[company]`.

>**NOTE**
>Когда PHP сталкивается с именами вроде `jobeet_job[company]`, он автоматически преобразует их
>в массив с именем `jobeet_job`.

Чтобы сделать названия более ясными, давайте добавим формат `job[%s]` для полей формы при помощи
следующего кода в конце метода `configure()` класса `JobeetJobForm`:

    [php]
<propel>
    // lib/form/JobeetJobForm.class.php
</propel>
<doctrine>
    // lib/form/doctrine/JobeetJobForm.class.php
</doctrine>
    $this->widgetSchema->setNameFormat('job[%s]');

После этого изменения имя поля `company` будет выглядеть как `job[company]` в Вашем 
браузере. Теперь самое время нажать на кнопку "Preview your job" и передать форме
допустимые значения полей:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()->

      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'url'          => 'http://www.sensio.com/',
        'logo'         => sfConfig::get('sf_upload_dir').'/jobs/sensio-labs.gif',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'description'  => 'You will work with symfony to develop websites for our customers.',
        'how_to_apply' => 'Send me an email',
        'email'        => 'for.a.job@example.com',
        'is_public'    => false,
      )))->

      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'create')->
      end()
    ;

Объект класса `sfBrowser` может также проэмулировать загрузку файлов, если Вы укажете абсолютный путь к файлу.
После сохранения формы мы проверили, что было запущено действие `create`.

Тестер форм (form tester) 
-------------------------

Форма, которую мы сохранили, должна быть валидна. Вы можете это проверить, используя
**тестер форм**:

    [php]
    with('form')->begin()->
      hasErrors(false)->
    end()->

Тестер форм имеет несколько методов для проверки текущего статуса формы, например,
наличия ошибок.

Если Вы сделали ошибку в тесте, и он не срабатывает, Вы можете использовать выражение
`with('response')->debug()`, которое мы уже видели в дне 9. Но Вы будете вынуждены
погрузиться в сгенерированный HTML, чтобы увидеть сообщения об ошибках. Это неудобно.
Тестер форм также предоставляет метод `debug()`, который отображает статус формы
и все связанные с ним сообщения об ошибках:

    [php]
    with('form')->debug()

Тестирование перенаправления (redirect)
---------------------------------------

Поскольку форма валидна, вакансия должна быть создана и пользователь перенаправлен 
на страницу `show`:

    [php]
    isRedirected()->
    followRedirect()->

    with('request')->begin()->
      isParameter('module', 'job')->
      isParameter('action', 'show')->
    end()->

Метод `isRedirected()` проверяет, было ли выполнено перенаправление, а метод
`followRedirect()` осуществляет перенаправление.

>**NOTE**
>Класс `sfBrowser` не выполняет перенаправление автоматически, поскольку Вы можете
>захотеть проверить состояние объектов перед перенаправлением.

##ORM##-тестер
-------------------

В конце концов, мы хотим проверить, что вакансия была создана в базе данных и 
поле `is_activated` установлено в `false`, поскольку пользователь еще не опубликовал вакансию.

Это может быть сделано довольно просто при помощи не использовавшегося нами до сих пор 
**##ORM##-тестера**. Поскольку ##ORM##-тестер по умолчанию не устанавливается, 
давайте его добавим:

<propel>
    [php]
    $browser->setTester('propel', 'sfTesterPropel');
</propel>
<doctrine>
    [php]
    $browser->setTester('doctrine', 'sfTesterDoctrine');
</doctrine>

##ORM##-тестер предлагает метод `check()` для проверки, что один или более
объектов в базе данных удовлетворяют критерию, задаваемому в аргументе метода.

    [php]
<propel>
    with('propel')->begin()->
</propel>
<doctrine>
    with('doctrine')->begin()->
</doctrine>
      check('JobeetJob', array(
        'location'     => 'Atlanta, USA',
        'is_activated' => false,
        'is_public'    => false,
      ))->
    end()

Критерий может задаваться массивом значений, как в примере выше, или экземпляром объекта
<propel>
`Criteria`
</propel>
<doctrine>
`Doctrine_Query`
</doctrine>
для более сложных запросов. Вы можете проверять существование объектов, удовлетворяющих критерию,
задавая значение Boolean в качестве третьего аргумента (по умолчанию `true`), или количество
совпадающих объектов, задавая целое число.

Тестирование на наличие ошибок валидации
----------------------------------------

Создание формы вакансии работает как ожидается, если мы сохраняем правильные значения. Давайте
добавим тест, чтобы проверить поведение, когда делается попытка сохранения невалидных значений:

    [php]
    $browser->
      info('  3.2 - Submit a Job with invalid values')->

      get('/job/new')->
      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'email'        => 'not.an.email',
      )))->

      with('form')->begin()->
        hasErrors(3)->
        isError('description', 'required')->
        isError('how_to_apply', 'required')->
        isError('email', 'invalid')->
      end()
    ;

Метод `hasErrors()` может протестировать количество ошибок, если вызывается с целым аргументом.
Метод `isError()` тестирует код ошибки для данного поля.

>**TIP**
>В тестах, которые мы написали для сохранения невалидных данных, мы не вызываем
>тесты для всей формы. Мы добавили тесты только для специфических полей.

Вы можете также протестировать сгенерированный HTML, чтобы проверить, что он содержит
сообщения об ошибках, но это не является необходимым в нашем случае, поскольку мы не меняли 
отображение формы.

Теперь нам нужно проверить панель администратора на странице предварительного просмотра вакансии.
Пока вакансия еще не активирована, Вы можете отредактировать, удалить или опубликовать ее. Чтобы проверить
эти три ссылки, сначала мы должны создать вакансию. Но нам придется скопировать много кода.
Поскольку я не люблю засорять код копипастом, давайте добавим метод создания вакансии
в класс `JobeetTestFunctional`:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function createJob($values = array())
      {
        return $this->
          get('/job/new')->
          click('Preview your job', array('job' => array_merge(array(
            'company'      => 'Sensio Labs',
            'url'          => 'http://www.sensio.com/',
            'position'     => 'Developer',
            'location'     => 'Atlanta, USA',
            'description'  => 'You will work with symfony to develop websites for our customers.',
            'how_to_apply' => 'Send me an email',
            'email'        => 'for.a.job@example.com',
            'is_public'    => false,
          ), $values)))->
          followRedirect()
        ;
      }

      // ...
    }

Метод `createJob()` создает вакансию, выполняет перенаправление и возвращает объект
браузера, чтобы не прерывать цепочку плавающего синтаксиса (fluent interface). Вы также можете
передать в метод массив значений, которые будут объединены со значениями по умолчанию перед 
сохранением.

Forcing the ~HTTP Method~ of a link
-----------------------------------

Testing the "Publish" link is now more simple:

    [php]
    $browser->info('  3.3 - On the preview page, you can publish the job')->
      createJob(array('position' => 'FOO1'))->
      click('Publish', array(), array('method' => 'put', '_with_csrf' => true))->

<propel>
      with('propel')->begin()->
</propel>
<doctrine>
      with('doctrine')->begin()->
</doctrine>
        check('JobeetJob', array(
          'position'     => 'FOO1',
          'is_activated' => true,
        ))->
      end()
    ;

If you remember from day 10, the "Publish" link has been configured to be
called with the HTTP `~PUT|PUT (HTTP Method)~` method. As browsers don't understand 
`PUT` requests, the `link_to()` helper converts the link to a form with some
JavaScript. As the test browser does not execute JavaScript, we need to force
the method to `PUT` by passing it as a third option of the `click()` method.
Moreover, the `link_to()` helper also embeds a ~CSRF token~ as we have enabled
CSRF protection during day 1; the `_with_csrf` option simulates this token.

Testing the "Delete" link is quite similar:

    [php]
    $browser->info('  3.4 - On the preview page, you can delete the job')->
      createJob(array('position' => 'FOO2'))->
      click('Delete', array(), array('method' => 'delete', '_with_csrf' => true))->

<propel>
      with('propel')->begin()->
</propel>
<doctrine>
      with('doctrine')->begin()->
</doctrine>
        check('JobeetJob', array(
          'position' => 'FOO2',
        ), false)->
      end()
    ;

Tests as a SafeGuard
--------------------

When a job is published, you cannot edit it anymore. Even if the "Edit" link
is not displayed anymore on the preview page, let's add some tests for this
requirement.

First, add another argument to the `createJob()` method to allow automatic
publication of the job, and create a `getJobByPosition()` method that returns
a job given its position value:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function createJob($values = array(), $publish = false)
      {
        $this->
          get('/job/new')->
          click('Preview your job', array('job' => array_merge(array(
            'company'      => 'Sensio Labs',
            'url'          => 'http://www.sensio.com/',
            'position'     => 'Developer',
            'location'     => 'Atlanta, USA',
            'description'  => 'You will work with symfony to develop websites for our customers.',
            'how_to_apply' => 'Send me an email',
            'email'        => 'for.a.job@example.com',
            'is_public'    => false,
          ), $values)))->
          followRedirect()
        ;

        if ($publish)
        {
          $this->
            click('Publish', array(), array('method' => 'put', '_with_csrf' => true))->
            followRedirect()
          ;
        }

        return $this;
      }

<propel>
      public function getJobByPosition($position)
      {
        $criteria = new Criteria();
        $criteria->add(JobeetJobPeer::POSITION, $position);

        return JobeetJobPeer::doSelectOne($criteria);
      }
</propel>
<doctrine>
      public function getJobByPosition($position)
      {
        $q = Doctrine_Query::create()
          ->from('JobeetJob j')
          ->where('j.position = ?', $position);

        return $q->fetchOne();
      }
</doctrine>

      // ...
    }

If a job is published, the edit page must return a ~404|404 Error~ status code:

    [php]
    $browser->info('  3.5 - When a job is published, it cannot be edited anymore')->
      createJob(array('position' => 'FOO3'), true)->
      get(sprintf('/job/%s/edit', $browser->getJobByPosition('FOO3')->getToken()))->

      with('response')->begin()->
        isStatusCode(404)->
      end()
    ;

But if you run the tests, you won't have the expected result as we forgot to
implement this ~security|Security~ measure yesterday. Writing tests is also a great way
to discover bugs, as you need to think about all ~edge cases|Edge Cases~.

Fixing the bug is quite simple as we just need to forward to a 404 page if the
job is activated:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeEdit(sfWebRequest $request)
    {
      $job = $this->getRoute()->getObject();
      $this->forward404If($job->getIsActivated());

      $this->form = new JobeetJobForm($job);
    }

The fix is trivial, but are you sure that everything else still works as
expected? You can open your browser and start testing all possible
combinations to access the edit page. But there is a simpler way: run
your test suite; if you have introduced a ~regression|Regression~, symfony will tell you
right away.

Back to the Future in a Test
----------------------------

When a job is expiring in less than five days, or if it is already expired,
the user can extend the job validation for another 30 days from the current
date.

Testing this requirement in a browser is not easy as the expiration date is
automatically set when the job is created to 30 days in the future. So, when
getting the job page, the link to extend the job is not present. Sure, you can
hack the expiration date in the database, or tweak the template to always
display the link, but that's tedious and error prone. As you have already
guessed, writing some tests will help us one more time.

As always, we need to add a new route for the `extend` method first:

    [yml]
    # apps/frontend/config/routing.yml
    job:
      class:   sfPropelRouteCollection
      options:
        model:          JobeetJob
        column:         token
        object_actions: { publish: PUT, extend: PUT }
      requirements:
        token: \w+

Then, update the "Extend" link code in the `_admin` partial:

    [php]
    <!-- apps/frontend/modules/job/templates/_admin.php -->
    <?php if ($job->expiresSoon()): ?>
     - <?php echo link_to('Extend', 'job_extend', $job, array('method' => 'put')) ?> for another <?php echo sfConfig::get('app_active_days') ?> days
    <?php endif; ?>

Then, create the `extend` action:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeExtend(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $this->forward404Unless($job->extend());

<propel>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extended until %s.', $job->getExpiresAt('m/d/Y')));
</propel>
<doctrine>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extended until %s.', date('m/d/Y', strtotime($job->getExpiresAt()))));
</doctrine>

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

As expected by the action, the `extend()` method of `JobeetJob` returns `true`
if the job has been extended or `false` otherwise:

<propel>
    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function extend()
      {
        if (!$this->expiresSoon())
        {
          return false;
        }

        $this->setExpiresAt(time() + 86400 * sfConfig::get('app_active_days'));

        return $this->save();
      }

      // ...
    }
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJob.class.php
    class JobeetJob extends BaseJobeetJob
    {
      public function extend()
      {
        if (!$this->expiresSoon())
        {
          return false;
        }

        $this->setExpiresAt(date('Y-m-d', time() + 86400 * sfConfig::get('app_active_days')));

        $this->save();

        return true;
      }

      // ...
    }
</doctrine>

Eventually, add a test scenario:

    [php]
    $browser->info('  3.6 - A job validity cannot be extended before the job expires soon')->
      createJob(array('position' => 'FOO4'), true)->
      call(sprintf('/job/%s/extend', $browser->getJobByPosition('FOO4')->getToken()), 'put', array('_with_csrf' => true))->
      with('response')->begin()->
        isStatusCode(404)->
      end()
    ;

    $browser->info('  3.7 - A job validity can be extended when the job expires soon')->
      createJob(array('position' => 'FOO5'), true)
    ;

    $job = $browser->getJobByPosition('FOO5');
<propel>
    $job->setExpiresAt(time());
</propel>
<doctrine>
    $job->setExpiresAt(date('Y-m-d'));
</doctrine>
    $job->save();

    $browser->
      call(sprintf('/job/%s/extend', $job->getToken()), 'put', array('_with_csrf' => true))->
      with('response')->isRedirected()
    ;

<propel>
    $job->reload();
    $browser->test()->is(
      $job->getExpiresAt('y/m/d'),
      date('y/m/d', time() + 86400 * sfConfig::get('app_active_days'))
    );
</propel>
<doctrine>
    $job->refresh();
    $browser->test()->is(
      date('y/m/d', strtotime($job->getExpiresAt())),
      date('y/m/d', time() + 86400 * sfConfig::get('app_active_days'))
    );
</doctrine>

This test scenario introduces a few new things:

 * The `call()` method retrieves a URL with a method different from `GET` or
   `POST`
<propel>
 * After the job has been updated by the action, we need to reload the local
   object with `$job->reload()`
</propel>
<doctrine>
 * After the job has been updated by the action, we need to reload the local
   object with `$job->refresh()`
</doctrine>
 * At the end, we use the embedded `lime` object directly to test the new
   expiration date.

Forms Security
--------------

### Form Serialization Magic!

##ORM## ~form|Forms~s are very easy to use as they automate a lot of work. For
instance, serializing a form to the database is as simple as a call to
`$form->save()`.

But how does it work? Basically, the `save()` method follows the following
steps:

 * Begin a transaction (because nested ##ORM## forms are all saved in one fell
   swoop)
 * Process the submitted values (by calling `updateCOLUMNColumn()` methods if
   they exist)
 * Call ##ORM## object `fromArray()` method to update the column values
 * Save the object to the database
 * Commit the transaction

### Built-in Security Features

The `fromArray()` method takes an array of values and updates the corresponding
column values. Does this represent a ~security|Security~ issue? What if someone tries to
submit a value for a column for which he does not have authorization? For
instance, can I force the `token` column?

Let's write a test to simulate a job submission with a `token` field:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      get('/job/new')->
      click('Preview your job', array('job' => array(
        'token' => 'fake_token',
      )))->

      with('form')->begin()->
        hasErrors(7)->
        hasGlobalError('extra_fields')->
      end()
    ;

When submitting the form, you must have an `extra_fields` global error.
That's because by default forms do not allow extra fields to be present in the
submitted values. That's also why all form fields must have an associated
validator.

>**TIP**
>You can also submit additional fields from the comfort of your browser using
>tools like the Firefox Web Developer Toolbar.

You can bypass this security measure by setting the `allow_extra_fields`
option to `true`:

    [php]
    class MyForm extends sfForm
    {
      public function configure()
      {
        // ...

        $this->validatorSchema->setOption('allow_extra_fields', true);
      }
    }

The test must now pass but the `token` value has been filtered out of the
values. So, you are still not able to bypass the security measure. But if you
really want the value, set the `filter_extra_fields` option to `false`:

    [php]
    $this->validatorSchema->setOption('filter_extra_fields', false);

>**NOTE**
>The tests written in this section are only for demonstration purpose. You
>can now remove them from the Jobeet project as tests do not need to validate
>symfony features.

### ~XSS~ and ~CSRF~ Protection

During day 1, we created the `frontend` application with the following command
line:

    $ php symfony generate:app --escaping-strategy=on
       ➥ --csrf-secret=Unique$ecret frontend

The `--escaping-strategy` option enables the protection against XSS. It means
that all variables used in templates are escaped by default. If you try to
submit a job description with some HTML tags inside, you will notice that when
symfony renders the job page, the HTML tags from the description are not
interpreted, but rendered as plain text.

The `--csrf-secret` option enabled the CSRF protection. When you provide this
option, all forms embed a `_csrf_token` hidden field.

>**TIP**
>The escaping strategy and the CSRF secret can be changed at any time by
>editing the `apps/frontend/config/settings.yml` ~configuration|onfiguration~
>file. As for the `databases.yml` file, the settings are configurable by 
>environment:
>
>     [yml]
>     all:
>       .settings:
>         # Form security secret (CSRF protection)
>         csrf_secret: Unique$ecret
>
>         # Output escaping settings
>         escaping_strategy: on
>         escaping_method:   ESC_SPECIALCHARS

Создание задач для поддержки
----------------------------

Несмотря на то, что Symfony - это веб-фреймворк, он включает инструменты, запускаемые 
из командной строки. Вы уже использовали их для создания структуры каталогов проекта
и приложения, а также для генерации различных файлов модели. Добавление новой задачи (task)
довольно просто осуществить, поскольку инструменты командной строки Symfony находятся
в самом фреймворке.

Когда пользователь создает вакансию, он должен ее активировать, чтобы она стала доступной другим. 
Но если он этого не сделает, база данных начнет разрастаться за счет неактуальных вакансий. 
Давайте создадим задачу для удаления таких вакансий из базы данных. Эта задача должна будет 
регулярно запускаться как задача cron.

    [php]
    // lib/task/JobeetCleanupTask.class.php
    class JobeetCleanupTask extends sfBaseTask
    {
      protected function configure()
      {
        $this->addOptions(array(
<doctrine>
          new sfCommandOption('application', null, sfCommandOption::PARAMETER_REQUIRED, 'The application', 'frontend'),
</doctrine>
          new sfCommandOption('env', null, sfCommandOption::PARAMETER_REQUIRED, 'The environement', 'prod'),
          new sfCommandOption('days', null, sfCommandOption::PARAMETER_REQUIRED, '', 90),
        ));

        $this->namespace = 'jobeet';
        $this->name = 'cleanup';
        $this->briefDescription = 'Cleanup Jobeet database';

        $this->detailedDescription = <<<EOF
    The [jobeet:cleanup|INFO] task cleans up the Jobeet database:

      [./symfony jobeet:cleanup --env=prod --days=90|INFO]
    EOF;
      }

      protected function execute($arguments = array(), $options = array())
      {
        $databaseManager = new sfDatabaseManager($this->configuration);

<propel>
        $nb = JobeetJobPeer::cleanup($options['days']);
        $this->logSection('propel', sprintf('Removed %d stale jobs', $nb));
</propel>
<doctrine>
        $nb = Doctrine::getTable('JobeetJob')->cleanup($options['days']);
        $this->logSection('doctrine', sprintf('Removed %d stale jobs', $nb));
</doctrine>
      }
    }

Конфигурация задачи выполняется в методе `configure()`. Каждая задача должна иметь
уникальное сочетание `namespace`:`name`, а также может иметь аргументы и опции.

>**TIP**
>Посмотрите встроенные задачи Symfony в каталоге (`lib/task/`), чтобы увидеть больше 
>примеров использования.

Задача `jobeet:cleanup` определяет две опции: `--env` и `--days` с некоторыми
приемлемыми значениями по умолчанию.

Запуск новой задачи аналогичен запуску любой встроенной задачи:

    $ php symfony jobeet:cleanup --days=10 --env=dev

<propel>
Как всегда, код очистки базы данных сосредоточен в классе `JobeetJobPeer`:

    [php]
    // lib/model/JobeetJobPeer.php
    static public function cleanup($days)
    {
      $criteria = new Criteria();
      $criteria->add(self::IS_ACTIVATED, false);
      $criteria->add(self::CREATED_AT, time() - 86400 * $days, Criteria::LESS_THAN);

      return self::doDelete($criteria);
    }

Метод `doDelete()` удаляет записи, соответствующие данному объекту `Criteria`. 
Метод возвращает массив первичных ключей обработанных записей.
</propel>
<doctrine>
Как всегда, код очистки базы данных сосредоточен в классе `JobeetJobTable`:

    [php]
    // lib/model/doctrine/JobeetJobTable.class.php
    public function cleanup($days)
    {
      $q = $this->createQuery('a')
        ->delete()
        ->andWhere('a.is_activated = ?', 0)
        ->andWhere('a.created_at < ?', date('Y-m-d', time() - 86400 * $days));

      return $q->execute();
    }
</doctrine>

>**NOTE**
>Задачи Symfony хорошо взаимодействуют со средой выполнения, т.к. возвращают
>значение, указывающее на успешность завершения задачи. Вы можете явно указать
>возвращаемое целое число в конце выполнения задачи.

Увидимся завтра
---------------

Тестирование - это сердце философии и инструментария Symfony. Сегодня мы снова
изучали, как применять инструменты Symfony, чтобы сделать процесс разработки
легче, быстрее и, что более важно, надежнее.

Фреймворк форм Symfony - это гораздо больше, чем просто виджеты и валидаторы: 
он дает Вам простой способ тестирования форм а также уверенность, что формы
защищены по умолчанию.

Our tour of great symfony features do not end today. Tomorrow, we will create
the backend application for Jobeet. Creating a backend interface is a must for
most web projects, and Jobeet is no different. But how will we be able to
develop such an interface in just one hour? Simple, we will use the symfony
admin generator framework. Until then, take care.

Наше путешествие в удивительный мир Symfony сегодня не заканчивается. Завтра
мы создадим бэкэнд-приложение для Jobeet. Бэкэнд-интерфейс - важная часть большинства
веб-проектов и Jobeet не является исключением. Но ка мы сможем создать его всего
за час? Очень просто -  мы будем использовать фреймворк Symfony для генерации
админки. А до тех пор - берегите себя.

__ORM__
