Ngày 11: Testing your Forms
==========================

Tóm tắt
--------------------

Hôm qua chúng ta đã tạo các form với symfony. Bây giờ, người dùng đã có thể
gửi một công việc mới lên Jobeet nhưng chúng ta đã không đủ thời gian để thực hiện test.

Chúng ta sẽ thực hiện việc này vào hôm nay. Trong quá trình thực hiện, chúng ta sẽ học nhiều hơn về
form framework.

>**SIDEBAR**
>Sử dụng Form Framework không cần symfony
>
>symfony framework được ghép từ các thành phần khác nhau. Điều đó có nghĩa là bạn có thể
>sử dụng từng thành phần riêng biệt mà không cần sử dụng toàn bộ framework.
>Bạn có thể dùng form framework độc lập với symfony. Bạn có thể dùng nó trong bất kì
>ứng dụng PHP nào bằng cách sử dụng các thư mục `lib/form/`, `lib/widgets/`, và
>`lib/validators/`.
>
>Một thành phần khác có thể dùng lại là routing framework. Copy thư mục `lib/routing/`
>vào project bất kì, và bạn có thể dùng nó để tạo ra các URL theo ý muốn.
>
>Các thành phần trong **symfony platform**:
>
>![The symfony plaform](http://www.symfony-project.org/images/jobeet/1_2/11/platform.png)

Submit một Form
-----------------

Mở file `jobActionsTest` và thêm functional tests cho quá trình tạo công việc và validation.

Thêm đoạn code sau vào cuối file:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()
    ;

Chúng ta đã dùng phương thức `click()` để giả lập việc click vào một link. Phương thức
`click()` cũng có thể dùng để submit một form. Với một form, bạn có thể cung cấp
các giá trị để submit cho mỗi field như là tham số thứ 2 của phương thức. Giống như
một trình duyệt thật, trình duyệt sẽ bổ sung các giá trị mặc định cho form
khi cần thiết.

Nhưng để cung cấp giá trị cho các field, chúng ta cần biết tên của chúng. Nếu bạn mở
source code hay sử dụng Firefox Web Developer Toolbar "Forms > Display Form
Details", bạn sẽ thấy rằng tên của field `company` là `jobeet_job[company]`.

>**NOTE**
>Khi PHP gặp một input field có tên là `jobeet_job[company]`, nó
>sẽ tự động chuyển thành một mảng `jobeet_job`.

Để dễ nhìn, chúng ta sẽ chuyển thành `job[%s]` bằng cách thêm đoạn
code sau vào cuối phương thức `configure()` của `JobeetJobForm`:

    [php]
<propel>
    // lib/form/JobeetJobForm.class.php
</propel>
<doctrine>
    // lib/form/doctrine/JobeetJobForm.class.php
</doctrine>
    $this->widgetSchema->setNameFormat('job[%s]');

Sau khi thay đổi, tên của field `company` sẽ là `job[company]`. Bây giờ chúng ta thực hiện việc click vào nút "Preview your job" và cung cấp giá trị cho form:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()->

      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'url'          => 'http://www.sensio.com/',
        'logo'         => sfConfig::get('sf_uploads_dir').'/jobs/sensio-labs.gif',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'description'  => 'You will work with symfony to develop websites for our customers.',
        'how_to_apply' => 'Send me an email',
        'email'        => 'for.a.job@example.com',
        'is_public'    => false,
      )))
    ;

Form phải được submit tới action `create`:

    [php]
    with('request')->begin()->
      isParameter('module', 'job')->
      isParameter('action', 'create')->
    end()->

Trình duyệt cũng giả lập việc upload file bằng cách cung cấp đường dẫn tuyệt đối tới file cần upload.

Form Tester
---------------

Form chúng ta đã submit cần được valid. Chúng ta có thể kiểm tra điều này bằng cách sử dụng
**form tester**:

    [php]
    with('form')->begin()->
      hasErrors(false)->
    end()->

Form tester có vài phương thức để kiểm tra trạng thái hiện tại của form, như errors...

Nếu bạn có lỗi trong test, và test không pass, bạn có thể sử dụng lệnh
`with('response')->debug()` đã học trong ngày 9. Nhưng bạn sẽ phải mò trong đống
HTML sinh ra để kiểm tra thông báo lỗi. Điều đó không được tiện lợi cho lắm. Vì thế, form tester cũng cung cấp một phương thức `debug()` trả về trạng thái của form và tất cả thông báo lỗi liên quan đến nó:

    [php]
    with('form')->debug()

Redirection Test
----------------

Khi form được valid, công việc được tạo và user chuyển sang trang `show`:

    [php]
    isRedirected()->
    followRedirect()->

    with('request')->begin()->
      isParameter('module', 'job')->
      isParameter('action', 'show')->
    end()->

`isRedirected()` kiểm tra xem trang đã được redirect hay chưa và
phương thức `followRedirect()` chuyển đến trang redirect.

##ORM## Tester
-----------------

Cuối cùng, chúng ta muốn test rằng công việc đã được tạo trong database và
kiểm tra rằng cột `is_public` có giá trị là `false` khi user chưa published nó.

Điều này có thể thực hiện dễ dàng nhờ một tester khác, **##ORM##
tester**. Mặc định, ##ORM## tester không được đăng kí, chúng ta cần thêm nó:

<propel>
    [php]
    $browser->setTester('propel', 'sfTesterPropel');
</propel>
<doctrine>
    [php]
    $browser->setTester('doctrine', 'sfTesterDoctrine');
</doctrine>

##ORM## tester cung cấp phương thức `check()` để kiểm tra xem một hay nhiều
object trong database có match với các tham số được cung cấp.

    [php]
<propel>
    with('propel')->begin()->
</propel>
<doctrine>
    with('doctrine')->begin()->
</doctrine>
      check('JobeetJob', array(
        'location'     => 'Atlanta, USA',
        'is_activated' => false,
        'is_public'    => false,
      ))->
    end()

<propel>
The criteria can be an array of values like above, or a `Criteria` instance
for more complex queries. You can test the existence of objects matching the
criteria with a Boolean as the third argument (the default is `true`), or the
number of matching objects by passing an integer.
</propel>
<doctrine>
Criteria có thể là một mảng các giá trị như ở trên, hoặc là một instance của `Doctrine_Query` 
đối với các câu truy vấn phức tạp. Bạn có thể kiểm tra các objects đã có
match với criteria với tham số thứ 3 là Boolean (mặc định là
`true`), hoặc số các matching objects đươc truyền vào kiểu integer.
</doctrine>

Testing for Errors
------------------

Job form đã tạo công việc đúng như mong đợi khi chúng ta submit các giá trị hợp lệ. Hãy thêm một
test để kiểm tra behavior khi chúng ta cung cấp dữ liệu không hợp lệ:

    [php]
    $browser->
      info('  3.2 - Submit a Job with invalid values')->

      get('/job/new')->
      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'email'        => 'not.an.email',
      )))->

      with('form')->begin()->
        hasErrors(3)->
        isError('description', 'required')->
        isError('how_to_apply', 'required')->
        isError('email', 'invalid')->
      end()
    ;

Phương thức `hasErrors()` có thể kiểm tra số lỗi nếu cung cấp một số nguyên.
Phương thức `isError()` kiểm tra error code for với từng field.

>**TIP**
>Trong khi test chúng ta viết các giá trị không hợp lệ, chứ không
>test lại toàn bộ form. Chúng ta chỉ thêm các test cho
>các trường cụ thể.

Bạn cũng có thể test mã HTML sinh ra để kiểm tra rằng nó chứa thông báo lỗi,
nhưng nó là không cần thiết do chúng ta không chỉnh sửa form layout.

Bây giờ, chúng ta cầ test thanh admin bar ở trang job preview. Khi một công việc
chưa được activated, bạn có thể edit, delete, hoặc publish công việc. Để test
3 link này, trước tiên chúng ta cần tạo một công việc. Chúng ta lại phải thực hiện việc copy
& paste code đã có. Để tránh lặp lại việc này, hãy thêm một phương thức tạo công việc trong lớp
`JobeetTestFunctional`:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function createJob($values = array())
      {
        return $this->
          get('/job/new')->
          click('Preview your job', array('job' => array_merge(array(
            'company'      => 'Sensio Labs',
            'url'          => 'http://www.sensio.com/',
            'position'     => 'Developer',
            'location'     => 'Atlanta, USA',
            'description'  => 'You will work with symfony to develop websites for our customers.',
            'how_to_apply' => 'Send me an email',
            'email'        => 'for.a.job@example.com',
            'is_public'    => false,
            'type'         => 'full-time',
          ), $values)))->
          followRedirect()
        ;
      }

      // ...
    }

Bắt buộc HTTP Method với một link
---------------------------------

Test link "Publish" trở nên đơn giản:

    [php]
    $browser->info('  3.3 - On the preview page, you can publish the job')->
      createJob(array('position' => 'FOO1'))->
      click('Publish', array(), array('method' => 'put', '_with_csrf' => true))->

<propel>
      with('propel')->begin()->
</propel>
<doctrine>
      with('doctrine')->begin()->
</doctrine>
        check('JobeetJob', array(
          'position'     => 'FOO1',
          'is_activated' => true,
        ))->
      end()
    ;

Nếu bạn nhớ lại trong ngày 10, link "Publish" đã được cấu hình để gọi với
HTTP `PUT` method. Do trình duyệt không hiểu `PUT`
requests, helper `link_to()` chuyển link thành một form với một vài
JavaScript. Do test browser không thực thi JavaScript, chúng ta cần bắt buộc
method là `PUT` bằng cách cung cấp nó như là tham số thứ 3 của phương thức `click()`.
Thêm vào đó, helper `link_to()` cũng nhúng một CSRF token do chúng ta đã enable
CSRF protection từ ngày 1; `_with_csrf` option mô phỏng token này.

Test link "Delete" hoàn toàn tương tự:

    [php]
    $browser->info('  3.4 - On the preview page, you can delete the job')->
      createJob(array('position' => 'FOO2'))->
      click('Delete', array(), array('method' => 'delete', '_with_csrf' => true))->

<propel>
      with('propel')->begin()->
</propel>
<doctrine>
      with('doctrine')->begin()->
</doctrine>
        check('JobeetJob', array(
          'position' => 'FOO2',
        ), false)->
      end()
    ;

Tests như một SafeGuard
--------------------

Khi một công việc được publish, bạn không thể sửa nó nữa. Link "Edit"
sẽ không xuất hiện ở trang preview, ta thêm một vài test cho yêu cầu này.

Đầu tiên, thêm một tham số khác cho phương thức `createJob()` để tự động
publication công việc, và tạo phương thức `getJobByPosition()` để trả về công việc
theo giá trị position cung cấp:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function createJob($values = array(), $publish = false)
      {
        $this->
          get('/job/new')->
          click('Preview your job', array('job' => array_merge(array(
            'company'      => 'Sensio Labs',
            'url'          => 'http://www.sensio.com/',
            'position'     => 'Developer',
            'location'     => 'Atlanta, USA',
            'description'  => 'You will work with symfony to develop websites for our customers.',
            'how_to_apply' => 'Send me an email',
            'email'        => 'for.a.job@example.com',
            'is_public'    => false,
            'type'         => 'full-time',
          ), $values)))->
          followRedirect()
        ;

        if ($publish)
        {
          $this->click('Publish', array(), array('method' => 'put', '_with_csrf' => true));
        }

        return $this;
      }

<propel>
      public function getJobByPosition($position)
      {
        $criteria = new Criteria();
        $criteria->add(JobeetJobPeer::POSITION, $position);

        return JobeetJobPeer::doSelectOne($criteria);
      }
</propel>
<doctrine>
      public function getJobByPosition($position)
      {
        $q = Doctrine_Query::create()
          ->from('JobeetJob j')
          ->where('j.position = ?', $position);

        return $q->fetchOne();
      }
</doctrine>
      // ...
    }

Nếu một công việc được publish, trang edit phải trả về mã trạng thái 404:

    [php]
    $browser->info('  3.5 - When a job is published, it cannot be edited anymore')->
      createJob(array('position' => 'FOO3'), true)->
      get(sprintf('/job/%s/edit', $browser->getJobByPosition('FOO3')->getToken()))->

      with('response')->begin()->
        isStatusCode(404)->
      end()
    ;

Nhưng nếu bạn chạy test, bạn sẽ không thu được kết quả như mong đợi do chúng ta đã quên thực hiện vấn đề này ngày hôm qua. Viết test cũng là một cách tốt để tìm ra các bug, và bạn cần nghĩ tới tất cả các trường hợp có thể.

Sửa lỗi này khá đơn giản, chúng ta cần forward trang edit tới trang 404 khi một công việc đã activated:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeEdit(sfWebRequest $request)
    {
      $jobeet_job = $this->getRoute()->getObject();
      $this->form = new JobeetJobForm($jobeet_job);

      $this->forward404If($jobeet_job->getIsActivated());
    }

Cách sửa thật đơn giản, nhưng bạn có chắc rằng mọi thứ vẫn làm việc như mong đợi?
Bạn có thể mở trình duyệt và bắt đầu test mọi cách có thể để truy cập trang edit.
Nhưng có một cách đơn giản hơn: chạy test suite của bạn;

Chuyển đến tương lai trong một Test
----------------------------

Khi một công việc hết hạn sau ít nhất 5 ngày,
user có thể gia hạn cho công việc thêm 30 ngày nữa kể từ ngày hiện tại.

Test yêu cầu này từ trình duyệt không dễ dàng do ngày hết hạn được tự động tạo khi tạo công việc. Vì thế, khi
chuyển đến trang công việc, link để extend cho công việc chưa tồn tại. Tất nhiên, bạn có thể sửa lại ngày hết hạn trong database, hoặc chỉnh lại template để hiển thị link này, nhưng việc này thật chán ngắt và dễ sinh ra lỗi. Bạn cũng có thể đoán được, viết một vài test sẽ giúp chúng ta.

Trước tiên, chúng ta cần thêm một route mới cho `extend`:

    [yml]
    # apps/frontend/config/routing.yml
    job:
      class:   sfPropelRouteCollection
      options:
        model:          JobeetJob
        column:         token
        object_actions: { publish: PUT, extend: PUT }
      requirements:
        token: \w+

Sau đó, sửa lại link "Extend" trong partial `_admin`:

    [php]
    <!-- apps/frontend/modules/job/templates/_admin.php -->
    <?php if ($job->expiresSoon()): ?>
     - <?php echo link_to('Extend', 'job_extend', $job, array('method' => 'put')) ?> for another <?php echo sfConfig::get('app_active_days') ?> days
    <?php endif; ?>

Sau đó, tạo action `extend`:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeExtend(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $this->forward404Unless($job->extend());

<propel>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extend until %s.', $job->getExpiresAt('m/d/Y')));
</propel>
<doctrine>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extend until %s.', date('m/d/Y', strtotime($job->getExpiresAt()))));
</doctrine>

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

Phương thức `extend()` của `JobeetJob` trả về `true`
nếu công việc đã được gia hạn và `false` trong trường hợp ngược lại:

<propel>
    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function extend()
      {
        if (!$this->expiresSoon())
        {
          return false;
        }

        $this->setExpiresAt(time() + 86400 * sfConfig::get('app_active_days'));

        return $this->save();
      }

      // ...
    }
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJob.class.php
    class JobeetJob extends BaseJobeetJob
    {
      public function extend()
      {
        if (!$this->expiresSoon())
        {
          return false;
        }

        $this->setExpiresAt(date('Y-m-d', time() + 86400 * sfConfig::get('app_active_days')));

        $this->save();

        return true;
      }

      // ...
    }
</doctrine>

Cuối cung, thêm một kịch bản test:

    [php]
    $browser->info('  3.6 - A job validity cannot be extended before the job expires soon')->
      createJob(array('position' => 'FOO4'), true)->
      call(sprintf('/job/%s/extend', $browser->getJobByPosition('FOO4')->getToken()), 'put', array('_with_csrf' => true))->
      with('response')->begin()->
        isStatusCode(404)->
      end()
    ;

    $browser->info('  3.7 - A job validity can be extended when the job expires soon')->
      createJob(array('position' => 'FOO5'), true)
    ;

    $job = $browser->getJobByPosition('FOO5');
<propel>
    $job->setExpiresAt(time());
</propel>
<doctrine>
    $job->setExpiresAt(date('Y-m-d'));
</doctrine>
    $job->save();

    $browser->
      call(sprintf('/job/%s/extend', $job->getToken()), 'put', array('_with_csrf' => true))->
      with('response')->isRedirected()
    ;

<propel>
    $job->reload();
    $browser->test()->is(
      $job->getExpiresAt('y/m/d'),
      date('y/m/d', time() + 86400 * sfConfig::get('app_active_days'))
    );
</propel>
<doctrine>
    $job->refresh();
    $browser->test()->is(
      date('y/m/d', strtotime($job->getExpiresAt())),
      date('y/m/d', time() + 86400 * sfConfig::get('app_active_days'))
    );
</doctrine>

Kịch bản test này có một vài thứ mới:

 * Phương thức `call()` nhận một URL với một method khác `GET` hay
   `POST`
 * Sau khi công việc đã được update bởi action, chúng ta cần nạp lại local
   object với `$job->reload()`
 * Cuối cùng, chúng ta dùng đối tượng `lime` nhúng trực tiếp để test ngày hết hạn mới.

Forms Security
--------------

### Form Serialization Magic!

##ORM## forms rất dễ sử dụng do chúng đã tự động thực hiện nhiều công việc.
Ví dụ, lưu một form vào database đơn giản là gọi `$form->save()`. Nó hoạt động như thế nào?

Bình thường, phương thức `save()` tiến hành qua các bước sau:

 * Begin a transaction (because nested ##ORM## forms are all saved in one fell
   swoop)
 * Process the submitted values (by calling `updateCOLUMNColumn()` methods if
   they exist)
 * Call ##ORM## object `fromArray()` method to update the column values
 * Save the object to the database
 * Commit the transaction

### Built-in Security Features

The `fromArray()` method takes an array of values and updates the corresponding
column values. Does this represent a security issue? What if someone tries to
submit a value for a column for which he does not have authorization? For
instance, can I force the `token` column?

Let's write a test to simulate a job submission with a `token` field:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      get('/job/new')->
      click('Preview your job', array('job' => array(
        'token' => 'fake_token',
      )))->

      with('form')->begin()->
        hasErrors(8)->
        hasGlobalError('extra_fields')->
      end()
    ;

When submitting the form, you must have an `extra_fields` global error.
That's because by default forms do not allow extra fields to be present in the
submitted values. That's also why all form fields must have an associated
validator.

>**TIP**
>You can also submit additional fields from the comfort of your browser using
>tools like the Firefox Web Developer Toolbar.

You can bypass this security measure by setting the `allow_extra_fields`
option to `true`:

    [php]
    class MyForm extends sfForm
    {
      public function configure()
      {
        // ...

        $this->validatorSchema->setOption('allow_extra_fields', true);
      }
    }

The test must now pass but the `token` value has been filtered out of the
values. So, you are still not able to bypass the security measure. But if you
really want the value, set the `filter_extra_fields` option to `false`:

    [php]
    $this->validatorSchema->setOption('filter_extra_fields', false);

>**NOTE**
>The tests written in this section are only for demonstration purpose. You
>can now remove them from the Jobeet project as tests do not need to validate
>symfony features.

### XSS and CSRF Protection

During day 1, we created the `frontend` application with the following command
line:

    $ php symfony generate:app --escaping-strategy=on --csrf-secret=Unique$ecret frontend

The `--escaping-strategy` option enables the protection against XSS. It means
that all variables used in templates are escaped by default. If you try to
submit a job description with some HTML tags inside, you will notice that when
symfony renders the job page, the HTML tags from the description are not
interpreted, but rendered as plain text.

The `--csrf-secret` option enabled the CSRF protection. When you provide this
option, all forms embed a `_csrf_token` hidden field.

>**TIP**
>The escaping strategy and the CSRF secret can be changed at any time by
>editing the `apps/frontend/config/settings.yml` configuration file. As for
>the `databases.yml` file, the settings are configurable by environment:
>
>     [yml]
>     all:
>       .settings:
>         # Form security secret (CSRF protection)
>         csrf_secret: Unique$ecret
>
>         # Output escaping settings
>         escaping_strategy: on
>         escaping_method:   ESC_SPECIALCHARS

Maintenance Tasks
-----------------

Even if symfony is a web framework, it comes with a command line tool.
You have already used it to create the default directory structure of the
project and the application, but also to generate various files for the model.
Adding a new task is quite easy as the tools used by the symfony command line
are packaged in a framework.

When a user creates a job, he must activate it to put it online. But if not,
the database will grow with stale jobs. Let's create a task that remove stale
jobs from the database. This task will have to be run regularly in a cron job.

    [php]
    // lib/task/JobeetCleanupTask.class.php
    class JobeetCleanupTask extends sfBaseTask
    {
      protected function configure()
      {
        $this->addOptions(array(
<doctrine>
          new sfCommandOption('application', null, sfCommandOption::PARAMETER_REQUIRED, 'The application', 'frontend'),
</doctrine>
          new sfCommandOption('env', null, sfCommandOption::PARAMETER_REQUIRED, 'The environement', 'prod'),
          new sfCommandOption('days', null, sfCommandOption::PARAMETER_REQUIRED, '', 90),
        ));

        $this->namespace = 'jobeet';
        $this->name = 'cleanup';
        $this->briefDescription = 'Cleanup Jobeet database';

        $this->detailedDescription = <<<EOF
    The [jobeet:cleanup|INFO] task cleans up the Jobeet database:

      [./symfony jobeet:cleanup --env=prod --days=90|INFO]
    EOF;
      }

      protected function execute($arguments = array(), $options = array())
      {
        $databaseManager = new sfDatabaseManager($this->configuration);

<propel>
        $nb = JobeetJobPeer::cleanup($options['days']);
        $this->logSection('propel', sprintf('Removed %d stale jobs', $nb));
</propel>
<doctrine>
        $nb = Doctrine::getTable('JobeetJob')->cleanup($options['days']);
        $this->logSection('doctrine', sprintf('Removed %d stale jobs', $nb));
</doctrine>
      }
    }

The task configuration is done in the `configure()` method. Each task must have
a unique name (`namespace`:`name`), and can have arguments and options.

>**TIP**
>Browse the built-in symfony tasks for (`lib/task/`) for more examples of
>usage.

The `jobeet:cleanup` task defines two options: `--env` and `--days` with some
sensible defaults.

Running the task is similar to running any other symfony built-in task:

    $ php symfony jobeet:cleanup --days=10 --env=dev

As always, the database cleanup code has been factored out in the
`JobeetJobPeer` class:

<propel>
    [php]
    // lib/model/JobeetJobPeer.php
    static public function cleanup($days)
    {
      $criteria = new Criteria();
      $criteria->add(self::IS_ACTIVATED, false);
      $criteria->add(self::CREATED_AT, time() - 86400 * $days, Criteria::LESS_THAN);

      return self::doDelete($criteria);
    }

The `doDelete()` method removes database records matching the given `Criteria`
object. It can also takes an array of primary keys.
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJobTable.class.php
    public function cleanup($days)
    {
      $q = $this->createQuery('a')
        ->delete()
        ->andWhere('a.is_activated = ?', 0)
        ->andWhere('a.created_at < ?', date('Y-m-d', time() - 86400 * $days));

      return $q->execute();
    }
</doctrine>

>**NOTE**
>The symfony tasks behave nicely with their environment as they return a
>value according to the success of the task. You can force a return value
>by returning an integer explicitly at the end of the task.

Hẹn gặp lại ngày mai
----------------

Test là một phần quan trọng trong symfony. Hôm nay, chúng ta đã học thêm về cách sử dụng các công cụ của symfony khiến cho việc phát triển ứng dụng trở nên nhanh chóng, dễ dàng, và an toàn hơn.

Symfony form framework cung cấp nhiều widget và validator: nó giúp bạn dễ dàng test form tạo ra để đảm bảo rằng 
form của bạn hoàn toàn bảo mật.

Chuyến hành trình khám phá những tính năng tuyệt vời của symfony vẫn chưa kết thúc. Ngày mai, chúng ta sẽ tạo 
backend application cho Jobeet. Tạo backend interface là yêu cầu bắt buộc với hầu hết các dự án web, và Jobeet cũng không là ngoại lệ. Nhưng chúng ta có thể phát triển toàn bộ chúng trong một giờ? Với symfony admin generator framework, việc đó trở nên đơn giản. Hãy đón xem vào ngày mai :)).

__ORM__
