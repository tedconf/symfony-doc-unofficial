13日目: ユーザー
================

昨日はたくさんの情報が詰め込まれました。
ごくわずかなPHPコードとadminジェネレータによって、
短時間でバックエンドインターフェイスを作成できます。

今日は、HTTPリクエストの間の永続データを管理する方法を理解します。
ご存じの通り、HTTPプロトコルはステートレスです。
それぞれのリクエストはその前後のリクエストから独立していることを意味します。
現代のWebサイトはユーザーエクスペリエンスを強化するために
リクエストの間のデータを一貫させる方法が必要です。

ユーザーセッションはCookieを利用して特定できます。
symfonyにおいて、開発者はセッションを直接操作する必要はありませんが
むしろアプリケーションのエンドユーザーを表す`sfUser`オブジェクトを使うことが必要です。

ユーザーflash
-------------

flashつきのアクションでユーザーオブジェクトをすでに見てきました。
flashはユーザーセッションに保存される短命のメッセージです。
これはすぐ次のリクエストの後で自動的に削除されます。
リダイレクトした後でユーザーにメッセージを表示する必要があるときにとても役立ちます。 
jobが保存される、削除もしくは延長されるときに、ユーザーにフィードバックを表示するために
adminジェネレータはflashをたくさん使います。

![flash](http://www.symfony-project.org/images/jobeet/1_2/13/flashes.png)

flashは`sfUser`の`setFlash()`メソッドを利用して設定できます:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeExtend(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $this->forward404Unless($job->extend());

<propel>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extended until %s.', $job->getExpiresAt('m/d/Y')));
</propel>
<doctrine>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extended until %s.', date('m/d/Y', strtotime($job->getExpiresAt()))));
</doctrine>

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

最初の引数はflashの識別子で2番目は表示するメッセージです。
望むのであればflashはなんでも定義できますが、
`notice`と`error`はもっとも共通するものの2つです
(これらはadminジェネレータによって広範囲で使われます)。

テンプレートにflashメッセージをインクルードするのは開発者次第ですが、
Jobeetに関して、これらは`layout.php`によって出力されます:

    [php]
    // apps/frontend/templates/layout.php
    <?php if ($sf_user->hasFlash('notice')): ?>
      <div class="flash_notice"><?php echo $sf_user->getFlash('notice') ?></div>
    <?php endif; ?>

    <?php if ($sf_user->hasFlash('error')): ?>
      <div class="flash_error"><?php echo $sf_user->getFlash('error') ?></div>
    <?php endif; ?>

テンプレートにおいて、ユーザーは特別な変数`sf_user`を通してアクセス可能です.

>**NOTE**
>symfonyオブジェクトの中にはアクションから明示的に渡さなくても
>常にテンプレートにアクセスできるものがあります: `sf_request`、`sf_user`、と
>`sf_response`

ユーザー属性
------------

不幸なことに、Jobeetユーザーのストーリーにはユーザーセッションに何かを保存する要件は含まれていません。
ですので新しい要件を追加しましょう: 求人の閲覧を楽にするために、
ユーザーによって閲覧される最新の3件の求人
は後で求人ページに戻れるリンクつきのメニューに表示されます。

ユーザーが求人ページにアクセスするとき、表示されるjobオブジェクトは
ユーザーの履歴に追加してセッションに保存する必要があります:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    class jobActions extends sfActions
    {
      public function executeShow(sfWebRequest $request)
      {
        $this->job = $this->getRoute()->getObject();

        // 求人履歴にすでに保存された求人を取得する
        $jobs = $this->getUser()->getAttribute('job_history', array());

        // 配列の始めに現在の求人を追加する
        array_unshift($jobs, $this->job->getId());

        // 新しい求人履歴をセッションに保存しなおす
        $this->getUser()->setAttribute('job_history', $jobs);
      }

      // ...
    }

>**NOTE**
>`JobeetJob`オブジェクトをセッションに直接保存するのはできますが非推奨です。
>リクエストの間にセッション変数がシリアライズされるからです。
>セッションがロードされるとき、`JobeetJob`オブジェクトは
>デシリアライズされ
>その間にそれらが修正もしくは削除される場合に"盗まれます"。

### `getAttribute()`、`setAttribute()`

識別子として、`sfUser::getAttribute()`メソッドはユーザーセッションから値を取得します。
逆に言えば、識別子のために`setAttribute()`メソッドはセッションにPHP変数を保存します。

`getAttribute()`メソッドは識別子がまだ定義されていない場合に
返すオプションのデフォルト値も受け取ります。

>**NOTE**
>`getAttribute()`メソッドが受け取るデフォルトの値は次の内容のショートカットです:
>
>     [php]
>     if (!$value = $this->getAttribute('job_history'))
>     {
>       $value = array();
>     }

### `myUser`クラス

関心の分離をより尊重するために、コードを`myUser`クラスに移動させましょう。
`myUser`クラスはデフォルトの[`sfUser`](http://www.symfony-project.org/api/1_2/sfUser)基底クラスを
アプリケーション固有のふるまいで
オーバーライドします:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    class jobActions extends sfActions
    {
      public function executeShow(sfWebRequest $request)
      {
        $this->job = $this->getRoute()->getObject();

        $this->getUser()->addJobToHistory($this->job);
      }

      // ...
    }

    // apps/frontend/lib/myUser.class.php
    class myUser extends sfBasicSecurityUser
    {
      public function addJobToHistory(JobeetJob $job)
      {
        $ids = $this->getAttribute('job_history', array());

        if (!in_array($job->getId(), $ids))
        {
          array_unshift($ids, $job->getId());

          $this->setAttribute('job_history', array_slice($ids, 0, 3));
        }
      }
    }

すべての要件を考慮するようにコードも変更されました:

  * `!in_array($job->getId(), $ids)`: jobは履歴に二度も
    保存できません

  * `array_slice($ids, 0, 3)`: ユーザーによって閲覧される最新の3つの求人のみ
    表示される

レイアウトにおいて、変数`$sf_content`が出力される前に
次のコードを追加します:

    [php]
    // apps/frontend/templates/layout.php
    <div id="job_history">
      Recent viewed jobs:
      <ul>
        <?php foreach ($sf_user->getJobHistory() as $job): ?>
          <li>
            <?php echo link_to($job->getPosition().' - '.$job->getCompany(), 'job_show_user', $job) ?>
          </li>
        <?php endforeach; ?>
      </ul>
    </div>

    <div class="content">
      <?php echo $sf_content ?>
    </div>

レイアウトは現在の求人履歴を読み取るために新しい`getJobHistory()`メソッドを使用する:

    [php]
    // apps/frontend/lib/myUser.class.php
    class myUser extends sfBasicSecurityUser
    {
<propel>
      public function getJobHistory()
      {
        $ids = $this->getAttribute('job_history', array());

        return JobeetJobPeer::retrieveByPKs($ids);
      }
</propel>
<doctrine>
      public function getJobHistory()
      {
        $ids = $this->getAttribute('job_history', array());

        if (!empty($ids))
        {
          return Doctrine::getTable('JobeetJob')
            ->createQuery('a')
            ->whereIn('a.id', $ids)
            ->execute();
        }
        else
        {
          return array();
        }
      }
</doctrine>

      // ...
    }

<propel>
1つの呼び出しで`JobeetJob`オブジェクトを読み取るために
`getJobHistory()`メソッドはPropelの`retrieveByPKs()`メソッドを使用します。
</propel>

![求人履歴](http://www.symfony-project.org/images/jobeet/1_2/13/job_history.png)

### sfParameterHolder

求人履歴のAPIを完結させるために、履歴をリセットするメソッドを追加しましょう:

    [php]
    // apps/frontend/lib/myUser.class.php
    class myUser extends sfBasicSecurityUser
    {
      public function resetJobHistory()
      {
        $this->getAttributeHolder()->remove('job_history');
      }

      // ...
    }

ユーザー属性は`sfParameterHolder`クラスのオブジェクトによって管理されます。
`getAttribute()`と`setAttribute()`メソッドは
`getParameterHolder()->get()`と`getParameterHolder()->set()`用のプロキシメソッドです。
`remove()`メソッドは`sfUser`のプロキシメソッドを持たないので、
パラメータホルダーオブジェクトを直接使う必要があります。

>**NOTE**
>[`sfParameterHolder`](http://www.symfony-project.org/api/1_2/sfParameterHolder)
>クラスはパラメータを保存するために`sfRequest`によっても使われます。

アプリケーションのセキュリティ
------------------------------

### 認証

他の多くのsymfonyの機能のように、セキュリティはYAMLファイルの`security.yml`で管理されます。
たとえば、バックエンドアプリケーションの`config/`ディレクトリで
デフォルト設定が見つかります:

    [yml]
    # apps/backend/config/security.yml
    default:
      is_secure: off

`is_secure`エントリを`on`に切り替える場合、
バックエンドアプリケーション全体でユーザーを認証することが求められます。

![ログイン](http://www.symfony-project.org/images/jobeet/1_2/13/login.png)

>**TIP**
>YAMLファイルにおいて、booleanは`true`と`false`、
>もしくは`on`と`off`の文字列で表現されます。

Webデバッグツールバーのログを見ると、
ページにアクセスしようとするたびに`defaultActions`クラスの`executeLogin()`メソッドが
呼び出されることに気がつきます。

![Webデバッグ](http://www.symfony-project.org/images/jobeet/1_2/13/web_debug.png)

認証されていないユーザーがセキュアなアクションにアクセスしようとするとき、
symfonyは`settings.yml`で設定された`login`アクションにリクエストを転送します:

    [yml]
    all:
      .actions:
        login_module: default
        login_action: login

>**NOTE**
>無限の再帰呼び出しを回避するためにloginアクションをセキュアにするのは不可能です。

-

>**TIP**
>4日目でみたように、同じ設定ファイルを複数の場所で定義できます。
>これは`security.yml`にも当てはまります。
>単独のアクションもしくはモジュール全体をセキュアにするもしくはセキュアにしないのみであれば、
>モジュールの`config/`ディレクトリで`security.yml`を作成します:
>
>     [yml]
>     index:
>       is_secure: off
>
>     all:
>       is_secure: on

デフォルトでは、`myUser`クラスは
[`sfBasicSecurityUser`](http://www.symfony-project.org/api/1_2/sfBasicSecurityUser)を継承し、
`sfUser`は継承しません。`sfBasicSecurityUser`は
ユーザーの認証と権限付与を管理するための追加メソッドを提供します。

ユーザーの認証を管理するには、
`isAuthenticated()`と`setAuthenticated()`メソッドを使います:

    [php]
    if (!$this->getUser()->isAuthenticated())
    {
      $this->getUser()->setAuthenticated(true);
    }

### 認証

ユーザーが認証されたとき、アクションへのアクセスは
**クレデンシャル(credential)**を定義することでより制限できます。
ユーザーはページにアクセスするために要求されるクレデンシャルを持たなければなりません:

    [yml]
    default:
      is_secure:   off
      credentials: admin

symfonyのクレデンシャルシステムはとてもシンプルで強力です。
クレデンシャルは(グループもしくはパーミッションのように)
アプリケーションのセキュリティモデルを記述するために必要なものを表現できます。

>**SIDEBAR**
>複雑なクレデンシャル
>
>複雑なクレデンシャルの要件を記述するために
>`security.yml`の`credentials`エントリはBooleanオペレーションをサポートします。
>
>ユーザーがクレデンシャルA**と**Bを持たなければならない場合、
>角かっこでクレデンシャルを囲みます:
>
>     [yml]
>     index:
>       credentials: [A, B]
>
>ユーザーがクレデンシャルA**もしくは**Bを持たなければならない場合、
>2つの角かっこの組でクレデンシャルを囲みます:
>
>     [yml]
>     index:
>       credentials: [[A, B]]
>
>クレデンシャルの数だけ任意のBoolean式を記述するために
>かっこを組み合わせることもできます。

ユーザークレデンシャルを管理するために、`sfBasicSecurityUser`は
いくつかのメソッドを提供します:

    [php]
    // 1つもしくは複数のクレデンシャルを追加する
    $user->addCredential('foo');
    $user->addCredentials('foo', 'bar');

    // ユーザーがクレデンシャルを持つかチェックする
    echo $user->hasCredential('foo');                      =>   true

    // ユーザーが両方のクレデンシャルを持つかチェックする
    echo $user->hasCredential(array('foo', 'bar'));        =>   true

    // ユーザーがクレデンシャルの1つを持つかチェックする
    echo $user->hasCredential(array('foo', 'bar'), false); =>   true

    // クレデンシャルを削除する
    $user->removeCredential('foo');
    echo $user->hasCredential('foo');                      =>   false

    // すべてのクレデンシャルを削除する(ログアウト処理の際に便利)
    $user->clearCredentials();
    echo $user->hasCredential('bar');                      =>   false

Jobeetバックエンドに関して、プロファイルは1つ: 管理者しかないで
クレデンシャルは使いません。

プラグイン
----------

車輪の再発明をしたくないので、ゼロからログインアクションを開発しません。
代わりに、**symfonyプラグイン**をインストールします。

symfonyフレークワークの偉大な強みの1つは
[プラグインのエコシステム](http://www.symfony-project.org/plugins/)です。
来たる日に見ますが、プラグインを作るのはとても簡単です。
プラグインは設定からモジュールとアセットまで任意のものを格納できるのでこれはとても強力でもあります。

<propel>
今日は、バックエンドアプリケーションをセキュアにするために
[`sfGuardPlugin`](http://www.symfony-project.org/plugins/sfGuardPlugin)
をインストールします:

    $ php symfony plugin:install sfGuardPlugin
</propel>
<doctrine>
今日は、バックエンドアプリケーションをセキュアにするために
[`sfDoctrineGuardPlugin`](http://www.symfony-project.org/plugins/sfDoctrineGuardPlugin)をインストールします

    $ php symfony plugin:install sfDoctrineGuardPlugin
</doctrine>

`plugin:install`タスクは名前でプラグインをインストールします。
すべてのプラグインは`plugins/`ディレクトリの元に保存され
それぞれのプラグインはプラグインの名前から名づけた独自のディレクトリを持ちます。

>**NOTE**
>`plugin:install`タスクを動作させるにはPEARをインストールしなければなりません。

`plugin:install`タスクでプラグインをインストールするとき、
symfonyは最新の安定版をインストールします。
プラグインの特定バージョンをインストールするには、`--release`オプションを渡します。

<propel>
[プラグインページ](http://www.symfony-project.org/plugins/sfGuardPlugin?tab=plugin_all_releases)
はsymfonyバージョンによってグループ化されるすべてのバージョンの一覧を示します。

プラグインはディレクトリに自己展開しますが、symfony公式サイトから
[パッケージをダウンロード](http://www.symfony-project.org/plugins/sfGuardPlugin?tab=plugin_installation)
して解答する、もしくは代わりに
[Subversionリポジトリ](http://svn.symfony-project.com/plugins/sfGuardPlugin)
への`svn:externals`リンクを作成します。

>**TIP**
>`config/ProjectConfiguration.class.php`クラスで`enableAllPluginsExcept()`メソッドを使わなかった場合、
>インストールした後でプラグインを必ず有効にすることを覚えておいてください。

</propel>
<doctrine>
[プラグインページ](http://www.symfony-project.org/plugins/sfDoctrineGuardPlugin?tab=plugin_all_releases)
は
symfonyのバージョンでグループ化された利用可能なすべてのバージョンの一覧を表示します。

プラグインはディレクトリに内蔵され、
symfony公式サイトから[パッケージをダウンロード](http://www.symfony-project.org/plugins/sfDoctrineGuardPlugin?tab=plugin_installation)
して解凍することが可能で、
代わりに
[Subversionリポジトリ](http://svn.symfony-project.com/plugins/sfDoctrineGuardPlugin)への`svn:externals`リンクを作成します。

>**TIP**
>`config/ProjectConfiguration.class.php`クラスの`enableAllPluginsExcept()`メソッドを使わなかった場合、
>プラグインをインストールした後でプラグインを必ず有効にすることを覚えておいてください。

</doctrine>

バックエンドのセキュリティ
--------------------------

それぞれのプラグインには
設定方法を説明している[README](http://www.symfony-project.org/plugins/sfGuardPlugin?tab=plugin_readme)
ファイルが含まれます。

新しいプラグインの作り方を見てみましょう。
ユーザー、グループ、とパーミッションを管理する新しいモデルクラスを提供するので、
モデルをリビルドする必要があります:

<propel>
    $ php symfony propel:build-all-load --no-confirmation
</propel>
<doctrine>
    $ php symfony doctrine:build-all-reload
</doctrine>

>**TIP**
<propel>
>`propel:build-all-load`タスクは既存のすべてのテーブルを削除することを覚えておいてください
</propel>
<doctrine>
>`doctrine:build-all-reload`タスクは既存のすべてのテーブルを削除することを覚えておいてください
</doctrine>
>これらを再生成する前に。これを避けるには、モデル、フォーム、フィルタをビルドし、
>`data/sql/`に保存されている生成SQLステートメントを実行して
>新しいテーブルを作成します。.

新しいクラスを作るときは、常にsymfonyのキャッシュをクリアする必要があります:

    $ php symfony cc

<propel>
`sfGuardPlugin`はユーザークラスにいくつかのメソッドを追加するので、
`myUser`の基底クラスを`sfGuardSecurityUser`に変更する必要があります:
</propel>
<doctrine>
`sfDoctrineGuardPlugin`はユーザークラスにいくつかのメソッドを追加するので、
`myUser`の基底クラスを`sfGuardSecurityUser`に変更する必要があります:
</doctrine>

    [php]
    // apps/backend/lib/myUser.class.php
    class myUser extends sfGuardSecurityUser
    {
    }

<propel>
`sfGuardPlugin`はユーザーを認証する`signin`アクションを
`sfGuardAuth`モジュールに提供します。
</propel>
<doctrine>
`sfDoctrineGuardPlugin`はユーザーを認証する`signin`メソッドを
`sfGuardAuth`モジュールに提供します。
</doctrine>

ログインページ用に使われるデフォルトのアクションを変更するために
`settings.yml`ファイルを編集します:

    [yml]
    # apps/backend/config/settings.yml
    all:
      .settings:
        enabled_modules: [default, sfGuardAuth]

        # ...

      .actions:
        login_module:    sfGuardAuth
        login_action:    signin

        # ...

プラグインは1つのプロジェクトのすべてのアプリケーションで共有されるので、
モジュールを`enabled_modules`設定に追加することで
使いたいモジュールを明示的に有効にする必要があります。

![sfGuardPluginのログイン](http://www.symfony-project.org/images/jobeet/1_2/13/sf_guard_login.png)

最後のステップは管理者ユーザーを作成することです:

    $ php symfony guard:create-user fabien SecretPass
    $ php symfony guard:promote fabien

>**TIP**
>`sfGuardPlugin`はコマンドラインからユーザー、グループ、とパーミッションを
>管理するタスクを提供します。
>`guard`名前空間に所属するすべてのタスクの一覧を表示するには`list`タスクを使います:
>
>     $ php symfony list guard

ユーザーが認証されていないとき、メニューバーを隠す必要があります:

    [php]
    // apps/backend/templates/layout.php
    <?php if ($sf_user->isAuthenticated()): ?>
      <div id="menu">
        <ul>
<propel>
          <li><?php echo link_to('Jobs', '@jobeet_job') ?></li>
          <li><?php echo link_to('Categories', '@jobeet_category') ?></li>
</propel>
<doctrine>
          <li><?php echo link_to('Jobs', '@jobeet_job_job') ?></li>
          <li><?php echo link_to('Categories', '@jobeet_category_category') ?></li>
</doctrine>
        </ul>
      </div>
    <?php endif; ?>

ユーザーが認証されたとき、メニューに~ログアウト~リンクを追加する必要があります:

    [php]
    // apps/backend/templates/layout.php
    <li><?php echo link_to('Logout', '@sf_guard_signout') ?></li>

>**TIP**
>`sfGuardPlugin`によって提供されるすべてのルートの一覧を表示するには、`app:routes`タスクを使います。

Jobeetバックエンドにさらに磨きをかけるには、
管理者ユーザーを管理する新しいモジュールを追加しましょう。
ありがたいことに、`sfGuardPlugin`はそのようなモジュールを提供してくれます。`sfGuardAuth`モジュールに関して、`settings.yml`でこれを有効にする必要があります:

    [yml]
    // apps/backend/config/settings.yml
    all:
      .settings:
        enabled_modules: [default, sfGuardAuth, sfGuardUser]

メニューにリンクを追加します:

    [php]
    // apps/backend/templates/layout.php
    <li><?php echo link_to('Users', '@sf_guard_user') ?></li>

![バックエンドのメニュー](http://www.symfony-project.org/images/jobeet/1_2/13/menu.png)

やりました！

ユーザーのテスト
----------------

ユーザーのテストの話をしていないので今日のチュートリアルは終わっていません。
symfonyブラウザはCookieをシミュレートするので、
組み込みの[`sfTesterUser`](http://symfony-project.org/api/1_2/sfTesterUser)テスターによって
使用されるユーザーのふるまいをテストするのはとても簡単です。

今日追加したメニュー機能用の機能テストを更新しましょう。
`job`モジュールの機能テストの末端に次のコードを追加します:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      info('4 - User job history')->

      loadData()->
      restart()->

      info('  4.1 - When the user access a job, it is added to its history')->
      get('/')->
      click('Web Developer', array(), array('position' => 1))->
      get('/')->
      with('user')->begin()->
        isAttribute('job_history', array($browser->getMostRecentProgrammingJob()->getId()))->
      end()->

      info('  4.2 - A job is not added twice in the history')->
      click('Web Developer', array(), array('position' => 1))->
      get('/')->
      with('user')->begin()->
        isAttribute('job_history', array($browser->getMostRecentProgrammingJob()->getId()))->
      end()
    ;

テスト作業を楽にするには、フィクスチャデータをリロードして
クリーンなセッションで始めるためにブラウザを再起動します。

`isAttribute()`メソッドは渡されたユーザー属性をチェックします。

>**NOTE**
>`sfTesterUser`テスターはユーザーの認証と権限付与をテストするために
>`isAuthenticated()`と`hasCredential()`メソッドも提供します。

また明日
--------

symfonyのユーザークラスはPHPセッションの管理を抽象化するための良い手段です。
symfonyの偉大なプラグインシステムと`sfGuardPlugin`プラグインを結びつけることで
短時間でJobeetバックエンドをセキュアにすることができました。
またプラグインによって提供されたモジュールのおかげで、
自由に管理者ユーザーを管理できるクリーンなインターフェイスも追加しました。


__ORM__
