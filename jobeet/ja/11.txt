11日目: フォームをテストする
============================

昨日はsymfonyで最初にフォームを作りました。
Jobeetで新しい求人を投稿できますが、テストを追加する前に
時間切れになりました。

これが今日行うことです。
この先、フォームフレームワークについてさらに詳しく学びます。

>**SIDEBAR**
>symfony無しでフォームフレームワークを使う
>
>symfonyフレームワークコンポーネントはよく~デカップリング~されています。
>このことはMVCフレームワーク全体を利用せずにそれらの大部分を利用できることを意味します。
>これはフォームフレームワークに当てはまります。これはsymfonyに依存していません。
>`lib/form/`、`lib/widgets/`、と`lib/validators/`ディレクトリを入手できることで
>任意のPHPアプリケーションで利用できます。
>
>別の再利用可能なコンポーネントはルーティングフレームワークです。
>非symfonyプロジェクトに`lib/routing/`ディレクトリをコピーし、自由にプリティURLの恩恵を得られます。
>
>コンポーネントは**~symfonyプラットフォーム~**から独立しています:
>
>![symfonyプラットフォーム](http://www.symfony-project.org/images/jobeet/1_2/11/platform.png)

フォームを投稿する
-----------------

job作成とバリデーション処理用の機能~テスト~を
追加するために`jobActionsTest`ファイルを開きましょう。

ファイルの終わりに、job作成ページを取得するために次のコードを追加します:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()
    ;

既にリンクのクリックをシミュレートするために`click()`メソッドを使いました。
同じ`click()`メソッドは~フォーム~を投稿するために使用できます。
フォームに関して、メソッドの2番目の引数としてそれぞれのフィールドに対して投稿する値を渡すことができます。
実際のブラウザのように、ブラウザオブジェクトはフォームのデフォルト値と投稿された値をマージします。

フィールドの値を渡すために、これらの名前を知る必要があります。
ソースコードを開くもしくはFirefox Web Developer Toolbar "Forms > Display Form
Details"昨日を使う場合、
`company`フィールド用の名前が
`jobeet_job[company]`であることがわかります。

>**NOTE**
>PHPが`jobeet_job[company]`のような名前を持つ入力フィールドに遭遇するとき、
>自動的にこれを名前が`jobeet_job`である配列に変換します。

より明確にするために、`JobeetJobForm`の`configure()`メソッドの終わりで
次のコードを追加することでフォーマットを`job[%s]`に変更してみましょう:

    [php]
<propel>
    // lib/form/JobeetJobForm.class.php
</propel>
<doctrine>
    // lib/form/doctrine/JobeetJobForm.class.php
</doctrine>
    $this->widgetSchema->setNameFormat('job[%s]');

この変更の後で、名前の`company`はブラウザで`job[company]`になります。
"Preview your job"ボタンを実際にクリックして
有効な値をフォームに渡しましょう:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()->

      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'url'          => 'http://www.sensio.com/',
        'logo'         => sfConfig::get('sf_upload_dir').'/jobs/sensio-labs.gif',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'description'  => 'You will work with symfony to develop websites for our customers.',
        'how_to_apply' => 'Send me an email',
        'email'        => 'for.a.job@example.com',
        'is_public'    => false,
      )))->

      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'create')->
      end()->
    ;

アップロードするファイルの絶対パスを渡すと
ブラウザは~ファイルのアップロード~もシミュレートします。

フォームを投稿した後で、実行されたアクションが`create`であることを確認しました。

フォームテスター
----------------

投稿したフォームは有効になります。
**フォームテスター**を利用してこれをテストできます:

    [php]
    with('form')->begin()->
      hasErrors(false)->
    end()->

フォームテスターはエラーのような現在のフォームステータスをテストするための
メソッドをいくつか持ちます。

テストで間違いをする場合、テストはパスしないので、
9日目で見たように`with('response')->~debug~()`ステートメントを利用できます。
しかし、エラーメッセージを確認するために生成されたHTMLを掘り下げなければなりません。
これは本当に便利ではありません。フォームテスターはフォームのステータスと
それに関連したすべてのエラーメッセージを出力する`debug()`メソッドも提供します:

    [php]
    with('form')->debug()

リダイレクトのテスト
--------------------

フォームが有効なので、jobが作成されユーザーは
`show`ページに~リダイレクト~されます:

    [php]
    isRedirected()->
    followRedirect()->

    with('request')->begin()->
      isParameter('module', 'job')->
      isParameter('action', 'show')->
    end()->

`isRedirected()`はページがリダイレクトされるかどうかをテストし
`followRedirect()`メソッドはリダイレクトをフォローします。

>**NOTE**
>ブラウザクラスは自動的にリダイレクトにフォローしません。
> リダイレクトの前にオブジェクトをイントロスペクトするとよいでしょう。

##ORM## テスター
----------------

結局、jobがデータベースに作成されたことをテストしユーザーがまだ公開していないので
`is_activated`カラムが`false`に設定されていることを
チェックしたい場合を考えます。

これは別の~テスター~、**##ORM## テスター**を利用することで簡単にできます。
##ORM## テスターは登録されていないので、今追加してみましょう:

<propel>
    [php]
    $browser->setTester('propel', 'sfTesterPropel');
</propel>
<doctrine>
    [php]
    $browser->setTester('doctrine', 'sfTesterDoctrine');
</doctrine>

データベースの1つもしくは複数のオブジェクトが引数として渡されたcriteriaにマッチすることをチェックする
##ORM## テスターは`check()`メソッドを提供します。

    [php]
<propel>
    with('propel')->begin()->
</propel>
<doctrine>
    with('doctrine')->begin()->
</doctrine>
      check('JobeetJob', array(
        'location'     => 'Atlanta, USA',
        'is_activated' => false,
        'is_public'    => false,
      ))->
    end()

<propel>
criteriaは上記のような値の配列もしくは 
もしくはより複雑なクエリに対する`Criteria`インスタンスになります。
3番目の引数としてBooleanを持つcriteriaにマッチするオブジェクトの存在
(デフォルトは`true`)、もしくは整数として渡されることでマッチするオブジェクトの数をテストできます。
</propel>
<doctrine>
criteriaは上記のような値の配列もしくは
より複雑なクエリに対する`Doctrine_Query`インスタンスになります。
3番目の引数としてBooleanを持つcriteriaにマッチするオブジェクトの存在
(デフォルトは`true`)、もしくは整数として渡されることでマッチするオブジェクトの数をテストできます。
</doctrine>

~エラー~をテストする
--------------------

有効な値を投稿するときにjob ~フォーム~ 作成は期待通りに動作します。
有効ではないデータを投稿するときに振る舞いをチェックするテストを追加してみましょう:

    [php]
    $browser->
      info('  3.2 - Submit a Job with invalid values')->

      get('/job/new')->
      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'email'        => 'not.an.email',
      )))->

      with('form')->begin()->
        hasErrors(3)->
        isError('description', 'required')->
        isError('how_to_apply', 'required')->
        isError('email', 'invalid')->
      end()
    ;

`hasErrors()`メソッドは整数としてパスする場合にエラーの数をテストできます。
`isError()`メソッドは渡されたフィールド用のエラーコードをテストします。

>**TIP**
>テストにおいて有効ではないデータの投稿に対して書き、
>繰り返しフォーム全体を再テストしませんでした。
>特定の内容に対してのみテストを追加しました。

エラーメッセージが含まれるかどうか確認するために生成された~HTML~もテストできますが、
フォームのレイアウトをカスタマイズしていないので、我々の場合は必要ありません。

これで、jobプレビューページで見つかるadminバーをテストする必要があります。
jobがまだアクティベイトされていないとき、jobを編集、削除もしくは公開できます。
これら3つのリンクをテストするには、最初にjobを作成する必要があります。
しかし、それはたくさんのコピー＆ペーストが行われます。
電子ツリーを無駄遣いしたくないので、
`JobeetTestFunctional`クラスのjob作成メソッドを追加しましょう:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function createJob($values = array())
      {
        return $this->
          get('/job/new')->
          click('Preview your job', array('job' => array_merge(array(
            'company'      => 'Sensio Labs',
            'url'          => 'http://www.sensio.com/',
            'position'     => 'Developer',
            'location'     => 'Atlanta, USA',
            'description'  => 'You will work with symfony to develop websites for our customers.',
            'how_to_apply' => 'Send me an email',
            'email'        => 'for.a.job@example.com',
            'is_public'    => false,
          ), $values)))->
          followRedirect()
        ;
      }

      // ...
    }

`createJob()`メソッドはjobを作成し、リダイレクトにフォローして
流れるようなインターフェイスを壊さないようにブラウザを返します。
デフォルトの値にマージされる値の配列を渡すことができます。

リンクの~HTTPメソッド~を強制する
--------------------------------

"Publish"リンクのテストはよりシンプルです:

    [php]
    $browser->info('  3.3 - On the preview page, you can publish the job')->
      createJob(array('position' => 'FOO1'))->
      click('Publish', array(), array('method' => 'put', '_with_csrf' => true))->

<propel>
      with('propel')->begin()->
</propel>
<doctrine>
      with('doctrine')->begin()->
</doctrine>
        check('JobeetJob', array(
          'position'     => 'FOO1',
          'is_activated' => true,
        ))->
      end()
    ;

10日目を覚えていれば、"Publish"リンクはHTTP `~PUT~`メソッドで呼び出せるように設定できます。
ブラウザは`PUT`リクエストを理解しないので、
`link_to()`ヘルパーはリンクをJavaScript付きのフォームに変換します。
テストブラウザはJavaScriptを実行しないので、`click()`メソッドの3番目のオプションとして渡すことで、
メソッドに`PUT`を強制する必要があります。
さらに、`link_to()`ヘルパーは~CSRFトークン~も埋め込ます。
1日目にCSRFの保護を有効にしたので; `_with_csrf`オプションはこのトークンをシミュレートします。

"Delete"リンクのテストはよく似ています:

    [php]
    $browser->info('  3.4 - On the preview page, you can delete the job')->
      createJob(array('position' => 'FOO2'))->
      click('Delete', array(), array('method' => 'delete', '_with_csrf' => true))->

<propel>
      with('propel')->begin()->
</propel>
<doctrine>
      with('doctrine')->begin()->
</doctrine>
        check('JobeetJob', array(
          'position' => 'FOO2',
        ), false)->
      end()
    ;

SafeGuardとしてのテスト
-----------------------

jobが公開されるとき、もはや編集できません。
以前のページで"Edit"リンクがもはや表示されなくても、 
この要件用のテストを追加しましょう。

最初に、jobの公開を自動的にできるようにするために
別の引数を`createJob()`メソッドに追加し、
位置の値に渡されるjobを返す`getJobByPosition()`メソッドを作ります:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function createJob($values = array(), $publish = false)
      {
        $this->
          get('/job/new')->
          click('Preview your job', array('job' => array_merge(array(
            'company'      => 'Sensio Labs',
            'url'          => 'http://www.sensio.com/',
            'position'     => 'Developer',
            'location'     => 'Atlanta, USA',
            'description'  => 'You will work with symfony to develop websites for our customers.',
            'how_to_apply' => 'Send me an email',
            'email'        => 'for.a.job@example.com',
            'is_public'    => false,
          ), $values)))->
          followRedirect()
        ;

        if ($publish)
        {
          $this->
            click('Publish', array(), array('method' => 'put', '_with_csrf' => true))->
            followRedirect()
          ;
        }

        return $this;
      }

<propel>
      public function getJobByPosition($position)
      {
        $criteria = new Criteria();
        $criteria->add(JobeetJobPeer::POSITION, $position);

        return JobeetJobPeer::doSelectOne($criteria);
      }
</propel>
<doctrine>
      public function getJobByPosition($position)
      {
        $q = Doctrine_Query::create()
          ->from('JobeetJob j')
          ->where('j.position = ?', $position);

        return $q->fetchOne();
      }
</doctrine>

      // ...
    }

jobが公開された場合、編集ページは~404~ステータスコードを返さなければなりません:

    [php]
    $browser->info('  3.5 - When a job is published, it cannot be edited anymore')->
      createJob(array('position' => 'FOO3'), true)->
      get(sprintf('/job/%s/edit', $browser->getJobByPosition('FOO3')->getToken()))->

      with('response')->begin()->
        isStatusCode(404)->
      end()
    ;

しかしテストを実行する場合、昨日はこの~セキュリティ~のmeasureを
実装するのを忘れたので、期待した結果は得られません。
すべてのエッジケースを考える必要があるので、テストを書くことはバグを発見するための偉大な方法でもあります。

jobがアクティブである場合、404エラーページにリダイレクトすることだけが必要なので、
バグの修正はとてもシンプルです:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeEdit(sfWebRequest $request)
    {
      $job = $this->getRoute()->getObject();
      $this->forward404If($job->getIsActivated());

      $this->form = new JobeetJobForm($job);
    }

修正はささいなことですが、すべてがまだ期待通りに動作すると思っていますか？
ブラウザを開き編集ページにアクセスする可能な組み合わせのテストすべてを始めることができます。
しかしよりシンプルな方法があります: テストスィートを実行します; 
~回帰テスト~を導入していれば、symfonyはすぐに教えてくれます。

テストで未来に戻る
------------------

jobが5日以内に期限切れするとき、もしくは既に期限切れしている場合、
ユーザーは現在の日付から30日後の期間にjobのバリデーションを拡張できます。

ブラウザでこの要件をテストするのは簡単ではありません。
将来の30日にjobが作成されるとき期限の日付が自動的に設定されるからです。
ですので、jobページを取得するとき、jobを拡張するリンクは存在しません。 
もちろん、データベースで期限日をハックする、
もしくはリンクを表示するためにテンプレートを調整できますが、
これは退屈でエラーになりがちです。
ご明察のとおり、
テストを書くことで時間の節約になります。

常に、最初に`extend`メソッド用の新しいルートを追加する必要があります:

    [yml]
    # apps/frontend/config/routing.yml
    job:
      class:   sfPropelRouteCollection
      options:
        model:          JobeetJob
        column:         token
        object_actions: { publish: PUT, extend: PUT }
      requirements:
        token: \w+

それから、`_admin`パーシャルの"Extend"リンクコードを更新します:

    [php]
    <!-- apps/frontend/modules/job/templates/_admin.php -->
    <?php if ($job->expiresSoon()): ?>
     - <?php echo link_to('Extend', 'job_extend', $job, array('method' => 'put')) ?> for another <?php echo sfConfig::get('app_active_days') ?> days
    <?php endif; ?>

それから、`extend`アクションを作ります:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeExtend(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $this->forward404Unless($job->extend());

<propel>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extended until %s.', $job->getExpiresAt('m/d/Y')));
</propel>
<doctrine>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extended until %s.', date('m/d/Y', strtotime($job->getExpiresAt()))));
</doctrine>

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

アクションによって要求されるように、jobが延長された場合`JobeetJob`の`extend()`メソッドは
`true`を返しそうでなければ`false`を返します:

<propel>
    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function extend()
      {
        if (!$this->expiresSoon())
        {
          return false;
        }

        $this->setExpiresAt(time() + 86400 * sfConfig::get('app_active_days'));

        return $this->save();
      }

      // ...
    }
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJob.class.php
    class JobeetJob extends BaseJobeetJob
    {
      public function extend()
      {
        if (!$this->expiresSoon())
        {
          return false;
        }

        $this->setExpiresAt(date('Y-m-d', time() + 86400 * sfConfig::get('app_active_days')));

        $this->save();

        return true;
      }

      // ...
    }
</doctrine>

最終的に、テストのシナリオを追加します:

    [php]
    $browser->info('  3.6 - A job validity cannot be extended before the job expires soon')->
      createJob(array('position' => 'FOO4'), true)->
      call(sprintf('/job/%s/extend', $browser->getJobByPosition('FOO4')->getToken()), 'put', array('_with_csrf' => true))->
      with('response')->begin()->
        isStatusCode(404)->
      end()
    ;

    $browser->info('  3.7 - A job validity can be extended when the job expires soon')->
      createJob(array('position' => 'FOO5'), true)
    ;

    $job = $browser->getJobByPosition('FOO5');
<propel>
    $job->setExpiresAt(time());
</propel>
<doctrine>
    $job->setExpiresAt(date('Y-m-d'));
</doctrine>
    $job->save();

    $browser->
      call(sprintf('/job/%s/extend', $job->getToken()), 'put', array('_with_csrf' => true))->
      with('response')->isRedirected()
    ;

<propel>
    $job->reload();
    $browser->test()->is(
      $job->getExpiresAt('y/m/d'),
      date('y/m/d', time() + 86400 * sfConfig::get('app_active_days'))
    );
</propel>
<doctrine>
    $job->refresh();
    $browser->test()->is(
      date('y/m/d', strtotime($job->getExpiresAt())),
      date('y/m/d', time() + 86400 * sfConfig::get('app_active_days'))
    );
</doctrine>

このテストのシナリオは少数の内容を導入します:

 * `call()`メソッドは`GET`もしくは`POST`からメソッドで
   URLを読み取ります。
<propel>
 * アクションで求人情報を更新した後で、
   `$job->reload()`でローカルオブジェクトをリロードする必要があります。
</propel>
<doctrine>
 * アクションで求人情報を更新した後で、
   `$job->refresh()`でローカルオブジェクトをリロードする必要があります。
</doctrine>
 * 最後に、新しい期限日付をテストするために埋め込みの`lime`オブジェクトを
   直接使います。

フォームのセキュリティ
---------------------

### フォームのシリアライズマジック！

##ORM## ~フォーム~は多くの作業を自動化するのでとても便利です。
例えば、フォームをデータベースにシリアライズするに
`$form->save()`を呼び出すだけです。


しかしどのように動作するのでしょうか？基本的に、`save()`メソッドは次のステップに従います:

 * トランザクションを始める(入れ子の ##ORM## フォームは一度に
   すべて保存されます)
 * 投稿された値を処理する(値が存在する場合に
   `updateCOLUMNColumn()`メソッドを呼び出す)
 * カラムの値を更新するために ##ORM## オブジェクトの`fromArray()`メソッドを呼び出す
 * オブジェクトをデータベースに保存する
 * トランザクションをコミットする

### 組み込みのセキュリティ機能

`fromArray()`メソッドは値の配列を受け取り対応するカラムの値を更新します。 
これは~セキュリティ~問題をあらわすのでしょうか？
認証されていない人がカラムに対して値を投稿しようとしたらどうなるでしょうか？
例えば、`token`カラムを強制できるでしょうか？

`token`フィールドでjobの投稿をシミュレートするテストを書いてみましょう:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      get('/job/new')->
      click('Preview your job', array('job' => array(
        'token' => 'fake_token',
      )))->

      with('form')->begin()->
        hasErrors(7)->
        hasGlobalError('extra_fields')->
      end()
    ;

フォームを投稿するとき、`extra_fields`グローバルエラーを用意しなければなりません。
デフォルトのフォームは追加フィールドが投稿された値に存在すること許可しないからです。
すべてのフォームフィールドは関連したバリデータ
を持たなければならない理由でもあります。

>**TIP**
>Firefox Web Developer Toolbarのようなツールを利用して
>ブラウザから追加フィールドも楽に投稿できます。

`allow_extra_fields`オプションを`true`に設定することでこのセキュリティ対策を回避できます
:

    [php]
    class MyForm extends sfForm
    {
      public function configure()
      {
        // ...

        $this->validatorSchema->setOption('allow_extra_fields', true);
      }
    }

テストはパスしなければなりませんが`token`の値は値からフィルタリングされました。
ですので、またセキュリティ対策を回避できません。
しかし本当に値が欲しい場合、`filter_extra_fields`オプションを`false`に設定します:

    [php]
    $this->validatorSchema->setOption('filter_extra_fields', false);

>**NOTE**
>このセクションで書かれたテストはデモンストレーションの目的用のみです。
>テストはsymfonyの機能をバリデートする必要がないので
>これらをJobeetプロジェクトから削除できます。

### ~XSS~と~CSRF~の保護

1日目において、次のコマンドラインで
`frontend`アプリケーションを作成しました:

    $ php symfony generate:app --escaping-strategy=on
       ➥ --csrf-secret=Unique$ecret frontend

`--escaping-strategy`オプションはXSSに対する保護を有効にします。
これはテンプレートで使われるすべての変数がデフォルトでエスケープされることを意味します。 
HTMLタグ内部でjobの説明を投稿しようとすると、symfonyがjobページをレンダリングするとき、 
説明文からのHTMLタグがインタープリターで処理されず、
プレーンなテキストとしてレンダリングされていることに気がつきます。

`--csrf-secret`オプションはCSRFの保護を有効にしました。
このオプションを提供するとき、すべてのフォームは`_csrf_token`隠しフィールドを埋め込みます。

>**TIP**
>`apps/frontend/config/~settings.yml~`設定ファイルを編集することで、
>escaping_strategyとcsrf_secretはいつでも変更できます。
>`databases.yml`ファイルに関して、個々の設定は環境によって設定可能です:
>
>     [yml]
>     all:
>       .settings:
>         # Form security secret (CSRF protection)
>         csrf_secret: Unique$ecret
>
>         # Output escaping settings
>         escaping_strategy: on
>         escaping_method:   ESC_SPECIALCHARS

メンテナンスタスク
------------------

symfonyがウェブフレームワークであるとしても、~コマンドライン~ツールが付属しています。
プロジェクトとアプリケーションのデフォルトのディレクトリ構造を作るおよび
モデル用の様々なファイルを生成するためにも使ってきました。
symfonyコマンドラインで使われるツールはフレームワークでパッケージとしてまとめられているので、新しい~タスク~を追加するのはとても簡単です。

ユーザーがjobを作成するとき、オンラインに設置するためにこれをアクティベイトしなければなりません。
しかしそうでなければ、データベースは古いjobで膨れ上がります。
データベースから古いjobを削除するタスクを作りましょう。
このタスクはcronジョブで定期的に実行しなければなりません。

    [php]
    // lib/task/JobeetCleanupTask.class.php
    class JobeetCleanupTask extends sfBaseTask
    {
      protected function configure()
      {
        $this->addOptions(array(
<doctrine>
          new sfCommandOption('application', null, sfCommandOption::PARAMETER_REQUIRED, 'The application', 'frontend'),
</doctrine>
          new sfCommandOption('env', null, sfCommandOption::PARAMETER_REQUIRED, 'The environement', 'prod'),
          new sfCommandOption('days', null, sfCommandOption::PARAMETER_REQUIRED, '', 90),
        ));

        $this->namespace = 'jobeet';
        $this->name = 'cleanup';
        $this->briefDescription = 'Cleanup Jobeet database';

        $this->detailedDescription = <<<EOF
    The [jobeet:cleanup|INFO] task cleans up the Jobeet database:

      [./symfony jobeet:cleanup --env=prod --days=90|INFO]
    EOF;
      }

      protected function execute($arguments = array(), $options = array())
      {
        $databaseManager = new sfDatabaseManager($this->configuration);

<propel>
        $nb = JobeetJobPeer::cleanup($options['days']);
        $this->logSection('propel', sprintf('Removed %d stale jobs', $nb));
</propel>
<doctrine>
        $nb = Doctrine::getTable('JobeetJob')->cleanup($options['days']);
        $this->logSection('doctrine', sprintf('Removed %d stale jobs', $nb));
</doctrine>
      }
    }

タスクの設定は`configure()`メソッドで行われます。
それぞれのタスクはユニークな名前(`namespace`:`name`)、と引数とオプションを持たなければなりません。

>**TIP**
>使い方の例はsymfony組み込みのタスク(`lib/task/`)を眺めて下さい。

`jobeet:cleanup`タスクは良識のあるデフォルトを伴う
2つのオプション: `--env`と`--days`を定義します。

タスクの実行はsymfony組み込みの他のタスクと同じです:

    $ php symfony jobeet:cleanup --days=10 --env=dev

常に、データベースのクリーンナップは
`JobeetJobPeer`クラスで行われます:

<propel>
    [php]
    // lib/model/JobeetJobPeer.php
    static public function cleanup($days)
    {
      $criteria = new Criteria();
      $criteria->add(self::IS_ACTIVATED, false);
      $criteria->add(self::CREATED_AT, time() - 86400 * $days, Criteria::LESS_THAN);

      return self::doDelete($criteria);
    }

`doDelete()`メソッドは与えられた`Criteria`オブジェクトにマッチするデータベースのレコードを削除します。
このメソッドは主キーの配列を受け取ることもできます。
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJobTable.class.php
    public function cleanup($days)
    {
      $q = $this->createQuery('a')
        ->delete()
        ->andWhere('a.is_activated = ?', 0)
        ->andWhere('a.created_at < ?', date('Y-m-d', time() - 86400 * $days));

      return $q->execute();
    }
</doctrine>

>**NOTE**
>タスクの成功に従って値を返すので
>symfonyのタスクは環境に応じた振る舞いをします。
>タスクの最後で明示的に整数を返すことで戻り値を強制できます。

また明日
--------

テストはsymfonyの哲学とツールの中心です。
開発プロセスを簡単で、速く、より重要で、安全にするために
今日は、symfonyのツールの活用方法を再び学びました。

symfonyフォームフレームワークはウィジェットバリデータ以外にもたくさんの機能を提供します:
フォームをテストする方法を提供しフォームがデフォルトでセキュアであることを保証します。

symfonyの偉大な機能のツアーは今日で終わりません。 
明日は、Jobeet用のバックエンドアプリケーションを作ります。
バックエンドインターフェイスは大抵のウェブプロジェクトで必須であり、Jobeetは難しくありません。
しかし1時間以内にこのようなインターフェイスを開発する方法は？
シンプルです。symfonyのadminジェネレータフレームワークを使います。
それまでは、お元気で。

__ORM__
