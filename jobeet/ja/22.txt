22日目: キャッシュ
==================

今日は、キャッシュの話をします。symfonyフレームワークは多くの組み込みのキャッシュ戦略を持ちます。
例えば、YAML設定ファイルは最初にPHPに変換されそれからファイルシステムに保存されます。
adminジェネレータによって生成されたモジュールがベターなパフォーマンスのためにキャッシュされることも
既に見てきました。

しかし今日は、別のキャッシュ: HTMLキャッシュを話します。
ウェブサイトのパフォーマンスを改善するために、HTMLページ全体もしくはそれらの一部だけをキャッシュできます。

新しい環境を作成する
--------------------

デフォルトでは、symfonyのテンプレートキャッシュ機能は
`test`や`dev`ではなく`prod`環境の`settings.yml`設定ファイルで
有効になります:

    [yml]
    prod:
      .settings:
        cache: on

    dev:
      .settings:
        cache: off

    test:
      .settings:
        cache: off

本番に移行する前にキャッシュ機能をテストする必要があるので、
`dev`環境用のキャッシュを有効にするか新しい環境を作成できます。
環境は名前(文字列)、関連したフロントコントローラ、オプションとして固有の設定値の一式
によって定義されることを思い出しましょう。

Jobeetのキャッシュシステムで遊ぶには、`cache`環境を作成します。
これは`prod`環境と似ていますが、`dev`環境で利用可能なログとデバッグ情報が付随します。

`dev`のフロントコントローラである`web/frontend_dev.php`を
`web/frontend_cache.php`にコピーして
新しい`cache`環境に
関連したフロントコントローラを作成します:

    [php]
    // web/frontend_cache.php
    if (!in_array(@$_SERVER['REMOTE_ADDR'], array('127.0.0.1', '::1')))
    {
      die('You are not allowed to access this file. Check '.basename(__FILE__).' for more information.');
    }

    require_once(dirname(__FILE__).'/../config/ProjectConfiguration.class.php');

    $configuration = ProjectConfiguration::getApplicationConfiguration('frontend', 'cache', true);
    sfContext::createInstance($configuration)->dispatch();

やることはこれだけです。新しい`cache`環境はこれで利用できます。
唯一の違いは`getApplicationConfiguration()`メソッドの2番目の引数で
環境の名前が`cache`になります。

ブラウザでフロントコントローラを呼び出すことで
`cache`環境をテストできます:

    http://jobeet.localhost/frontend_cache.php/

>**NOTE**
>フロントコントローラスクリプトはローカルのIPアドレスからのみ
>呼び出されることを保証するコードで始まります。このセキュリティ対策は
>本番サーバーでフロントコントローラが呼び出されないようにするためです。
>明日のチュートリアルでより詳しく話します。

これで、`cache`環境はデフォルト設定を継承します。
`cache`環境固有の設定を追加するために
`settings.yml`設定ファイルを編集します:

    [yml]
    # apps/frontend/config/settings.yml
    cache:
      .settings:
        error_reporting: <?php echo (E_ALL | E_STRICT)."\n" ?>
        web_debug:       on
        cache:           on
        etag:            off

これらの設定作業において、
symfonyのテンプレートキャッシュ機能は`cache`設定によって有効になり、
デバッグツールバーは`web_debug`設定によって有効になりました。

<propel>
SQLステートメントのロギングもしたいので、データベースの構成を変更する必要があります。
`databases.yml`を編集して
ファイルの始めに次の設定を追加します:

    [yml]
    # config/databases.yml
    cache:
      propel:
        class: sfPropelDatabase
        param:
          classname: DebugPDO
</propel>

デフォルトの構成ではキャッシュのすべての設定をキャッシュするので、
ブラウザで変更を見ることができる前にキャッシュをクリアする必要があります:

    $ php symfony cc

ブラウザをリフレッシュすると、`dev`環境と同じように
ウェブデバッグツールバーがページ右上に出現します。


キャッシュの構成
----------------

symfonyのテンプレートキャッシュは`cache.yml`設定ファイルで設定できます。
アプリケーションのデフォルト構成は`apps/frontend/config/cache.yml`で見つかります:

    [yml]
    default:
      enabled:     off
      with_layout: false
      lifetime:    86400

デフォルトでは、すべてのページは動的な情報を持つことができるので、
グローバルなキャッシュは無効です(`enabled: off`)。
ページ単位でキャッシュを有効にするので
この設定を変更する必要はありません。

`lifetime`設定はサーバーサイドのキャッシュの寿命を
秒単位で定義します(`86400`秒は1日に等しい)。

>**TIP**
>次善策もあります: グローバルでキャッシュを有効にして、
>キャッシュできない特定のページでこれを無効にします。
>アプリケーションに対してどちらが作業が少なくて済むかによります。

ページのキャッシュ
------------------

Jobeetのホームページはウェブサイトの中で恐らく最も訪問されるページになりますので、
ユーザーがアクセスするたびにデータベースからデータをリクエストする代わりに
これをキャッシュできます。

`sfJobeetJob`モジュールに対して`cache.yml`ファイルを作成します:

    [yml]
    # plugins/sfJobeetJob/modules/sfJobeetJob/config/cache.yml
    index:
      enabled:     on
      with_layout: true

>**TIP**
>`cache.yml`設定ファイルは`view.yml`のような
>symfonyの設定ファイル以外は同じプロパティを持ちます。
>特別な`all`キーを使うことでモジュールのすべてのアクションに対して
>キャッシュを有効にできることを意味します。

ブラウザをリフレッシュする場合、コンテンツがキャッシュされたことを示すボックスで
ページがデコレートされているのを見ることになります:

![フレッシュなキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/fresh_cache.png)

ボックスはキャッシュの寿命、
年齢などデバッグのためのキャッシュキーに関する貴重な情報を表示します。

ページを再度リフレッシュすると、ボックスの色が緑から黄色に変わります。
これはページがキャッシュから読み取られたことを示します:

![キャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/cache.png)

2番目のケースでは、ウェブデバッグツールバーで示されるように、
データベースへのリクエストが行われなかったことがわかります。

>**TIP**
>言語をユーザーごとに変更できる場合でも、
>言語がURLに埋め込まれるのでキャッシュは機能します。

ページがキャッシュ可能なときで、キャッシュがまだ存在しない場合、
symfonyはリクエストの最後でレスポンスオブジェクトをキャッシュに保存します。
将来の他のすべてのリクエストに関して、symfonyはコントローラを呼び出さずに
キャッシュされたレスポンスを送信します:

![ページキャッシュのフロー](http://www.symfony-project.org/images/jobeet/1_2/22/flow_cache_page.png)

[JMeter](http://jakarta.apache.org/jmeter/)のようなツールを利用することで自分自身で測定できるので
これはパフォーマンスに大きなインパクトがあります。

>**NOTE**
>`GET`パラメータでやってくるリクエスト、`POST`、
>`PUT`、`DELETE`メソッドで投稿されたリクエストは設定にかかわらず
>symfonyによってキャッシュされることはありません。 

求人作成ページもキャッシュできます:

    [yml]
    # plugins/sfJobeetJob/modules/sfJobeetJob/config/cache.yml
    new:
      enabled:     on

    index:
      enabled:     on

    all:
      with_layout: true

2つのページがレイアウトでキャッシュできるので、
すべての`sfJobeetJob`モジュールセクション用のデフォルト設定を定義する
`all`セクションを作成しました。

キャッシュをクリアする
----------------------

ページのキャッシュをクリアしたい場合、`cache:clear`タスクを使用できます:

    $ php symfony cc

`cache:clear`タスクはメインの`cache/`ディレクトリに保存されたすべてのキャッシュをクリアします。
このタスクはキャッシュの一部を選別してクリアするためのオプションも受け取ります。
`cache`環境用のテンプレートキャッシュのみをクリアするには、
`--type`と`--env`オプションを使います:

    $ php symfony cc --type=template --env=cache

変更を行うたびにキャッシュをクリアする代わりに、
クエリ文字列をURLに追加する、もしくはウェブデバッグツールバーから"Ignore cache"ボタンを使用することで
キャッシュを無効にすることもできます:

![ウェブデバッグツールバー](http://www.symfony-project.org/images/jobeet/1_2/22/debug.png)

アクションのキャッシュ
----------------------

ページ全体をキャッシュできないが、
アクションテンプレート自身はキャッシュできます。
言い換えると、レイアウト以外はすべてをキャッシュできます。

Jobeetアプリケーションに関して、
"history job"バーなのでページ全体をキャッシュできません。

`job`モジュールキャッシュ用の設定を変更します:

    [yml]
    # plugins/sfJobeetJob/modules/sfJobeetJob/config/cache.yml
    new:
      enabled:     on

    index:
      enabled:     on

    all:
      with_layout: false

`with_layout`設定を`false`に変更することで、
レイアウトのキャッシュを無効にしました。

キャッシュをクリアします:

    $ php symfony cc

違いを見るためにブラウザをリフレッシュします:

![アクションキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/action_cache.png)

リクエストのフローが簡略化されたダイアグラムとよく似ている場合でも、
レイアウト無しのキャッシュははるかにリソースを集約します。

![アクションキャッシュのフロー](http://www.symfony-project.org/images/jobeet/1_2/22/flow_cache_action.png)

パーシャルとコンポーネントのキャッシュ
--------------------------------------

高度に動的なサイトに関して、
アクションテンプレート全体をキャッシュすることが不可能なことがあります。
これらのケースの場合、きめ細かいレベルでキャッシュを設定する方法が必要です。
ありがたいことに、パーシャルとコンポーネントもキャッシュできます。

![パーシャルキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/partial_cache.png)

`sfJobeetLanguage`モジュール用の`cache.yml`ファイルを作成することで
`language`コンポーネントをキャッシュしましょう:

    [yml]
    # plugins/sfJobeetJob/modules/sfJobeetLanguage/config/cache.yml
    _language:
      enabled: on

パーシャルもしくはコンポーネントに対してキャッシュを設定するには名前付きのエントリを追加します。
このタイプのキャッシュに対して
`with_layout`オプションは意味がないので考慮されません:

![パーシャルとコンポーネントキャッシュのフロー](http://www.symfony-project.org/images/jobeet/1_2/22/flow_cache_partial.png)

>**SIDEBAR**
>文脈依存であるか？
>
>同じコンポーネントもしくはパーシャルが多くの異なるテンプレートで使用できます。
>例えばjobの`_list.php`パーシャルは`sfJobeetJob`と`sfJobeetCategory`モジュールで使われます。 
>レンダリングは常に同じなので、パーシャルは使われるコンテキストに依存せず
>キャッシュはすべてのテンプレートに対して同じです
>(キャッシュはパラメータの異なる一式に対して明らかに異なります)。
>
>しかし時々、パーシャルもしくはコンポーネントの出力は含まれるアクションに基づいて異なります
>例えば、blogのサイドバーを考えると、
>これはホームページとblog投稿ページでは微妙に違います)。 
>このような場合パーシャルもしくはコンポーネントは文脈依存で、
>`contextual`オプションを`true`に設定することでキャッシュを設定しなければなりません:
>
>     [yml]
>     _sidebar:
>       enabled:    on
>       contextual: true

キャッシュのフォーム
--------------------

フォームが含まれるので求人作成ページをキャッシュに保存することには問題があります。
問題をより理解するために、キャッシュを生成するためにブラウザで"Post a Job"ページに移動します。
それから、セッションクッキーをクリアし、求人の投稿を試します。 
"CSRF attack"を警告するエラーメッセージを見ることになります:

![CSRFとキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/csrf.png)

なぜでしょうか？フロントエンドアプリケーションを作成したときCSRFシークレットを設定したので、 
symfonyはすべてのフォームにCSRFトークンを埋め込みます。
CSRF攻撃から身を守るために、このトークンはユーザーとフォームに対してユニークです。

ページが表示される最初のときに、
生成されたHTMLフォームは現在のユーザーのトークンと一緒にキャッシュに保存されます。
別のユーザーは後からやってくると、キャッシュからのページは最初のユーザーのCSRFトークンと一緒に表示されます。
フォームを投稿するとき、トークンはマッチせず、エラーが投じられます。

フォームをキャッシュに保存するのは適切だと思われますがこの問題を修正するにはどうしたらよいでしょうか？
求人作成フォームはユーザーに依存せず、現在のユーザーに対して何も変更しません。
このような場合、CSRFの防御が不要なので、
CSRFトークンを完全に削除できます:

    [php]
<propel>
    // plugins/sfJobeetPlugin/lib/form/JobeetJobForm.class.php
    class JobeetJobForm extends BaseJobeetJobForm
</propel>
<doctrine>
    // plugins/sfJobeetPlugin/lib/form/doctrine/PluginJobeetJobForm.class.php
    abstract PluginJobeetJobForm extends BaseJobeetJobForm
</doctrine>
    {
<propel>
      public function __construct(BaseObject $object = null, $options = array(), $CSRFSecret = null)
</propel>
<doctrine>
      public function __construct(sfDoctrineRecord $object = null, $options = array(), $CSRFSecret = null)
</doctrine>
      {
        parent::__construct($object, $options, false);
      }

      // ...
    }

この変更の後で、キャッシュをクリアして期待通りに動作するか検証するために
上記のシナリオを再試行してください。

レイアウトに含まれキャッシュに保存されるので、
同じ設定は言語フォームに適用しなければなりません
新しいクラスを作る代わりにデフォルトの`sfLanguageForm`が使われるので、CSRFトークンを削除するために、
`sfJobeetLanguage`モジュールのアクションとコンポーネントからこれを行いましょう:

    [php]
    // plugins/sfJobeetJob/modules/sfJobeetLanguage/actions/components.class.php
    class sfJobeetLanguageComponents extends sfComponents
    {
      public function executeLanguage(sfWebRequest $request)
      {
        $this->form = new sfFormLanguage($this->getUser(), array('languages' => array('en', 'fr')));
        unset($this->form[$this->form->getCSRFFieldName()]);
      }
    }

    // plugins/sfJobeetJob/modules/sfJobeetLanguage/actions/actions.class.php
    class sfJobeetLanguageActions extends sfActions
    {
      public function executeChangeLanguage(sfWebRequest $request)
      {
        $form = new sfFormLanguage($this->getUser(), array('languages' => array('en', 'fr')));
        unset($form[$form->getCSRFFieldName()]);

        // ...
      }
    }

`getCSRFFieldName()`はCSRFトークンを含むフィールドの名前を返します。
このフィールドの割り当てを解除することで、
ウィジェットと関連のバリデータは削除されます。

キャッシュを削除する
--------------------

ユーザーが求人を投稿してアクティベイトするたびに、新しい求人の一覧を表示するために
ホームページをリフレッシュしなければなりません。

リアルタイムで求人をホームページに表示させる必要はないので、 
ベストな戦略はキャッシュの寿命を短くすることです:

    [yml]
    # plugins/sfJobeetJob/modules/sfJobeetJob/config/cache.yml
    index:
      enabled:  on
      lifetime: 600

デフォルトの1日の設定の代わりに、
ホームページのキャッシュは10分ごとに自動的に削除されます。

ユーザーが新しい求人をアクティベイトしたらすぐにホームページを更新したい場合、
キャッシュをクリアする機能を追加するために
`sfJobeetJob`モジュールの>`executePublish()`メソッドを編集します:

    [php]
    // plugins/sfJobeetJob/modules/sfJobeetJob/actions/actions.class.php
    public function executePublish(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $job->publish();

      if ($cache = $this->getContext()->getViewCacheManager())
      {
        $cache->remove('sfJobeetJob/index?sf_culture=*');
        $cache->remove('sfJobeetCategory/show?id='.$job->getJobeetCategory()->getId());
      }

      $this->getUser()->setFlash('notice', sprintf('Your job is now online for %s days.', sfConfig::get('app_active_days')));

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

キャッシュは`sfViewCacheManager`クラスによって管理されます。
`remove()`メソッドは内部URIに関連したキャッシュを削除します。
変数の可能なすべてのパラメータに対するキャッシュを削除するには、`*`を値として使います。
上記のコードで使用した`sf_culture=*`は
symfonyが英語とフランス語のホームページ用のキャッシュを削除することを意味します。

キャッシュが無効なときキャッシュマネージャーは`null`なので、
`if`ブロックで削除するキャッシュをラップしました。

>**SIDEBAR**
>`sfContext`クラス
>
>`sfContext`オブジェクトは
>リクエスト、レスポンス、ユーザーなどのsymfonyのコアオブジェクトへの参照を持ちます。
>`sfContext`はSingletonのように振る舞うので、任意の場所から取得するために、
>`sfContext::getInstance()`ステートメントが利用可能で、symfonyコアオブジェクトにアクセスできます:
>
>     [php]
>     $user = sfContext::getInstance()->getUser();
>
>複数のクラスの1つで`sfContext::getInstance()`を使いたいときは、
>これは文字列の組み合わせを導入するので2度考えてください。
>必要なオブジェクトを引数として渡す方が常にベターです。
>
>`sfContext`をレジストリとして使用し`set()`メソッドを利用して独自オブジェクトを追加することもできます。
>このメソッドは名前とオブジェクトを引数として受け取り
>`get()`メソッドは後でオブジェクトを名前で読み取るために使用できます:
>
>     [php]
>     sfContext::getInstance()->set('job', $job);
>     $job = sfContext::getInstance()->get('job');

キャッシュをテストする
----------------------

始める前に、キャッシュレイヤーを有効にするために
`test`環境用の設定を変更する必要があります:

    [yml]
    # apps/frontend/config/settings.yml
    test:
      .settings:
        error_reporting: <?php echo ((E_ALL | E_STRICT) ^ E_NOTICE)."\n" ?>
        cache:           on
        web_debug:       off
        etag:            off

求人作成ページをテストしましょう:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      info('  7 - Job creation page')->

      get('/fr/')->
      with('view_cache')->isCached(true, false)->

<propel>
      createJob(array('category_id' => $browser->getProgrammingCategory()->getId()), true)->
</propel>
<doctrine>
      createJob(array('category_id' => Doctrine::getTable('CategoryTranslation')->findOneBySlug('programming')->getId()), true)->
</doctrine>

      get('/fr/')->
      with('view_cache')->isCached(true, false)->
      with('response')->checkElement('.category_programming .more_jobs', '/23/')
    ;

`view_cache`テスターはキャッシュをテストするために使用されます。
`isCached()`メソッドは2つのbooleanを受け取ります:

  * ページをキャッシュに入れるかどうか
  * キャッシュにレイアウトが付属するかどうか

>**TIP**
>機能テストフレームワークによって提供されるすべてのツールがあるにせよ、
>ブラウザで問題を診断する方が簡単であることがあります。
>これを実行するのは簡単で`test`環境用のフロントコントローラを作るだけです。
>`log/frontend_test.log`に保存されるログも非常に役立ちます。

また明日
--------

他の多くのsymfonyの機能のように、
symfonyのキャッシュサブフレームワークはとても柔軟なので
開発者はきめ細かいレベルでキャッシュを設定できます。

明日は、アプリケーションのライフサイクルの
一番最後のステップ: 本番サーバーへのデプロイを話します。

__ORM__
