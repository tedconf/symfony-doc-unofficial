22日目: キャッシュ
==================

今日は、~キャッシュ~の話をします。symfonyフレームワークは多くの組み込みのキャッシュ戦略を持ちます。
たとえば、~YAML~~設定|コンフィギュレーション~ファイルは最初にPHPに変換されそれからファイルシステムに保存されます。
adminジェネレーターによって生成されたモジュールがよりよい~パフォーマンス~のためにキャッシュされることもすでに見てきました。

しかし今日は、別のキャッシュ: HTMLキャッシュを話します。
Webサイトのパフォーマンスを改善するために、HTMLページ全体もしくはそれらの一部だけをキャッシュできます。

新しい環境を作成する
--------------------

デフォルトでは、symfonyの~テンプレートキャッシュ|テンプレート(キャッシュ)~機能は`test`や`dev`ではなく`prod`~環境~の`settings.yml`設定ファイルで有効になります:

    [yml]
    prod:
      .settings:
        cache: on

    dev:
      .settings:
        cache: off

    test:
      .settings:
        cache: off

運用に移行する前にキャッシュ機能をテストする必要があるので、`dev`環境用のキャッシュを有効にするか新しい環境を作成できます。
環境は名前(文字列)、関連するフロントコントローラー、オプションとして固有の設定値のセットによって定義されることを思い出しましょう。

Jobeetのキャッシュシステムで遊ぶには、`cache`環境を作成します。
これは`prod`環境と似ていますが、`dev`環境で利用可能なログとデバッグ情報が付属します。

`dev`のフロントコントローラーである`web/frontend_dev.php`を`web/frontend_cache.php`にコピーして新しい`cache`環境に関連するフロントコントローラーを作成します:

    [php]
    // web/frontend_cache.php
    if (!in_array(@$_SERVER['REMOTE_ADDR'], array('127.0.0.1', '::1')))
    {
      die('You are not allowed to access this file. Check '.basename(__FILE__).' for more information.');
    }

    require_once(dirname(__FILE__).'/../config/ProjectConfiguration.class.php');

    $configuration = ProjectConfiguration::getApplicationConfiguration('frontend', 'cache', true);
    sfContext::createInstance($configuration)->dispatch();

作業はこれだけです。新しい`cache`環境はこれで利用できます。
唯一の違いは`getApplicationConfiguration()`メソッドの2番目の引数で環境の名前が`cache`になります。

ブラウザーでフロントコントローラーを呼び出すことで`cache`環境をテストできます:

    http://jobeet.localhost/frontend_cache.php/

>**NOTE**
>フロントコントローラースクリプトはローカルのIPアドレスからのみ呼び出されることを保証するコードで始まります。
>このセキュリティ対策は運用サーバーでフロントコントローラーが呼び出されないようにするためです。
>明日のチュートリアルでより詳しく話します。

これで、`cache`環境はデフォルト設定を継承します。
`cache`環境固有の設定を追加するために`settings.yml`設定ファイルを編集します:

    [yml]
    # apps/frontend/config/settings.yml
    cache:
      .settings:
        error_reporting: <?php echo (E_ALL | E_STRICT)."\n" ?>
        web_debug:       on
        cache:           on
        etag:            off

これらの設定作業において、symfonyのテンプレートキャッシュ機能は`cache`設定によって有効になり、~Webデバッグツールバー~は`web_debug`設定によって有効になりました。

<propel>
SQLステートメントの~ロギング~もしたいので、データベースのコンフィギュレーションを変更する必要があります。
`databases.yml`を編集してファイルの始めに次の設定を追加します:

    [yml]
    # config/databases.yml
    cache:
      propel:
        class: sfPropelDatabase
        param:
          classname: DebugPDO
</propel>

デフォルトのコンフィギュレーションではキャッシュのすべての設定をキャッシュするので、ブラウザーで変更を見ることができる前にキャッシュをクリアする必要があります:

    $ php symfony cc

ブラウザーをリフレッシュすると、`dev`環境と同じようにWebデバッグツールバーがページ右上に出現します。


キャッシュのコンフィギュレーション
--------------------------------

symfonyのテンプレートキャッシュは~`cache.yml`~設定ファイルで設定できます。
アプリケーションのデフォルトコンフィギュレーションは`apps/frontend/config/cache.yml`で見つかります:

    [yml]
    default:
      enabled:     off
      with_layout: false
      lifetime:    86400

デフォルトでは、すべてのページは動的な情報を持つことができるので、グローバルなキャッシュは無効です(`enabled: off`)。
ページ単位でキャッシュを有効にするのでこの設定を変更する必要はありません。

`lifetime`設定はサーバーサイドの~キャッシュの有効期間~を秒単位で定義します(`86400`秒は1日に等しい)。

>**TIP**
>次善策もあります: グローバルでキャッシュを有効にして、キャッシュできない特定のページでこれを無効にします。
>アプリケーションに対してどちらが作業が少なくて済むかによります。

ページのキャッシュ
------------------

JobeetのホームページはWebサイトの中で恐らく最も訪問されるページになりますので、ユーザーがアクセスするたびにデータベースにデータをリクエストする代わりにデータをキャッシュできます。

`sfJobeetJob`モジュールに対して`cache.yml`ファイルを作成します:

    [yml]
    # plugins/sfJobeetPlugin/modules/sfJobeetJob/config/cache.yml
    index:
      enabled:     on
      with_layout: true

>**TIP**
>`cache.yml`設定ファイルは`view.yml`のようなsymfonyの設定ファイル以外は同じプロパティを持ちます。
>特別な`all`キーを使うことでモジュールのすべてのアクションに対してキャッシュを有効にできることを意味します。

ブラウザーをリフレッシュする場合、コンテンツがキャッシュされたことを示すボックスでページがデコレートされているのを見ることになります:

![フレッシュなキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/fresh_cache.png)

ボックスはキャッシュの有効期間、年齢などデバッグのためのキャッシュキーに関する貴重な情報を表示します。

ページを再度リフレッシュすると、ボックスの色が緑から黄色に変わります。
これはページがキャッシュから読み込まれたことを示します:

![キャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/cache.png)

2番目のケースでは、Webデバッグツールバーで示されるように、データベースへのリクエストが行われなかったことがわかります。

>**TIP**
>言語をユーザーごとに変更できる場合でも、言語がURLに埋め込まれるのでキャッシュは機能します。

ページがキャッシュ可能なときで、キャッシュがまだ存在しない場合、symfonyはリクエストの最後でレスポンスオブジェクトをキャッシュに保存します。
将来の他のすべてのリクエストに関して、symfonyはコントローラーを呼び出さずにキャッシュされたレスポンスを送信します:

![ページキャッシュのフロー](http://www.symfony-project.org/images/jobeet/1_2/22/flow_cache_page.png)

[JMeter](http://jakarta.apache.org/jmeter/)のようなツールを利用することで自分自身で測定できるのでこれは~パフォーマンス~に大きなインパクトがあります。

>**NOTE**
>`GET`パラメーターでやってくるリクエスト、`POST`、`PUT`、`DELETE`メソッドで投稿されたリクエストは設定にかかわらずsymfonyによってキャッシュされることはありません。 

求人作成ページもキャッシュできます:

    [yml]
    # plugins/sfJobeetPlugin/modules/sfJobeetJob/config/cache.yml
    new:
      enabled:     on

    index:
      enabled:     on

    all:
      with_layout: true

2つのページがレイアウトでキャッシュできるので、すべての`sfJobeetJob`モジュールセクション用のデフォルト設定を定義する`all`セクションを作成しました。

キャッシュをクリアする
----------------------

ページのキャッシュをクリアしたい場合、`cache:clear`タスクを使用できます:

    $ php symfony cc

`cache:clear`タスクはメインの`cache/`ディレクトリに保存されたすべてのキャッシュをクリアします。
このタスクはキャッシュの一部を選別してクリアするためのオプションも受け取ります。
`cache`環境用のテンプレートキャッシュのみをクリアするには、`--type`と`--env`オプションを使います:

    $ php symfony cc --type=template --env=cache

変更を行うたびにキャッシュをクリアする代わりに、クエリ文字列をURLに追加する、もしくはWebデバッグツールバーから"Ignore cache"ボタンを使うことでキャッシュを無効にすることもできます:

![Webデバッグツールバー](http://www.symfony-project.org/images/jobeet/1_2/22/debug.png)

アクションのキャッシュ
----------------------

ページ全体をキャッシュできないが、~アクション~テンプレート自身はキャッシュできます。
言い換えると、レイアウト以外はすべてをキャッシュできます。

Jobeetアプリケーションに関して、"history job"バーなのでページ全体をキャッシュできません。

`job`モジュール用のキャッシュ設定を変更します:

    [yml]
    # plugins/sfJobeetPlugin/modules/sfJobeetJob/config/cache.yml
    new:
      enabled:     on

    index:
      enabled:     on

    all:
      with_layout: false

`with_layout`設定を`false`に変更することで、レイアウトのキャッシュを無効にしました。

キャッシュをクリアします:

    $ php symfony cc

違いを見るためにブラウザーをリフレッシュします:

![アクションキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/action_cache.png)

リクエストのフローが簡略化されたダイアグラムとよく似ている場合でも、レイアウトなしのキャッシュははるかにリソースを集約します。

![アクションキャッシュのフロー](http://www.symfony-project.org/images/jobeet/1_2/22/flow_cache_action.png)

~パーシャル|パーシャルテンプレート~と~コンポーネント~のキャッシュ
---------------------------------------------------------------

高度に動的なサイトに関して、アクションテンプレート全体をキャッシュすることが不可能なことがあります。
これらのケースの場合、きめ細かいレベルでキャッシュを設定する方法が必要です。
ありがたいことに、パーシャルとコンポーネントもキャッシュできます。

![パーシャルキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/partial_cache.png)

`sfJobeetLanguage`モジュール用の`cache.yml`ファイルを作成することで`language`コンポーネントをキャッシュしましょう:

    [yml]
    # plugins/sfJobeetPlugin/modules/sfJobeetLanguage/config/cache.yml
    _language:
      enabled: on

パーシャルもしくはコンポーネントに対してキャッシュを設定するには名前つきのエントリを追加します。
このタイプのキャッシュに対して`with_layout`オプションは意味がないので考慮されません:

![パーシャルとコンポーネントキャッシュのフロー](http://www.symfony-project.org/images/jobeet/1_2/22/flow_cache_partial.png)

>**SIDEBAR**
>~コンテキスト依存|コンテキスト上のキャッシュ~であるか？
>
>同じコンポーネントもしくはパーシャルが多くの異なるテンプレートで使用できます。
>たとえばjobの`_list.php`パーシャルは`sfJobeetJob`と`sfJobeetCategory`モジュールで使われます。 
>レンダリングは常に同じなので、パーシャルは使われるコンテキストに依存せずキャッシュはすべてのテンプレートに対して同じです(キャッシュはパラメーターの異なる一式に対して明らかに異なります)。
>
>しかし時々、パーシャルもしくはコンポーネントの出力は含まれるアクションに基づいて異なります(たとえば、blogのサイドバーを考えると、これはホームページとblog投稿ページでは微妙に違います)。 
>このような場合パーシャルもしくはコンポーネントはコンテキスト依存で、`contextual`オプションを`true`にセットすることでキャッシュを設定しなければなりません:
>
>     [yml]
>     _sidebar:
>       enabled:    on
>       contextual: true

フォームにおけるキャッシュ
-------------------------

フォームが含まれるので求人作成ページをキャッシュに保存することには問題があります。
問題をより理解するために、キャッシュを生成するためにブラウザーで"Post a Job"ページに移動します。
それから、セッションCookieをクリアし、求人の投稿を試します。 
"~CSRF~攻撃"を警告するエラーメッセージを見ることになります:

![CSRFとキャッシュ](http://www.symfony-project.org/images/jobeet/1_2/22/csrf.png)

なぜでしょうか？
フロントエンドアプリケーションを作成したときCSRF用の秘密の文字列を設定したので、symfonyはすべてのフォームにCSRFトークンを埋め込みます。
CSRF攻撃から身を守るために、このトークンはユーザーとフォームに対してユニークです。

ページが表示される最初のときに、生成されたHTMLフォームは現在のユーザーのトークンと一緒にキャッシュに保存されます。
別のユーザーは後からやってくると、キャッシュからのページは最初のユーザーのCSRFトークンと一緒に表示されます。
フォームを投稿するとき、トークンはマッチせず、エラーが投じられます。

フォームをキャッシュに保存するのは適切だと思われますがこの問題を修正するにはどうしたらよいでしょうか？
求人作成フォームはユーザーに依存せず、現在のユーザーに対して何も変更しません。
このような場合、CSRFの防御が不要なので、CSRFトークンを完全に削除できます:

    [php]
<propel>
    // plugins/sfJobeetPlugin/lib/form/JobeetJobForm.class.php
    class JobeetJobForm extends BaseJobeetJobForm
</propel>
<doctrine>
    // plugins/sfJobeetPlugin/lib/form/doctrine/PluginJobeetJobForm.class.php
    abstract PluginJobeetJobForm extends BaseJobeetJobForm
</doctrine>
    {
<propel>
      public function __construct(BaseObject $object = null, $options = array(), $CSRFSecret = null)
</propel>
<doctrine>
      public function __construct(sfDoctrineRecord $object = null, $options = array(), $CSRFSecret = null)
</doctrine>
      {
        parent::__construct($object, $options, false);
      }

      // ...
    }

この変更の後で、キャッシュをクリアして期待通りに動作するか検証するために上記のシナリオを再試行してください。

レイアウトに含まれキャッシュに保存されるので、同じ設定は言語フォームに適用しなければなりません。
新しいクラスを作る代わりにデフォルトの`sfLanguageForm`が使われるので、CSRFトークンを削除するために、`sfJobeetLanguage`モジュールのアクションとコンポーネントからこれを行いましょう:

    [php]
    // plugins/sfJobeetPlugin/modules/sfJobeetLanguage/actions/components.class.php
    class sfJobeetLanguageComponents extends sfComponents
    {
      public function executeLanguage(sfWebRequest $request)
      {
        $this->form = new sfFormLanguage($this->getUser(), array('languages' => array('en', 'fr')));
        unset($this->form[$this->form->getCSRFFieldName()]);
      }
    }

    // plugins/sfJobeetPlugin/modules/sfJobeetLanguage/actions/actions.class.php
    class sfJobeetLanguageActions extends sfActions
    {
      public function executeChangeLanguage(sfWebRequest $request)
      {
        $form = new sfFormLanguage($this->getUser(), array('languages' => array('en', 'fr')));
        unset($form[$form->getCSRFFieldName()]);

        // ...
      }
    }

`getCSRFFieldName()`はCSRFトークンを含むフィールドの名前を返します。
このフィールドの割り当てを解除することで、ウィジェットと関連バリデーターは削除されます。

~キャッシュを削除する|キャッシュの削除~
--------------------------------------

ユーザーが求人を投稿してアクティベイトするたびに、新しい求人の一覧を表示するためにホームページをリフレッシュしなければなりません。

リアルタイムで求人をホームページに表示させる必要はないので、ベストな戦略はキャッシュの寿命を短くすることです:

    [yml]
    # plugins/sfJobeetPlugin/modules/sfJobeetJob/config/cache.yml
    index:
      enabled:  on
      lifetime: 600

デフォルトの1日の設定の代わりに、ホームページのキャッシュは10分ごとに自動的に削除されます。

ユーザーが新しい求人をアクティベイトしたらすぐにホームページを更新したい場合、キャッシュをクリアする機能を追加するために`sfJobeetJob`モジュールの>`executePublish()`メソッドを編集します:

    [php]
    // plugins/sfJobeetPlugin/modules/sfJobeetJob/actions/actions.class.php
    public function executePublish(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $job->publish();

      if ($cache = $this->getContext()->getViewCacheManager())
      {
        $cache->remove('sfJobeetJob/index?sf_culture=*');
        $cache->remove('sfJobeetCategory/show?id='.$job->getJobeetCategory()->getId());
      }

      $this->getUser()->setFlash('notice', sprintf('Your job is now online for %s days.', sfConfig::get('app_active_days')));

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

キャッシュは`sfViewCacheManager`クラスによって管理されます。
`remove()`メソッドは内部URIに関連するキャッシュを削除します。
変数の可能なすべてのパラメーターに対するキャッシュを削除するには、`*`を値として使います。
上記のコードで使用した`sf_culture=*`はsymfonyが英語とフランス語のホームページ用のキャッシュを削除することを意味します。

キャッシュが無効なときキャッシュマネージャーは`null`なので、`if`ブロックで削除するキャッシュをラップしました。

>**SIDEBAR**
>`sfContext`クラス
>
>~`sfContext`~オブジェクトはリクエスト、レスポンス、ユーザーなどのsymfonyのコアオブジェクトへの参照を持ちます。
>`sfContext`はSingletonのようにふるまうので、任意の場所から取得するために、`sfContext::getInstance()`ステートメントが利用可能で、symfonyコアオブジェクトにアクセスできます:
>
>     [php]
>     $user = sfContext::getInstance()->getUser();
>
>複数のクラスの1つで`sfContext::getInstance()`を使いたいときは、これは~密結合~を導入するので2度考え直してください。
>常に必要なオブジェクトを引数として渡す方がよいです。
>
>~`sfContext`~をレジストリとして利用し`set()`メソッドを使って独自オブジェクトを追加することもできます。
>このメソッドは名前とオブジェクトを引数として受け取り`get()`メソッドは後でオブジェクトを名前で読み取るために使います:
>
>     [php]
>     sfContext::getInstance()->set('job', $job);
>     $job = sfContext::getInstance()->get('job');

~キャッシュをテストする|テスト(キャッシュ)~
------------------------------------------

始める前に、キャッシュレイヤーを有効にするために`test`環境用の設定を変更する必要があります:

    [yml]
    # apps/frontend/config/settings.yml
    test:
      .settings:
        error_reporting: <?php echo ((E_ALL | E_STRICT) ^ E_NOTICE)."\n" ?>
        cache:           on
        web_debug:       off
        etag:            off

求人作成ページをテストしましょう:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      info('  7 - Job creation page')->

      get('/fr/')->
      with('view_cache')->isCached(true, false)->

<propel>
      createJob(array('category_id' => $browser->getProgrammingCategory()->getId()), true)->
</propel>
<doctrine>
      createJob(array('category_id' => Doctrine::getTable('CategoryTranslation')->findOneBySlug('programming')->getId()), true)->
</doctrine>

      get('/fr/')->
      with('view_cache')->isCached(true, false)->
      with('response')->checkElement('.category_programming .more_jobs', '/23/')
    ;

`view_cache`テスターはキャッシュをテストするために使います。
`isCached()`メソッドは2つのbooleanを受け取ります:

  * ページをキャッシュに入れるかどうか
  * キャッシュにレイアウトが付属するかどうか

>**TIP**
>機能テストフレームワークによって提供されるすべてのツールがあるにせよ、ブラウザーで問題を診断する方が簡単であることがあります。
>これを実行するのは簡単で`test`環境用のフロントコントローラーを作るだけです。
>`log/frontend_test.log`に保存される~ログ|ロギング~も非常に役立ちます。

また明日
--------

他の多くのsymfonyの機能のように、symfonyのキャッシュサブフレームワークはとても柔軟なので開発者はきめ細かいレベルでキャッシュを設定できます。

明日は、アプリケーションのライフサイクルの一番最後のステップ: 運用サーバーへのデプロイを話します。

__ORM__
