3日目: データモデル
===================

テキストエディタを開いてPHPコードを書き記したい方は
今日のチュートリアルで開発を進めることを知ったらハッピーになるでしょう。

Jobeetのデータモデルを定義するので、データベースとインタラクトするために
ORMを使い、アプリケーションの最初のモジュールをビルドします。
symfonyが多くの作業を我々の代わりにやってくれるので、
PHPのコードをあまり書かなくても十分な機能を持つウェブモジュールが手に入ります。

<doctrine>

`sfDoctrinePlugin`を有効にする
------------------------------

この記事を読んでいるのであれば、Propelの代わりにDoctrine ORM用のJobeetチュートリアルを終わらせることを決めたことになります。
最初にやるべきことは`sfDoctrinePlugin`を有効にして`sf#PropelPlugin`を無効にすることだけです。`config/ProjectConfiguration.class.php`で次のコードで簡単にできます:

    [php]
    public function setup()
    {
      $this->enablePlugins(array('sfDoctrinePlugin'));
      $this->disablePlugins(array('sf#PropelPlugin'));
    }

すべてのプラグインをデフォルトで有効にしたいのであれば、次のようにできます:

    [php]
    public function setup()
    {
      $this->enableAllPluginsExcept(array('sf#PropelPlugin', 'sfCompat10Plugin'));
    }

>**NOTE**
>この変更の後で、後で`sfDoctrineDatabase`を使うように
>`config/databases.yml`ファイルを設定するまでエラーが表示されます。

これらの変更をした後でキャッシュのクリアを必ず行います。

    $ php symfony cc

チュートリアルの後で見るように、それぞれのプラグインはアセットを埋め込むことができます(画像、スタイルシート)。
新しいプラグインをインストールもしくは有効にするとき、
`plugin:publish-assets`タスクをとしてこれらをインストールします:

    $ php symfony plugin:publish-assets

`web/sf#PropelPlugin`ディレクトリを削除することも必要あります:

    $ rm web/sf#PropelPlugin

>**TIP**
>Propelの代わりにDoctrineを使うときに他に推奨されることは
>Propelへの参照がないクリーンなインストール状態を保つために
>`config/propel.ini`と`config/schema.yml`を削除することです
>
>     $ rm config/propel.ini
>     $ rm config/schema.yml
</doctrine>

リレーションモデル
------------------

昨日のユーザーストーリーでは
プロジェクトの主なオブジェクト: jobs、affiliates、categoriesを詳しく説明しました。
下図は対応するエンティティ関係図です:

![Entity relationship diagram](http://www.symfony-project.org/images/jobeet/1_2/03/diagram.png)

ストーリーで説明したカラムに加えて、
いくつかのテーブルには`created_at`フィールドも追加しています。
symfonyはそのフィールドを見分けて、
レコードが生成されたとき現在のシステム時刻を値としてセットします。
`updated_at`フィールドも同様なものです。
レコードが更新されるとシステム時刻をセットします。

~スキーマ~
---------

job、affiliate、categorieを保存するために、
当然リレーショナルデータベースが必要となります。

しかしsymfonyのようなオブジェクト指向のフレームワークではいつでもオブジェクトを操作したいと考えます。例えば、データベースからレコードを取得するSQL文を書く代わりにオブジェクトを使う方を好みます。

リレーショナルデータベースの情報は
オブジェクトモデルとしてマッピングされなければなりません。
これはありがたいことに[ORMツール](http://en.wikipedia.org/wiki/Object-relational_mapping)を使って実現でき、
symfonyでは2つのORM([Propel](http://propel.phpdb.org/)と[Doctrine](http://www.doctrine-project.org/))をバンドルしています。
このチュートリアルでは##ORM##を使っていきます。

ORMはテーブルと生成する関連クラスとの関係を説明が必要です。
スキーマの記述には2つの方法があります。
それは既存のデータベースから作る方法と、
手書きで作る方法の2つです。

<propel>
>**Note**
>([FabforceのDbdesigner](http://www.fabforce.net/dbdesigner4/)など)で
>データベースをグラフィカルにビルドしたり
>([DB Designer 4 TO Propel Schema
>Converter](http://blog.tooleshed.com/docs/dbd2propel/transform.php)で)`schema.xml`を直接生成できます。

データベースがまだ存在しないのとJobeetのデータベースを見えない状態に保ちたいので、
空の`config/schema.yml`ファイルを編集して
スキーマファイルを手書きで作りましょう:

    [yml]
    # config/schema.yml
    propel:
      jobeet_category:
        id:           ~
        name:         { type: varchar(255), required: true, index: unique }

      jobeet_job:
        id:           ~
        category_id:  { type: integer, foreignTable: jobeet_category,
          ➥ foreignReference: id, required: true }
        type:         { type: varchar(255) }
        company:      { type: varchar(255), required: true }
        logo:         { type: varchar(255) }
        url:          { type: varchar(255) }
        position:     { type: varchar(255), required: true }
        location:     { type: varchar(255), required: true }
        description:  { type: longvarchar, required: true }
        how_to_apply: { type: longvarchar, required: true }
        token:        { type: varchar(255), required: true, index: unique }
        is_public:    { type: boolean, required: true, default: 1 }
        is_activated: { type: boolean, required: true, default: 0 }
        email:        { type: varchar(255), required: true }
        expires_at:   { type: timestamp, required: true }
        created_at:   ~
        updated_at:   ~

      jobeet_affiliate:
        id:           ~
        url:          { type: varchar(255), required: true }
        email:        { type: varchar(255), required: true, index: unique }
        token:        { type: varchar(255), required: true }
        is_active:    { type: boolean, required: true, default: 0 }
        created_at:   ~

      jobeet_category_affiliate:
        category_id:  { type: integer, foreignTable: jobeet_category,
          ➥ foreignReference: id, required: true, primaryKey: true,
          ➥ onDelete: cascade }
        affiliate_id: { type: integer, foreignTable: jobeet_affiliate,
          ➥ foreignReference: id, required: true, primaryKey: true,
          ➥ onDelete: cascade }
</propel>
<doctrine>
データベースがまだ存在せずJobeetデータベースを見えない状態に保ちたいので、
空の`config/doctrine/schema.yml`ファイルを手で編集して
スキーマファイルを作りましょう:

>**TIP**
>プロジェクトに`config/doctrine/`ディレクトリがまだ存在しなければ
>手作業で作成する必要があります:
>
>     $ mkdir config/doctrine

    [yml]
    # config/doctrine/schema.yml
    ---
    JobeetCategory:
      actAs: { Timestampable: ~ }
      columns:
        name: { type: string(255), notnull: true, unique: true }

    JobeetJob:
      actAs: { Timestampable: ~ }
      columns:
        category_id:  { type: integer, notnull: true }
        type:         { type: string(255) }
        company:      { type: string(255), notnull: true }
        logo:         { type: string(255) }
        url:          { type: string(255) }
        position:     { type: string(255), notnull: true }
        location:     { type: string(255), notnull: true }
        description:  { type: string(4000), notnull: true }
        how_to_apply: { type: string(4000), notnull: true }
        token:        { type: string(255), notnull: true, unique: true }
        is_public:    { type: boolean, notnull: true, default: 1 }
        is_activated: { type: boolean, notnull: true, default: 0 }
        email:        { type: string(255), notnull: true }
        expires_at:   { type: timestamp, notnull: true }
      relations:
        JobeetCategory: { local: category_id, foreign: id, foreignAlias: JobeetJobs } 

    JobeetAffiliate:
      actAs: { Timestampable: ~ }
      columns:
        url:       { type: string(255), notnull: true }
        email:     { type: string(255), notnull: true, unique: true }
        token:     { type: string(255), notnull: true }
        is_active: { type: boolean, notnull: true, default: 0 }
      relations:
        JobeetCategories:
          class: JobeetCategory
          refClass: JobeetCategoryAffiliate
          local: affiliate_id
          foreign: category_id
          foreignAlias: JobeetAffiliates

    JobeetCategoryAffiliate:
      columns:
        category_id:  { type: integer, primary: true }
        affiliate_id: { type: integer, primary: true }
      relations:
        JobeetCategory:  { onDelete: CASCADE, local: category_id, foreign: id }
        JobeetAffiliate: { onDelete: CASCADE, local: affiliate_id, foreign: id }
</doctrine>

>**TIP**
>SQLステートメントを書いてテーブルを作成する方法を選んだ場合、
>`propel:build-schema`タスクを実行して、
>対応する`schema.yml`設定ファイルを生成できます:
>
>     $ php symfony propel:build-schema
>
>上記のタスクは`databases.yml`でデータベースを設定することが必要です。
>最後のステップでデータベースの設定の仕方を示します。タスクを実行しようとしても
>スキーマをビルドする対象のデータベースがわからないので現時点ではタスクは動作しません。

スキーマはYAMLフォーマットでのエンティティリレーションダイアグラムの直接の翻訳です。

>**SIDEBAR**
>YAMLフォーマット
>
>[YAML](http://yaml.org/)の公式サイトによれば、YAMLは
>"人間にフレンドリーですべてのプログラミング言語用のデータシリアライゼーション標準"です。
>
>言い換えると、YAMLはデータを記述するためのシンプルな言語です(文字列、
>整数、日付、配列、とハッシュ)。
>
>YAMLにおいて、構造はインデントを通して示され、連番のアイテムはダッシュで示され、
>マップのキー/値の組はコロンによって分離されます。
>YAMLは同じ構造をより短い行で記述するための省略記法を持ちます。
>配列は`[]`で、ハッシュは`{}`で明示的に示されます。
>
>まだYAMLに慣れていなければ、使い始める良い機会です。
>symfonyフレームワークは設定ファイル用にこのフォーマットを広範囲に使っています。
>
>YAMLファイルを編集する際に覚える必要がある大切なことが1つあります:
>**インデントは1つ以上のスペースで行わなければならず、
>タブは使ってはなりません**。

`schema.yml` ファイルは全てのテーブルとカラムの説明を含んでいます。各カラムは下記の情報をつけて記述されます。:

<propel>
  * `type`: カラムの型(`boolean`、`tinyint`、`smallint`、`integer`、
    `bigint`、`double`、`float`、`real`、`decimal`、`char`、`varchar(size)`、
    `longvarchar`、`date`、`time`、`timestamp`、`blob`、と`clob`)
  * `required`: カラムを必須にしたい場合は`true`に設定する
  * `index`: カラム用にインデックスを作りたい場合は`true`に設定する。
    カラムでユニークインデックスを作りたい場合は`unique`に設定する。
  * `primaryKey`: カラムをテーブル用の主キーとして定義する。
  * `foreignTable`, `foreignReference`: 別のテーブルへの外部キーとしてカラムを定義する。

`~`に設定されたカラムはYAMLで`null`を意味します(`id`、`created_at`、と
`updated_at`)、
symfonyはベストの設定を推測します
(`id`に対しては主キー
`created_at`と`updated_at`に対してはタイムスタンプ).

>**NOTE**
>`onDelete`属性は外部キーの`ON DELETE`ビヘイビアを定義し、
>Propelは`CASCADE`、`SETNULL`、と`RESTRICT`をサポートします。
>例えば、`job`レコードが削除されるとき、`jobeet_category_affiliate`にすべての関連したレコードは
>データベースもしくは内在するデータベースエンジンが
>この機能をサポートしない場合はPropelが自動的に削除されます。
</propel>
<doctrine>
  * `type`: カラムの型(`boolean`、`integer`、`float`、`decimal`、
            `string`、`array`、`object`、`blob`、`clob`、`timestamp`、
            `time`、`date`、`enum`、`gzip`)
  * `notnull`: カラムを必須にしたい場合は`true`に設定する。
  * `unique`: カラム用のユニークインデックスを作りたい場合`true`に設定する。

>**NOTE**
>`onDelete`属性は外部キーの`ON DELETE`ビヘイビアを削除し、
>DoctrineはCASCADE`、`SET NULL`、と`RESTRICT`をサポートします。
>例えばjob`レコードが削除されるとき、`jobeet_category_affiliate`に関連した
>すべてのレコードは自動的にデータベースによって自動的に削除されます。
</doctrine>

データベース
------------

symfonyフレームワークはPDOがサポートするすべてのデータベースをサポートします
(MySQL、PostgreSQL、SQLite、Oracle、MSSQL、など)。
[PDO](http://www.php.net/PDO)はPHPに搭載されているデータベース抽象化レイヤーです。

このチュートリアルではMySQLを使いましょう:

    $ mysqladmin -uroot -p create jobeet
    Enter password: mYsEcret ## The password will echo as ********

>**Note**
>使うデータベースエンジンはご自由に選んで下さい。
>ORMが我々に代わってSQLを書くので
>コードを採用するのは難しくありません。

symfonyにJobeetプロジェクト用にこのデータベースを使うことを伝える必要があります:

<propel>
    $ php symfony configure:database
      ➥ "mysql:host=localhost;dbname=jobeet" root mYsEcret
</propel>
<doctrine>
デフォルトの`config/databases.yml`はPropelを参照する接続を含みます。
Doctrineを使っているので、Doctrine用の`config/databases.yml`を再生成するために
これを削除する必要があります。

    $ rm config/databases.yml

Doctrine用に新しいデータベース設定ファイルを生成するために
次のコマンドを実行します:

    $ php symfony configure:database --name=doctrine
      ➥ --class=sfDoctrineDatabase
      ➥ "mysql:host=localhost;dbname=jobeet" root mYsEcret
</doctrine>
`configure:database`タスクはデータベースにアクセスするために3つの引数: 
[PDOのDSN](http://www.php.net/manual/pdo.drivers.php)、ユーザー名、とパスワード
を受け取ります。
開発サーバーでデータベースにアクセスするパスワードが不要であれば、
3番目の引数を省略します。

>**NOTE**
>`configure:database`タスクは
>`config/databases.yml`ファイルに結果を保存します。
>タスクを使う代わりに手動で編集してもOKです。

-

>**CAUTION**
>コマンドラインでデータベースパスワードを渡すのは手軽ですが
>[安全ではありません](http://dev.mysql.com/doc/refman/5.1/ja/password-security.html)。
>環境にアクセスする人に依存するので、パスワードを変更するには
>`config/databases.yml`を編集するとよいでしょう。もちろん、to
>パスワードを安全に保つために、設定ファイルのアクセスモードも
>制限すべきです。

ORM
---

`schema.yml` に書いたデータベースの説明のおかげで、
PDOの##ORM##のビルトイン関数を利用して
テーブルを生成するためのSQL文を作れます:

<doctrine>
最初にSQLを生成するために
スキーマファイルからモデルをビルドしなければなりません。

    $ php symfony doctrine:build-model

モデルが生成されたのでSQLを生成してインサートできます。
</doctrine>

    $ php symfony propel:build-sql

`propel:build-sql`タスクは`data/sql/`ディレクトリで
設定したデータベース用に最適化されたSQLステートメントを生成します:

<propel>
    [sql]
    # snippet from data/sql/lib.model.schema.sql
    CREATE TABLE `jobeet_category`
    (
            `id` INTEGER  NOT NULL AUTO_INCREMENT,
            `name` VARCHAR(255)  NOT NULL,
            PRIMARY KEY (`id`),
            UNIQUE KEY `jobeet_category_U_1` (`name`)
    )Type=InnoDB;
</propel>
<doctrine>
    [sql]
    # snippet from data/sql/schema.sql
    CREATE TABLE jobeet_category (id BIGINT AUTO_INCREMENT, name VARCHAR(255)
    NOT NULL COMMENT 'test', created_at DATETIME, updated_at DATETIME, slug
    VARCHAR(255), UNIQUE INDEX sluggable_idx (slug), PRIMARY KEY(id))
    ENGINE = INNODB;
</doctrine>

実際にデータベース上にテーブルを生成するには、
`propel:insert-sql`タスクを実行する必要があります:

    $ php symfony propel:insert-sql

<propel>
このタスクはテーブルを再生成する前に現在のテーブルを削除するので、
確認ダイアログが出てきます。
`--no-confirmation`オプションを使えば、
その確認ダイアログを無視できるのでバッチに組みこむときは便利です:

    $ php symfony propel:insert-sql --no-confirmation
</propel>

>**TIP**
>コマンドラインツールに関して、symfonyは引数とオプションを受け取ることができます。
>それぞれのタスクにはヘルプメッセージが組み込まれ
>`help`タスクを実行すると表示されます:
>
>     $ php symfony help propel:insert-sql
>
>ヘルプメッセージは利用可能なすべての引数とオプションの一覧を表示し、
>それぞれのデフォルト値および、役に立つ使い方の例を示します。

ORMはテーブルレコードをオブジェクトにマッピングしたPHPクラスも生成します。:

    $ php symfony propel:build-model

`propel:build-model`タスクは`lib/model/`ディレクトリで
データベースとインタラクトするために使用できるPHPファイルを生成します

<propel>
生成されたファイルを見てみると、Propelはテーブル単位で4つのクラスを生成することに
気付くでしょう。例えば`jobeet_job`テーブルの場合は次のようになります:

  * `JobeetJob`: このクラスのオブジェクトは`jobeet_job`テーブルの**単独のレコードを表します**。
                 デフォルトではこのクラスは空です。
  * `BaseJobeetJob`: `JobeetJob`の親クラス。`propel:build-model`を実行するたびに、
                     このクラスはオーバーライドされるので
                     すべてのカスタマイズは`JobeetJob`クラスで行わなければなりません。

  * `JobeetJobPeer`: このクラスは**`JobeetJob`オブジェクトの**コレクションを返す**
                     スタティックメソッドを定義します。
                     デフォルトではこのクラスは空です。
  * `BaseJobeetJobPeer`: `JobeetJobPeer`の親クラス。
                         `propel:build-model`を実行するたびに
                         このクラスはオーバーライドされるので、カスタマイズは
                         `JobeetJobPeer`クラスで行わなければなりません。
</propel>
<doctrine>
生成されたファイルを見てみると、Doctrineがテーブルごとに3つのクラスを生成することに
気がつくでしょう。`jobeet_job`テーブルの場合は次の通りです:

 * `JobeetJob`: このクラスのオブジェクトは`jobeet_job`テーブルの単独のレコードを表します。
                デフォルトではこのクラスは空です。
 * `BaseJobeetJob`: `JobeetJob`の親クラス。
                    `doctrine:build-model`を実行するたびに、このクラスは上書きされるので、
                    すべてのカスタマイズは`JobeetJob`クラスで行わなければなりません。

 * `JobeetJobTable`: このクラスは`JobeetJob`オブジェクトのコレクション
                    を返すメソッドを定義します。 
                    デフォルトではクラスは空です。
</doctrine>

-

レコードのカラム値はアクセサ(`get*()` メソッド)やミューテータ(`set*()`メソッド)を使って
モデルオブジェクトで操作されます:

    [php]
    $job = new JobeetJob();
    $job->setPosition('Web developer');
    $job->save();

    echo $job->getPosition();

    $job->delete();

オブジェクトと一緒に直接リンクする外部キーを定義できます:

    [php]
    $category = new JobeetCategory();
    $category->setName('Programming');

    $job = new JobeetJob();
    $job->setCategory($category);

`propel:build-all` タスクは
この章で行ったタスクを一括してやってくれるショートカットです。
また、Jobeetモデルクラス用のフォームやバリデータを生成するためにこのタスクを今実行します:

    $ php symfony propel:build-all --no-confirmation

今日の最後にアクションにおけるvalidatorを見ることができます。
formsについては10日目にもっと詳しく説明する予定です。

あとで見ることになりますが、symfonyはPHPクラスをオートロードします。
このことはコード内でrequireを使う必要がないということを意味してます。
symfonyが開発者のために自動でやってくれるのはたくさんの事柄の1つです。しかし1点よくないところもあります。
それはsymfonyに新しいクラスを追加したときはキャッシュをクリアする必要があることです。
`propel:build-model`はたくさんのクラスを生成するのでキャッシュをクリアしましょう。:

     $ php symfony cache:clear

>**TIP**
>symfonyタスクは名前空間とタスクの名前で構成されます。
>それぞれのタスクは他のタスクとの曖昧性がない限り短くできます。 
>ですので次のコマンドは`cache:clear`と同等です:
>
>     $ php symfony cache:cl
>     $ php symfony ca:c
>
>`cache:clear`タスクはとてもよく使われるので、
>固有の短縮名を持ちます:
>
>     $ php symfony cc

初期データ
----------

データベースにテーブルが作成されました、しかしデータがありません。
Webアプリケーションでは3種類のデータがあります:

  * **初期データ**: アプリケーションを動作させるのに必要なデータ。
                   例えば、Jobeetだとカテゴリーが必要となります。
                   もしカテゴリーが無ければ誰も仕事を投稿できなくなります。
                   backendにログインできるadminユーザが必要になります。

  * **テストデータ**: アプリケーションのテストに必要です。開発者にとって、
                    ストーリー通りにJobeetが動作するのを確実にするためにテストを書きます。
                    自動化されたテストを書くのが1番良い方法です。
                    テストを動かすたびにテストデータでデータベースをきれいにする必要があります。

  * **ユーザデータ**: アプリケーションが普通の状態でユーザによって作られたデータ

symfonyがデータベースのテーブルを作成するたびに、
すべてのデータは失われます。
初期データを持つデータベースを投入するには、
PHPスクリプトを作る、
もしくは`mysql`プログラムでSQLステートメントを実行します。
しかしニーズはとても共通しているので、symfonyを使ったベターな方法があります: 
`data/fixtures/`ディレクトリにYAMLファイルを作り
データベースでそれらをロードするために
`propel:data-load`タスクを使います。

最初に、次のフィクスチャファイルを作ります:

<propel>
    [yml]
    # data/fixtures/010_categories.yml
    JobeetCategory:
      design:        { name: Design }
      programming:   { name: Programming }
      manager:       { name: Manager }
      administrator: { name: Administrator }

    # data/fixtures/020_jobs.yml
    JobeetJob:
      job_sensio_labs:
        category_id:  programming
        type:         full-time
        company:      Sensio Labs
        logo:         sensio-labs.gif
        url:          http://www.sensiolabs.com/
        position:     Web Developer
        location:     Paris, France
        description:  |
          You've already developed websites with symfony and you want to
          work with Open-Source technologies. You have a minimum of 3
          years experience in web development with PHP or Java and you
          wish to participate to development of Web 2.0 sites using the
          best frameworks available.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_sensio_labs
        email:        job@example.com
        expires_at:   2010-10-10

      job_extreme_sensio:
        category_id:  design
        type:         part-time
        company:      Extreme Sensio
        logo:         extreme-sensio.gif
        url:          http://www.extreme-sensio.com/
        position:     Web Designer
        location:     Paris, France
        description:  |
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
          enim ad minim veniam, quis nostrud exercitation ullamco laboris
          nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor
          in reprehenderit in.

          Voluptate velit esse cillum dolore eu fugiat nulla pariatur.
          Excepteur sint occaecat cupidatat non proident, sunt in culpa
          qui officia deserunt mollit anim id est laborum.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_extreme_sensio
        email:        job@example.com
        expires_at:   2010-10-10
</propel>
<doctrine>
    [yml]
    # data/fixtures/categories.yml
    JobeetCategory:
      design:
        name: Design
      programming:
        name: Programming
      manager:
        name: Manager
      administrator:
        name: Administrator

    # data/fixtures/jobs.yml
    JobeetJob:
      job_sensio_labs:
        JobeetCategory: programming
        type:         full-time
        company:      Sensio Labs
        logo:         sensio-labs.gif
        url:          http://www.sensiolabs.com/
        position:     Web Developer
        location:     Paris, France
        description:  |
          You've already developed websites with symfony and you want to work
          with Open-Source technologies. You have a minimum of 3 years
          experience in web development with PHP or Java and you wish to
          participate to development of Web 2.0 sites using the best
          frameworks available.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_sensio_labs
        email:        job@example.com
        expires_at:   '2010-10-10'

      job_extreme_sensio:
        JobeetCategory:  design
        type:         part-time
        company:      Extreme Sensio
        logo:         extreme-sensio.gif
        url:          http://www.extreme-sensio.com/
        position:     Web Designer
        location:     Paris, France
        description:  |
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
          enim ad minim veniam, quis nostrud exercitation ullamco laboris
          nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor
          in reprehenderit in.

          Voluptate velit esse cillum dolore eu fugiat nulla pariatur.
          Excepteur sint occaecat cupidatat non proident, sunt in culpa
          qui officia deserunt mollit anim id est laborum.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_extreme_sensio
        email:        job@example.com
        expires_at:   '2010-10-10'
</doctrine>

>**NOTE**
>jobフィクスチャファイルは2つの画像を参照します。
>(`http://www.symfony-project.org/get/jobeet/sensio-labs.gif`,
>`http://www.symfony-project.org/get/jobeet/extreme-sensio.gif`)からダウンロードして
>`uploads/jobs/`ディレクトリにこれらを設置します。

フィクスチャファイルはYAMLで記述され、モデルオブジェクトを定義し、
ユニークな名前でラベル付けされます
(例えば、`job_sensio_labs`と`job_extreme_sensio`のラベルがつけられた2つのjobを定義しました)。
このラベルは主キーを定義しなくても関連オブジェクトをリンクするためにとても便利です
(これらはよくauto-incrementがつけられ設定できません)。
例えば、jobの`job_sensio_labs`カテゴリは`programming`で、これは'Programming' カテゴリに渡されるラベルです。

>**TIP**
>YAMLファイルにおいて、(jobフィクスチャファイルの`description`
>カラムのように)文字列が改行を含むとき、
>文字列がいくつかの行に分割されることを示すためにパイプ(`|`)を利用できます

フィクスチャフィルは1つもしくは複数のモデルからオブジェクトを格納できますが、
Jobeetフィクスチャ用にモデルごとに1つのファイルを作ることを決めました。

<propel>
>**TIP**
>ファイルの名前の接頭辞に数字がついてるのに気づいてください。
>これはデータロードの順序をコントロールする簡単な方法です。
>より最近のプロジェクトでいくつかの新しいfixtureファイルを挿入することになったなら、
>現在使ってる番号の間で番号付けをしてやるだけで良いです。
</propel>
<doctrine>
>**NOTE**
>ファイルがロードされる順序を決定するために
>Propelはフィクスチャファイルの接頭辞を番号にすることが必要です。Doctrineではこれは必要ありません。
>外部キーが適切に設定されていることを確認するために
>すべてのフィクスチャはロードされ正しい順序で保存されます。
</doctrine>

フィクスチャファイルにおいて、すべてのカラムの値を定義する必要はありません。
そうでなければ、symfonyはデータベーススキーマで定義されたデフォルトの値を使います。
データベースにデータをロードするためにsymfonyは ##ORM## を使用するので、 
すべての組み込みのビヘイビア(例えば`created_at`もしくは`updated_at`
カラムを自動的に設定するもの)とモデルクラスに追加された
カスタムのビヘイビアが有効になります。

データベースに初期データをロードするには
`propel:data-load`タスクを実行するだけです:

    $ php symfony propel:data-load

>**TIP**
>`propel:build-all-load`タスクは`propel:data-load`タスクが後に続く
>`propel:build-all`タスク用のショートカットです。

<doctrine>
スキーマから生成されたすべての内容を確認するには`doctrine:build-all-reload`タスクを実行します。このタスクによってフォーム、フィルタ、モデルを生成し、データベースを削除してからすべてのテーブルで再び作成します。

    $ php symfony doctrine:build-all-reload
</doctrine>

ブラウザ上での動作確認
----------------------

たくさんのCLIを使いますが、あんまり面白いものではありません。
とりわけWebプロジェクトにとっては。
データベースと情報をやり取りするWebページを作ることができます。

jobのリストを表示方法、既存のjobを編集する方法、jobを削除する方法を見てみましょう。
1日目で説明したように、symfonyプロジェクトは複数のアプリケーションで構成されます。
それぞれのアプリケーションは**モジュール**に分割されます。
1つのモジュールは自己完結したPHPコードの集まりでアプリケーションの機能(例えばAPIモジュール)、
もしくはユーザーがモデルオブジェクトで
実行可能な操作の一式(例えばjobモジュール)です。

symfonyは自動で基本要素を操作できる
モジュールを作ることができます:

    $ php symfony propel:generate-module --with-show
      ➥ --non-verbose-templates frontend job JobeetJob

`propel:generate-module`タスクは`JobeetJob`モデル用の`frontend`アプリケーションの`job`モジュールを生成します。
大抵のsymfonyタスクに関して、ファイルとディレクトリは
`apps/frontend/modules/job/`ディレクトリの元に作られます:

 | ディレクトリ | 説明
 | ------------ | ------------------------
 | `actions/`   | モジュールのアクション
 | `templates/` | モジュールのテンプレート

`actions/actions.class.php`ファイルは
`job`モジュールに対して利用可能なすべての*アクション*を定義します:

 | アクションの名前 | 説明
 | ---------------- | -------------------------------------------------------
 | `index`          | テーブルのレコードを表示する
 | `show`           | 渡されたレコード用にフィールドと値を表示する
 | `new`            | 新しいレコードを作成するフォームを表示する
 | `create`         | 新しいレコードを作成する
 | `edit`           | 既存のレコードを編集するフォームを表示する
 | `update`         | ユーザーが投稿した値に応じてレコードを更新する
 | `delete`         | 渡されたレコードをテーブルから削除する

ブラウザでjobモジュールをテストできます:

     http://jobeet.localhost/frontend_dev.php/job

![jobモジュール](http://www.symfony-project.org/images/jobeet/1_2/03/job.png)

<propel>
仕事の編集を試したいなら、symfonyはカテゴリのテキスト表示が必要となるので例外が表示されます。
PHPのオブジェクト表現は`__toString()`というマジックメソッドを使って定義できます。
カテゴリレコードのテキスト表示は
`JobeetCategory`モデルクラスで定義します。:

    [php]
    // lib/model/JobeetCategory.php
    class JobeetCategory extends BaseJobeetCategory
    {
      public function __toString()
      {
        return $this->getName();
      }
    }

これでカテゴリのテキスト表現をするたびに
`__toString()`メソッドが呼び出されてカテゴリー名が返されます。
他のモデルクラスでも必要となるので
全てのモデルに対して`__toString()`を定義しましょう。:
</propel>
<doctrine>
jobを編集しようとすると、
Categoryのidドロップダウンがすべてのカテゴリの名前のリストを持つことに気がつきます。
それぞれのオプションの値は`__toString()`メソッドから取得されます。

Doctrineは`title`、`name`、`subject`など説明用のカラム名を推測することで基本の`__toString()`メソッドを提供しようとします。
何かカスタマイズしたい場合、独自の`__toString()`メソッドを追加する必要があります。 
`JobeetCategory`モデルは`jobeet_category`テーブルの`name`カラムを利用して`__toString()`メソッドを推測できます。

</doctrine>

    [php]
<propel>
    // lib/model/JobeetJob.php
</propel>
<doctrine>
    // lib/model/doctrine/JobeetJob.class.php
</doctrine>
    class JobeetJob extends BaseJobeetJob
    {
      public function __toString()
      {
        return sprintf('%s at %s (%s)', $this->getPosition(),
         ➥ $this->getCompany(), $this->getLocation());
      }
    }

<propel>
    // lib/model/JobeetAffiliate.php
</propel>
<doctrine>
    // lib/model/doctrine/JobeetAffiliate.class.php
</doctrine>
    class JobeetAffiliate extends BaseJobeetAffiliate
    {
      public function __toString()
      {
        return $this->getUrl();
      }
    }

これで仕事の作成と編集が使えるようになりました。必須項目を空にして保存しようとすると、symfonyはデータベーススキーマから基本バリデーションルールを作ります。

![バリデーション](http://www.symfony-project.org/images/jobeet/1_2/03/validation.png)

明日お会いしましょう
--------------------

今日はここまでです。導入部分で予告しました。
今日は、PHPコードをほとんど書いていませんが、
jobモデル用にwebモジュールに取り組み、
調整とカスタマイズする準備はできています。PHPコードがないことは
バグが存在しないことも意味することを覚えておいて下さい！

まだエネルギーが残っていたら、モジュールとモデル用に生成されたコードを読んで
どのように動くのか理解を深めて下さい。
そうでなければ、気にせずによく寝て下さい。
明日は、ウェブフレームワークで最もよく使われるパラダイムの1つである
[MVCデザインパターン](http://en.wikipedia.org/wiki/Model-view-controller)について話します。

他の日に関しては、今日のコードはJobeet SVNリポジトリから入手できます。
`release_day_03`タグをチェックアウトして下さい:

    $ svn co http://svn.jobeet.org/##ORM_LOWER##/tags/release_day_03/ jobeet/

__ORM__
