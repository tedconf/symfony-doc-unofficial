19日目: 国際化とローカライゼーション
====================================

昨日は、AJAXの良いところを追加することで検索エンジンを終わらせました。

今日は、Jobeetの **国際化** (もしくはi18n)と
**ローカライゼーション** (もしくはl10n)を話します。

[Wikipedia](http://en.wikipedia.org/wiki/Internationalization)より:

>**国際化**とはエンジニアリングの変更無しに
>様々な言語と地域に適応できるようにする
>ソフトウェアアプリケーションの設計プロセスです。
>
>**ローカライゼーション** とはロケール固有のコンポーネントと翻訳テキストを追加することで
>特定の地域もしくは言語用にソフトウェアを適応させるプロセスです。

いつものように、symfonyフレームワークは車輪を再発明しないので
国際化(i18n)とローカライゼーションは[ICU標準](http://www.icu-project.org/)に基づいてサポートされます。

ユーザー
--------

ユーザー無しの国際化はあり得ません。
世界の異なる地域もしくは異なる言語でウェブサイトが利用できるとき、
ユーザーは自身が最もフィットする言語を選ぶことができます。

>**NOTE**
>13日目にsymfonyのUserクラスを既に話しました。

### ユーザーculture

symfonyの国際化とローカライゼーションの機能は**ユーザーculture**に基づいています。
cultureはユーザーの言語と国の組み合わせです。
例えば、フランス語を話すユーザーのcultureは
`fr`でフランス出身のユーザーは`fr_FR`です。

Userオブジェクトの`setCulture()`と`getCulture()`メソッドを呼び出すことで
ユーザーcultureを管理できます:

    [php]
    // アクションにおいて
    $this->getUser()->setCulture('fr_BE');
    echo $this->getUser()->getCulture();

>**TIP**
>[ISO 639-1標準](http://en.wikipedia.org/wiki/ISO_639-1)に従って、
>言語コードは2つの小文字で構成されます。
>[ISO 3166-1標準](http://en.wikipedia.org/wiki/ISO_3166-1)に従って
>国コードは2つの大文字で構成されます。

### オプションとしてのculture

デフォルトでは、ユーザーcultureは
`settings.yml`設定ファイルで設定できます:

    [yml]
    # apps/frontend/config/settings.yml
    all:
      .settings:
        default_culture: it_IT

>**TIP**
>cultureはUserオブジェクトによって管理されるので、これはユーザーセッションに保存されます。
>開発期間に、デフォルトのcultureを変更する場合
>ブラウザで新しい設定を有効にするために
>セッションクッキーをクリアしなければなりません 

ユーザーがJobeetウェブサイトでセッションを始めるとき、
`Accept-Language` HTTPヘッダーによって提供される情報に基づいて
最良のcultureを決定することもできます。

リクエストオブジェクトの`getLanguages()`メソッドは現在のユーザー用に許容される言語の配列を返します。
これはプリファレンスの順序によってソートされます:

    [php]
    // アクションにて
    $languages = $request->getLanguages();

しかし大抵の場合、あなたのウェブサイトでは世界の136の主要な言語は利用できません。
ユーザーが選択した言語とウェブサイトでサポートされる言語を比較することで
`getPreferredCulture()`メソッドはベストな言語を返します:

    [php]
    // アクションにて
    $language = $request->getPreferredCulture(array('en', 'fr'));

以前のコールで、ユーザーが選択した言語に従って返される言語は英語もしくはフランス語のどちらか
何もマッチしない場合は英語(配列の最初の言語)です。

URLのculture
------------

Jobeetウェブサイトは英語とフランス語の両方で利用できます。
URLは単独のリソースのみを表すので、cultureをURLに埋め込まなければなりません。 
これを行うためには、`routing.yml`ファイルを開き、`api_jobs`と`homepage`以外のすべてのルートに対して
特殊な変数`:sf_culture`を追加します。シンプルなルートに関して、
`/:sf_culture`を`url`の前に追加します。
コレクションルートに関して、
`/:sf_culture`で始まる`prefix_path`オプションを追加します。

    [yml]
    # apps/frontend/config/routing.yml
    affiliate:
      class: sfPropelRouteCollection
      options:
        model:          JobeetAffiliate
        actions:        [new, create]
        object_actions: { wait: get }
        prefix_path:    /:sf_culture/affiliate

    category:
      url:     /:sf_culture/category/:slug.:sf_format
      class:   sfPropelRoute
      param:   { module: category, action: show, sf_format: html }
      options: { model: JobeetCategory, type: object }
      requirements:
        sf_format: (?:html|atom)

    job_search:
      url:   /:sf_culture/search
      param: { module: job, action: search }

    job:
      class: sfPropelRouteCollection
      options:
        model:          JobeetJob
        column:         token
        object_actions: { publish: put, extend: put }
        prefix_path:    /:sf_culture/job
      requirements:
        token: \w+

    job_show_user:
      url:     /:sf_culture/job/:company_slug/:location_slug/:id/:position_slug
      class:   sfPropelRoute
<propel>
      options:
        model: JobeetJob
        type: object
        method_for_criteria: doSelectActive
</propel>
<doctrine>
      options:
        model: JobeetJob
        type: object
        method_for_query: retrieveActiveJob
</doctrine>
      param:   { module: job, action: show }
      requirements:
        id:        \d+
        sf_method: get

ルートで`sf_culture`変数が使われるとき、
ユーザーのcultureを変更するためにsymfonyは自動的にこの値を使います。

多言語(`/en/`, `/fr/`, ...)で多くのホームページをサポートする必要があるので、
デフォルトのホームページ(`/`)はユーザーのcultureに従って
適切にローカライズされたページにリダイレクトされなければなりません。
しかし、ユーザーがJobeetに初めて訪問するので、ユーザーがcultureを持たない場合、
そのユーザーのためにcultureが選択されます。

最初に、`myUser`に`isFirstRequest()`メソッドを追加します。
このメソッドはユーザーセッションの一番最初のリクエストに対してのみ`true`を返します:

    [php]
    // apps/frontend/lib/myUser.class.php
    public function isFirstRequest($boolean = null)
    {
      if (is_null($boolean))
      {
        return $this->getAttribute('first_request', true);
      }
      else
      {
        $this->setAttribute('first_request', $boolean);
      }
    }

`localized_homepage`ルートを追加します:

    [yml]
    # apps/frontend/config/routing.yml
    localized_homepage:
      url:   /:sf_culture/
      param: { module: job, action: index }
      requirements:
        sf_culture: (?:fr|en)

セッションの最初のリクエストでユーザーを"ベストな"ホームページにリダイレクトする
ロジックを実装するために`job`モジュールの`index`アクションを変更します:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeIndex(sfWebRequest $request)
    {
      if (!$request->getParameter('sf_culture'))
      {
        if ($this->getUser()->isFirstRequest())
        {
          $culture = $request->getPreferredCulture(array('en', 'fr'));
          $this->getUser()->setCulture($culture);
          $this->getUser()->isFirstRequest(false);
        }
        else
        {
          $culture = $this->getUser()->getCulture();
        }

        $this->redirect('@localized_homepage');
      }

<propel>
      $this->categories = JobeetCategoryPeer::getWithJobs();
</propel>
<doctrine>
      $this->categories = Doctrine::getTable('JobeetCategory')->getWithJobs();
</doctrine>
    }

リクエストの中に`sf_culture`変数が存在しない場合、
ユーザーは`/`のURLに到達することを意味します。
これが当てはまりセッションが新しい場合、選択されたcultureがユーザーのcultureとして使われます。
さもなければユーザーの現在のcultureが使われます。

最後のステップはユーザーを`localized_homepage`のURLにリダイレクトすることです。
symfonyが`sf_culture`変数を自動的に追加するので`sf_culture`変数は
リダイレクトコールに渡されていないことに注意して下さい。

これで、`/it/`のURLに移動しようとすると、
`sf_culture`変数を`en`、もしくは`fr`に制限したので、symfonyは404エラーを返します。
この要件をcultureを埋め込むすべてのルートに追加します:

    [yml]
    requirements:
      sf_culture: (?:fr|en)

cultureのテスト
---------------

実装をテストしましょう。しかしさらにテストを追加する前に、既存のものを修正する必要があります。
すべてのURLは変更されるので、`test/functional/frontend/`の機能テストすべてを編集し
すべてのURLの前に`/en`を追加します。
`lib/test/JobeetTestFunctional.class.php`ファイルのURLも変更することを忘れないで下さい。
テストを正しく修正したことを確認するためにテストスイートを立ち上げます:

    $ php symfony test:functional frontend

ユーザーテスターは現在のユーザーのcultureをテストする`isCulture()`メソッドを提供します。
`jobActionsTest`ファイルを開き次のテストを追加します:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->setHttpHeader('ACCEPT_LANGUAGE', 'fr_FR,fr,en;q=0.7');
    $browser->
      info('6 - User culture')->

      restart()->

      info('  6.1 - For the first request, symfony guesses the best culture')->
      get('/')->
      isRedirected()->followRedirect()->
      with('user')->isCulture('fr')->

      info('  6.2 - Available cultures are en and fr')->
      get('/it/')->
      with('response')->isStatusCode(404)
    ;

    $browser->setHttpHeader('ACCEPT_LANGUAGE', 'en,fr;q=0.7');
    $browser->
      info('  6.3 - The culture guessing is only for the first request')->

      get('/')->
      isRedirected()->followRedirect()->
      with('user')->isCulture('fr')
    ;

言語の切り替え
--------------

cultureを変更するユーザーのために、言語フォームはレイアウトに追加しなければなりません。
フォームフレームワークはそのまま使えるフォームを提供しませんが
国際化されたウェブサイトの共通のニーズなので、
symfonyコアチームは [`sfFormExtraPlugin`](http://www.symfony-project.org/plugins/sfFormExtraPlugin?tab=plugin_readme)を維持しています。
このプラグインはバリデータ、ウィジェット、とフォームを含みます。
これらはsymfonyのメインパッケージに含めることができません。
これらは限定的すぎるもしくは外部依存があるにも関わらず
とても役に立つものだからです。

`plugin:install`タスクでこのプラグインをインストールします:

    $ php symfony plugin:install sfFormExtraPlugin

プラグインは新しいクラスを定義するのでキャッシュをクリアします:

    $ php symfony cc

>**NOTE**
>`sfFormExtraPlugin`はJavaScriptライブラリのような
>外部依存を必要とするウィジェットを含みます。
>リッチな日付セレクタ、WYSIWYGエディタなどもあります。
>たくさんの便利なものが見つかりましたらドキュメントを読むのに時間を割いて下さい。

`sfFormExtraPlugin`プラグインは言語選択を管理するために`sfFormLanguage`フォームを提供します。
言語フォームは次のように
レイアウトに追加できます:

>**NOTE**
>下記のコードは実装されることを意図していません。
>これは間違った方法で何かを実装したくなる方法の例を示したものです。
>symfonyを使って適切に実装する方法を示すことに取りかかります。

    [php]
    // apps/frontend/templates/layout.php
    <div id="footer">
      <div class="content">
        <!-- footer content -->

        <?php $form = new sfFormLanguage(
          $sf_user,
          array('languages' => array('en', 'fr'))
          )
        ?>
        <form action="<?php echo url_for('@change_language') ?>">
          <?php echo $form ?><input type="submit" value="ok" />
        </form>
      </div>
    </div>

問題を見つけられましたか？そうです、フォームオブジェクト作成はViewレイヤーに所属していません。
これはアクションから作成しなければなりません。しかしこのコードはレイアウトにあるので、
すべてのアクションに対してフォームが作成されます。これは実用的なものとはほど遠いものです。
このような場合、**コンポーネント**を使います。コンポーネント(component)はパーシャルに似ていますが
コードが添付されます。軽量のアクションと考えて下さい。

テンプレートからコンポーネントのインクルードは
`include_component()`ヘルパーを使うことで可能です:

    [php]
    // apps/frontend/templates/layout.php
    <div id="footer">
      <div class="content">
        <!-- footer content -->

        <?php include_component('language', 'language') ?>
      </div>
    </div>

ヘルパーは引数としてモジュールとアクションを受け取ります。
3番目の引数はパラメータをコンポーネントに渡すために使われます。

実際にユーザーの言語を変更するコンポーネントとアクションをホストする
`language`モジュールを作成します:

    $ php symfony generate:module frontend language

コンポーネントは`actions/components.class.php`ファイルで定義されます。

今ファイルを作りましょう:

    [php]
    // apps/frontend/modules/language/actions/components.class.php
    class languageComponents extends sfComponents
    {
      public function executeLanguage(sfWebRequest $request)
      {
        $this->form = new sfFormLanguage(
          $this->getUser(),
          array('languages' => array('en', 'fr'))
        );
      }
    }

ご覧の通り、コンポーネントクラスはアクションクラスとよく似ています。

コンポーネント用のテンプレートはパーシャルと同じ命名規約を使います: 
コンポーネントの名前の前にアンダースコア(`_`)をつけます:

    [php]
    // apps/frontend/modules/language/templates/_language.php
    <form action="<?php echo url_for('@change_language') ?>">
      <?php echo $form ?><input type="submit" value="ok" />
    </form>

プラグインはユーザーcultureを変更するアクションを提供しないので、
`change_language`ルートを作成するために
`routing.yml`ファイルを編集します:

    [yml]
    # apps/frontend/config/routing.yml
    change_language:
      url:   /change_language
      param: { module: language, action: changeLanguage }

そして対応するアクションを作成します:

    [php]
    // apps/frontend/modules/language/actions/actions.class.php
    class languageActions extends sfActions
    {
      public function executeChangeLanguage(sfWebRequest $request)
      {
        $form = new sfFormLanguage(
          $this->getUser(),
          array('languages' => array('en', 'fr'))
        );

        $form->process($request);

        return $this->redirect('@localized_homepage');
      }
    }

`sfFormLanguage`クラスの`process()`メソッドは、ユーザーのフォーム投稿に基づいて、
ユーザーcultureの変更を考慮します。

![国際化されたフッター](http://www.symfony-project.org/images/jobeet/1_2/19/footer.png)

国際化
------

### 言語、文字集合、エンコーディング

異なる言語は異なる文字集合を持ちます。
英語はASCII文字のみを使うので最もシンプルですが、
フランス語には"é"のようなアクセント付きの文字があるので少し複雑です。
ロシア語、中国語、アラビア語は文字がASCIIの範囲の外側にあるのではるかに複雑です。
このような言語は完全に異なる文字集合で定義されます。

国際化されたデータを扱うとき、ユニコード標準を使う方がベターです。
ユニコードの背景にあるアイディアはすべての言語のためのすべての文字を含む文字の全体集合です。
ユニコードの問題は単独の文字が21ビットで表されることです。
それゆえ、ウェブに関して、我々はUTF-8を使います。
これはUnicodeコードポイントをオクテットの可変長のシーケンスにマッピングします。
UTF-8において、最もよく使われる言語の文字は3ビット未満でコード化されます。

UTF-8はsymfonyで使われるデフォルトのエンコーディングで、
`settings.yml`設定ファイルで定義されます:

    [yml]
    # apps/frontend/config/settings.yml
    all:
      .settings:
        charset: utf-8

また、symfonyの国際化レイヤーを有効にするには、
`settings.yml`で`i18n`を`on`に設定しなければなりません:

    [yml]
    # apps/frontend/config/settings.yml
    all:
      .settings:
        i18n: on

### テンプレート

国際化されたウェブサイトとは
ユーザーインターフェイスが複数の言語に翻訳されることを意味します。

テンプレートにおいて、言語に依存している文字列は`__()`ヘルパー(アンダースコアは2であることに注意)で
ラップしなければなりません。

`__()`ヘルパーは`I18N`ヘルパーグループの一部です。
これはテンプレートの国際化管理を楽にしているヘルパーを含みます。
このヘルパーグループはデフォルトでロードされないので、
既に`Text`ヘルパーグループに対して行ったように`use_helper('I18N')`で
それぞれのテンプレートに手動で追加するか`standard_helpers`設定を追加することでグローバルにロードする必要があります:

    [yml]
    # apps/frontend/config/settings.yml
    all:
      .settings:
        standard_helpers: [Partial, Cache, I18N]

Jobeetのフッターに対する`__()`ヘルパーの使い方です:

    [php]
    // apps/frontend/templates/layout.php
    <div id="footer">
      <div class="content">
        <span class="symfony">
          <img src="/images/jobeet-mini.png" />
          powered by <a href="http://www.symfony-project.org/">
          <img src="/images/symfony.gif" alt="symfony framework" /></a>
        </span>
        <ul>
          <li>
            <a href=""><?php echo __('About Jobeet') ?></a>
          </li>
          <li class="feed">
            <?php echo link_to(__('Full feed'), '@job?sf_format=atom') ?>
          </li>
          <li>
            <a href=""><?php echo __('Jobeet API') ?></a>
          </li>
          <li class="last">
            <?php echo link_to(__('Become an affiliate'), '@affiliate_new') ?>
          </li>
        </ul>
        <?php include_component('language', 'language') ?>
      </div>
    </div>

>**NOTE**
>`__()`ヘルパーはデフォルトの言語用の文字列を受け取るもしくは
>それぞれの文字列に対してユニークな識別子を使うこともできます。これは単なる好みの問題です。
>Jobeetに関して、テンプレートが読みやすいように先の戦略を使います。

symfonyがテンプレートをレンダリングするとき、`__()`ヘルパーが呼び出されるたびに、
symfonyは現在のユーザーのculture用の翻訳を探します。
翻訳が見つかると、それが使われ、そうでなければ、最初の引数とフォールバックの値として返されます。

すべての翻訳はcatalogueに保存されます。
i18nフレームワークは翻訳を保存するために
たくさんの異なる戦略を提供します。
我々は["XLIFF"](http://en.wikipedia.org/wiki/XLIFF)フォーマットを使用します。
これは標準で最も柔軟なものです。
これはadminジェネレータとsymfonyの大抵のプラグインにも使われます。

>**NOTE**
>保存する他のcatalogueは`gettext`、`MySQL`、と`SQLite`です。
>いつものことですが、
>詳細は[i18n API](http://www.symfony-project.org/api/1_2/i18n)をご覧下さい。

### `i18n:extract`

手動でカタログファイルを作成する代わりに、
組み込みの`i18n:extract`タスクを使います:

    $ php symfony i18n:extract frontend fr --auto-save

`i18n:extract`タスクは`frontend`アプリケーションで`fr`に翻訳される必要のあるすべての文字列を見つけ
対応するカタログを作成もしくは更新します。
`--auto-save`オプションは新しい文字列をcatalogueに保存します。
もう存在しない文字列を自動的に削除するために
`--auto-delete`オプションを使うこともできます。

我々の場合、作成したファイルを投入します:

    [xml]
    <!-- apps/frontend/i18n/fr/messages.xml -->
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE xliff PUBLIC "-//XLIFF//DTD XLIFF//EN"
      "http://www.oasis-open.org/committees/xliff/documents/xliff.dtd">
    <xliff version="1.0">
      <file source-language="EN" target-language="fr" datatype="plaintext"
          original="messages" date="2008-12-14T12:11:22Z"
          product-name="messages">
        <header/>
        <body>
          <trans-unit id="1">
            <source>About Jobeet</source>
            <target/>
          </trans-unit>
          <trans-unit id="2">
            <source>Feed</source>
            <target/>
          </trans-unit>
          <trans-unit id="3">
            <source>Jobeet API</source>
            <target/>
          </trans-unit>
          <trans-unit id="4">
            <source>Become an affiliate</source>
            <target/>
          </trans-unit>
        </body>
      </file>
    </xliff>

それぞれの翻訳はユニークな`id`属性を持つ
`trans-unit`タグで管理されます。
このファイルを編集してフランス語用の翻訳を追加できます:

    [xml]
    <!-- apps/frontend/i18n/fr/messages.xml -->
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE xliff PUBLIC "-//XLIFF//DTD XLIFF//EN"
      "http://www.oasis-open.org/committees/xliff/documents/xliff.dtd">
    <xliff version="1.0">
      <file source-language="EN" target-language="fr" datatype="plaintext"
          original="messages" date="2008-12-14T12:11:22Z"
          product-name="messages">
        <header/>
        <body>
          <trans-unit id="1">
            <source>About Jobeet</source>
            <target>A propos de Jobeet</target>
          </trans-unit>
          <trans-unit id="2">
            <source>Feed</source>
            <target>Fil RSS</target>
          </trans-unit>
          <trans-unit id="3">
            <source>Jobeet API</source>
            <target>API Jobeet</target>
          </trans-unit>
          <trans-unit id="4">
            <source>Become an affiliate</source>
            <target>Devenir un affilié</target>
          </trans-unit>
        </body>
      </file>
    </xliff>

>**TIP**
>XLIFFは標準フォーマットなので、翻訳作業を楽にしてくれるツールがたくさんあります。
>[Open Language Tools](https://open-language-tools.dev.java.net/)は
>XLIFFエディタが統合されたオープンソースのJavaプロジェクトです。

-

>**TIP**
>XLIFFはファイルをベースとしたフォーマットなので、
>symfonyの設定ファイル用に存在する同じ手続きとマージルールも適用できます。
>I18nファイルは、プロジェクト、アプリケーション、もしくはモジュール単位で存在可能で、
>多くの場合個別のファイルはよりグローバルな場所で見つかる翻訳を上書きできます。

### 引数で翻訳

国際化の背景にある主要な原則はセンテンス全体を翻訳することです。 
しかし中には動的な値を埋め込むセンテンスがあります。
Jobeetにおいて、これは"more..."リンク用のホームページに当てはまります:

    [php]
    // apps/frontend/modules/job/templates/indexSuccess.php
    <div class="more_jobs">
      and <?php echo link_to($count, 'category', $category) ?> more...
    </div>

jobsの数は変数で翻訳用のプレースホルダーによって
置き換えられなければなりません:

    [php]
    // apps/frontend/modules/job/templates/indexSuccess.php
    <div class="more_jobs">
      <?php echo __('and %count% more...', array('%count%' => link_to($count, 'category', $category))) ?>
    </div>

翻訳される文字列は"and %count% more..."で`%count%`プレースホルダーは
`__()`ヘルパーに2番目の引数として渡される値のおかげで、
実行時に本当の数値に置き換えられます。

`trans-unit`タグを`messages.xml`ファイルに挿入することで
新しい文字列を手作業で追加するかファイルを自動的に更新するために
`i18n:extract`タスクを使います:

    $ php symfony i18n:extract frontend fr --auto-save

タスクを実行した後で、フランス語翻訳を追加するためにXLIFFファイルを開きます:

    [xml]
    <trans-unit id="5">
      <source>and %count% more...</source>
      <target>et %count% autres...</target>
    </trans-unit>

翻訳された文字列の唯一の要件は
どこかで`%count%`プレースホルダーを使うことです。

数、センテンスへの変化に応じた複数形を持つためにより複雑な文字列がありますが、
すべての言語で必ずしも同じ方法ではありません。
ポーランド語やロシア語のように、
複数形に関して非常に複雑な文法ルールを持つ言語があります。

カテゴリーページにおいて、現在のカテゴリーの求人数が表示されます:

    [php]
    // apps/frontend/modules/category/templates/showSuccess.php
    <strong><?php echo $pager->getNbResults() ?></strong> jobs in this category

センテンスが数に応じて異なる翻訳を持つとき、
`format_number_choice()`ヘルパーが使われます:

    [php]
    <?php echo format_number_choice(
        '[0]No job in this category|[1]One job in this category|(1,+Inf]%count% jobs in this category',
        array('%count%' => '<strong>'.$pager->getNbResults().'</strong>'),
        $pager->getNbResults()
      )
    ?>

`format_number_choice()`ヘルパーは3つの引数を受け取ります:

  * 数に応じて使う文字列
  * プレースホルダーの置き換えの配列
  * 使用するテキストを決定するために使う数

数に応じて翻訳を記述する文字列は
次のようにフォーマットされます:

  * それぞれのpossibilityはパイプ文字(`|`)で隔てられる
  * それぞれの文字列は翻訳の後に続く範囲で構成される

範囲は範囲の数を記述できます:

  * `[1,2]`:     境界値を含めて、1と2の間の値を受け取る
  * `(1,2)`:     境界値は含まず、1と2の間の値を受け取る
  * `{1,2,3,4}`: 集合で定義された値のみが受け取られる
  * `[-Inf,0)`:  負の無限大より大きいもしくは等しく、
                 0よりも小さい値を受け取る
  * `{n: n % 10 > 1 && n % 10 < 5}`: 2, 3, 4, 22, 23, 24のような数にマッチする

文字列の翻訳は他のメッセージ文字列と似ています:

    [xml]
    <trans-unit id="6">
      <source>[0]No job in this category|[1]One job in this category|(1,+Inf]%count% jobs in this category</source>
      <target>[0]Aucune annonce dans cette catégorie|[1]Une annonce dans cette catégorie|(1,+Inf]%count% annonces dans cette catégorie</target>
    </trans-unit>

すべての種類の文字列を国際化する方法を理解したので、
フロントエンドアプリケーションのすべてのテンプレートに対して`__()`コールを追加してみましょう。
バックエンドアプリケーションは国際化しません。

### フォーム

ラベル、エラーメッセージ、とヘルプメッセージのように
フォームクラスは翻訳される必要のある文字列をたくさん含んでいます。
これらすべての文字列はsymfonyによって自動的に国際化されるので、
XLIFFファイルで翻訳を提供することだけが必要です。

>**NOTE**
>不幸なことに、`i18n:extract`タスクは未翻訳の文字列のために
>フォームクラスを解析しません。

### ##ORM## オブジェクト

Jobeetのウェブサイトのために、すべてのテーブルを国際化しません。
求人の投稿をすべて利用可能な言語に翻訳することを
求人の投稿者に質問するのは意味がないからです。
しかしカテゴリーテーブルは明らかに翻訳する必要があります。

##ORM## プラグインはi18nテーブルをネイティブにサポートします。
ローカライズされたデータを含むそれぞれのテーブルに対して、
2つのテーブルを作成する必要があります: 
1つは国際化から独立しているカラムを持ち、
もう一方は国際化するために必要なカラムを持ちます。
2つのテーブルは一対多のリレーションでリンクされます。

`schema.yml`を更新します:

<propel>
    [yml]
    # config/schema.yml
    jobeet_category:
      _attributes:  { isI18N: true, i18nTable: jobeet_category_i18n }
      id:           ~

    jobeet_category_i18n:
      id:           { type: integer, required: true, primaryKey: true,
       ➥ foreignTable: jobeet_category, foreignReference: id }
      culture:      { isCulture: true, type: varchar, size: 7,
       ➥ required: true, primaryKey: true }
      name:         { type: varchar(255), required: true }
      slug:         { type: varchar(255), required: true }

`_attributes`エントリはテーブル用のオプションを定義します。

そしてカテゴリー用のフィクスチャを更新します:

    [yml]
    # data/fixtures/010_categories.yml
    JobeetCategory:
      design:        { }
      programming:   { }
      manager:       { }
      administrator: { }

    JobeetCategoryI18n:
      design_en:        { id: design, culture: en, name: Design }
      programming_en:   { id: programming, culture: en, name: Programming }
      manager_en:       { id: manager, culture: en, name: Manager }
      administrator_en: { id: administrator, culture: en,
       ➥ name: Administrator }

      design_fr:        { id: design, culture: fr, name: Design }
      programming_fr:   { id: programming, culture: fr,
       ➥ name: Programmation }
      manager_fr:       { id: manager, culture: fr, name: Manager }
      administrator_fr: { id: administrator, culture: fr,
       ➥ name: Administrateur }

`i18n`スタブクラスを作るためにモデルをリビルドします:

    $ php symfony propel:build-all --no-confirmation
    $ php symfony cc

`name`と`slug`カラムはi18nテーブルに移動させたので、
`setName()`メソッドを`JobeetCategory`から`JobeetCategoryI18n`に移動させます:

    [php]
    // lib/model/JobeetCategoryI18n.php
    public function setName($name)
    {
      parent::setName($name);

      $this->setSlug(Jobeet::slugify($name));
    }

`JobeetCategoryPeer`の`getForSlug()`メソッドを修正することも必要です:

    [php]
    // lib/model/JobeetCategoryPeer.php
    static public function getForSlug($slug)
    {
      $criteria = new Criteria();
      $criteria->addJoin(JobeetCategoryI18nPeer::ID, self::ID);
      $criteria->add(JobeetCategoryI18nPeer::CULTURE, 'en');
      $criteria->add(JobeetCategoryI18nPeer::SLUG, $slug);

      return self::doSelectOne($criteria);
    }
</propel>
<doctrine>
    [yml]
    # config/doctrine/schema.yml
    JobeetCategory:
      actAs:
        Timestampable: ~
        I18n:
          fields: [name]
          actAs:
            Sluggable: { fields: [name], uniqueBy: [lang, name] }
      columns:
        name: { type: string(255), notnull: true }

`I18n`ビヘイビアを有効にすることで、`JobeetCategoryTranslation`という名前のモデルが
自動的に作成され指定された`fields`がそのモデルに移動させられます。

`I18n`ビヘイビアを有効にして自動的に作成される`JobeetCategoryTranslation`モデルに添付される`Sluggable`ビヘイビアを移動させていることに注目して下さい。
`uniqueBy`オプションはslugがユニークかそうではないかをフィールドが決定することを
`Sluggable`ビヘイビアに伝えます。 
この場合それぞれのslugは`lang`と`name`の組に対してユニークでなければなりません。

カテゴリー用のフィクスチャを更新します:

    [yml]
    # data/fixtures/categories.yml
    JobeetCategory:
      design:
        Translation:
          en:
            name: Design
          fr:
            name: design
      programming:
        Translation:
          en:
            name: Programming
          fr:
            name: Programmation
      manager:
        Translation:
          en:
            name: Manager
          fr:
            name: Manager
      administrator:
        Translation:
          en:
            name: Administrator
          fr:
            name: Administrateur

`JobeetCategoryTable`の`findOneBySlug()`メソッドをオーバーライドすることも必要です。 
Doctrineはモデルのすべてのカラム用のマジックファインダーを提供するので、
Doctrineが提供するデフォルトのマジック機能をオーバーライドするために
`findOneBySlug()`メソッドを作ることが単に必要です。 

カテゴリーが`JobeetCategoryTranslation`テーブルの英語のslugに基づいて読み取られるように
少しの変更を行う必要があります。

    [php]
    // lib/model/doctrine/JobeetCategoryTable.cass.php
    public function findOneBySlug($slug)
    {
      $q = $this->createQuery('a')
        ->leftJoin('a.Translation t')
        ->andWhere('t.lang = ?', 'en')
        ->andWhere('t.slug = ?', $slug);
      return $q->fetchOne();
    }

モデルをリビルドします:

    $ php symfony propel:build-all --no-confirmation
    $ php symfony cc

</doctrine>

>**TIP**
<propel>
>`propel:build-all`はデータベースからすべてのテーブルとデータを削除するので、
</propel>
<doctrine>
>`doctrine:build-all-reload`はデータベースからすべてのテーブルとデータを削除するので、
</doctrine>
>`guard:create-user`タスクでJobeetバックエンドにアクセスするユーザーを
>再作成することを忘れないで下さい。代わりに、フィクスチャファイルを追加できます to add it
>automatically for you.

<propel>
モデルをビルドするとき、
`JobeetCategoryI18n`で定義されたi18nカラムにアクセスしやすくするために
symfonyはメインの`JobeetCategory`オブジェクトに プロキシメソッドを作成します:

    [php]
    $category = new JobeetCategory();

    $category->setName('foo');       // 現在のculture用の名前を設定する
    $category->setName('foo', 'fr'); // フランス語用の名前を設定する

    echo $category->getName();     // 現在のculture用の名前を取得する
    echo $category->getName('fr'); // フランス語用の名前を取得する
</propel>
<doctrine>
`I18n`ビヘイビアを使用するとき、`JobeetCategory`オブジェクトと
`JobeetCategoryTranslation`オブジェクトの間にプロキシが作成されるので
カテゴリーの名前を読み取るためのすべての古い関数はまだ動作し、
現在のculture用の値を読み取ります。

    [php]
    $category = new JobeetCategory();
    $category->setName('foo'); // 現在のculture用の名前を設定する
    $category->getName(); // 現在のculture用の名前を取得する

    $this->setCulture('fr'); // アクションクラスから

    $category->setName('foo'); // フランス語用の名前を設定する
    echo $category->getName(); // フランス語用の名前を取得する
</doctrine>

<propel>
>**TIP**
>データベースリクエストの回数を減らすために、
>通常の`doSelect()`メソッドの代わりに、`doSelectWithI18n()`メソッドを使います。
>これは1つのリクエストでメインオブジェクトとi18nオブジェクトを読み取ります。
>
>     [php]
>     $categories = JobeetCategoryPeer::doSelectWithI18n($c, $culture);
</propel>
<doctrine>
>**TIP**
>データベースリクエストの回数を減らすために、
>クエリに`JobeetCategoryTranslation`をjoinします。
>これは1つのリクエストでメインオブジェクトとi18nオブジェクトを読み取ります。
>
>     [php]
>     $categories = Doctrine_Query::create()
>       ->from('JobeetCategory c')
>       ->leftJoin('c.Translation t WITH t.lang = ?', $culture)
>       ->execute();
>
>上記の`WITH`キーワードはクエリの`ON`条件を自動的に追加する条件を追加します。
>ですので、joinの`ON`条件は最終的に次のようになります。
>
>
>     [sql]
>     LEFT JOIN c.Translation t ON c.id = t.id AND t.lang = ?
</doctrine>

`category`ルートは`JobeetCategory`モデルクラスに結びつけられます。
<propel>
`slug`は`JobeetCategoryI18n`の一部で、
</propel>
<doctrine>
`slug`は
`JobeetCategoryTranslation`の一部で、
</doctrine>
ルートは`Category`オブジェクトを自動的に読み取ることができないからです。ルーティングシステムを手助けするために、
オブジェクト読み取りを考慮するメソッドを作りましょう:

<propel>
    [php]
    // lib/model/JobeetCategoryPeer.php
    class JobeetCategoryPeer extends BaseJobeetCategoryPeer
    {
      static public function doSelectForSlug($parameters)
      {
        $criteria = new Criteria();
        $criteria->addJoin(JobeetCategoryI18nPeer::ID, JobeetCategoryPeer::ID);
        $criteria->add(JobeetCategoryI18nPeer::CULTURE, $parameters['sf_culture']);
        $criteria->add(JobeetCategoryI18nPeer::SLUG, $parameters['slug']);

        return self::doSelectOne($criteria);
      }
</propel>
<doctrine>
既に`findOneBySlug()`をオーバーライドしたので
これらのメソッドが共有されるようにもう少しリファクタリングしましょう。
`findOneBySlugAndCulture()`メソッドを単に使うために
新しい`findOneBySlugAndCulture()`と`doSelectForSlug()`メソッドを作り、`findOneBySlug()`メソッドを変更します。

    [php]
    // lib/model/doctrine/JobeetCategoryTable.class.php
    public function doSelectForSlug($parameters)
    {
      return $this->findOneBySlugAndCulture($parameters['slug'], $parameters['sf_culture']);
    }

    public function findOneBySlugAndCulture($slug, $culture = 'en')
    {
      $q = $this->createQuery('a')
        ->leftJoin('a.Translation t')
        ->andWhere('t.lang = ?', $culture)
        ->andWhere('t.slug = ?', $slug);
      return $q->fetchOne();
    }

    public function findOneBySlug($slug)
    {
      return $this->findOneBySlugAndCulture($slug, 'en');
    }
</doctrine>

    // ...
  }

オブジェクトを読み取る`doSelectForSlug()`メソッドを使うように
`category`ルートに伝えるために`method`オプションを使います:

    [yml]
    # apps/frontend/config/routing.yml
    category:
      url:     /:sf_culture/category/:slug.:sf_format
      class:   sfPropelRoute
      param:   { module: category, action: show, sf_format: html }
      options: { model: JobeetCategory, type: object, method: doSelectForSlug }
      requirements:
        sf_format: (?:html|atom)

カテゴリー用に適切なslugを再生成するために
フィクスチャをリロードする必要があります:

    $ php symfony propel:data-load

これで`category`ルートは国際化され
カテゴリ用のURLは翻訳されたカテゴリslugを埋め込みます:

    /frontend_dev.php/fr/category/programmation
    /frontend_dev.php/en/category/programming

### adminジェネレータ

symfony 1.2.1のバグのため、
`edit`セクションの`title`をコメントアウトする必要があります:

    [yml]
    # apps/backend/modules/category/config/generator.yml
    edit:
      #title: Editing Category "%%name%%" (#%%id%%)

バックエンドに関して、英語とフランス語を
同じフォームで編集できるようにしたいです:

![バックエンドカテゴリー](http://www.symfony-project.org/images/jobeet/1_2/19/backend_categories.png)

`embedI18N()`メソッドを使用することで国際化フォームを埋め込むことができます:

    [php]
    // lib/form/JobeetCategoryForm.class.php
    class JobeetCategoryForm extends BaseJobeetCategoryForm
    {
      public function configure()
      {
<propel>
        unset($this['jobeet_category_affiliate_list']);
</propel>
<doctrine>
        unset(
          $this['jobeet_affiliates_list'],
          $this['created_at'], $this['updated_at']
        );
</doctrine>

        $this->embedI18n(array('en', 'fr'));
        $this->widgetSchema->setLabel('en', 'English');
        $this->widgetSchema->setLabel('fr', 'French');
      }
    }

adminジェネレータインターフェイスは国際化をネイティブでサポートします。
これには20以上の言語の翻訳が付属しており、
新しい翻訳を追加もしくはカスタマイズするのはとても簡単です。
`i18n`ディレクトリ
<propel>
(アプリケーションの`lib/vendor/symfony/lib/plugins/sfPropelPlugin/i18n/`で見つかるadminの翻訳)
</propel>
<doctrine>
(アプリケーションの`lib/vendor/symfony/lib/plugins/sfDoctrinePlugin/i18n/`で見つかるadminの翻訳)
</doctrine>
からカスタマイズしたい言語のファイルをコピーします。
アプリケーションのファイルはsymfonyのものにマージされるので、
修正した文字列をアプリケーションファイルの中だけに留めておきます。

adminジェネレータの翻訳ファイルは、`fr/messages.xml`の代わりに、
`sf_admin.fr.xml`のように名付けられていることに注目して下さい。
実際のところ、`messages`はカタログの名前で、
アプリケーションの異なる部分の間のベターな分離を可能にするために変更できます。`__()`ヘルパーを使うときにデフォルト以外のカタログを使う場合は指定する必要があります:

    [php]
    <?php echo __('About Jobeet', array(), 'jobeet') ?>

上記の`__()`コールにおいて、
symfonyは`jobeet`カタログの"About Jobeet"の文字列を探します。

### テスト

テストの修正は
国際化への移行のための不可欠な部分です。
<propel>
`test/fixtures/010_categories.yml`で定義したフィクスチャをコピーして
</propel>
<doctrine>
`test/fixtures/categories.yml`で定義したフィクスチャファイルをコピーして
</doctrine>
最初に、カテゴリ用のテストフィクスチャを更新します。
`test`環境用のモデルをリビルドします:

<propel>
    $ php symfony propel:build-all-load --no-confirmation --env=test
</propel>
<doctrine>
    $ php symfony doctrine:build-all-reload --no-confirmation --env=test
</doctrine>

正しく動作しているかチェックするためにすべてのテストを立ち上げることができます:

    $ php symfony test:all

>**NOTE**
>Jobeet用のバックエンドインターフェイスを開発したとき、機能テストを書きませんでした。
>しかしsymfonyコマンドラインでモジュールを作成するとき、
>symfonyはテストスタブも生成します。これらのスタブを削除しても安全です。

ローカライゼーション
--------------------

### テンプレート

異なるcultureをサポートすることは日付と数値をフォーマットする異なる方法もサポートすることを意味します。
テンプレートにおいて、現在のユーザーのcultureに基づいて、
これらすべての違いを考慮することを手助けしてくれるいくつかのヘルパーを自由に使えます:

[`Date`](http://www.symfony-project.org/api/1_2/DateHelper)ヘルパーグループにおいて:

 | ヘルパー            | 説明                   |
 | ------------------- | ---------------------- |
 | `format_date()`     | 日付をフォーマットする |
 | `format_datetime()` | 日付をフォーマットする |

[`Number`](http://www.symfony-project.org/api/1_2/NumberHelper)ヘルパーグループにて:

 | ヘルパー            | 説明                   |
 | ------------------- | ---------------------- |
 | `format_number()`   | 数値をフォーマットする |
 | `format_currency()` | 通貨をフォーマットする |

[`I18N`](http://www.symfony-project.org/api/1_2/I18NHelper)ヘルパーグループ
において:

 | ヘルパー            | 説明                            |
 | ------------------- | ------------------------------- |
 | `format_country()`  | 国の名前を表示する              |
 | `format_language()` | 言語の名前を表示する            |

### フォーム

フォームフレームワークはローカライズされたデータ用のウィジェットとバリデータをいくつか提供します:

 * [`sfWidgetFormI18nDate`](http://www.symfony-project.org/api/1_2/sfWidgetFormI18nDate)
 * [`sfWidgetFormI18nDateTime`](http://www.symfony-project.org/api/1_2/sfWidgetFormI18nDateTime)
 * [`sfWidgetFormI18nTime`](http://www.symfony-project.org/api/1_2/sfWidgetFormI18nTime)

 * [`sfWidgetFormI18nSelectCountry`](http://www.symfony-project.org/api/1_2/sfWidgetFormI18nSelectCountry)
 * [`sfWidgetFormI18nSelectCurrency`](http://www.symfony-project.org/api/1_2/sfWidgetFormI18nSelectCurrency)
 * [`sfWidgetFormI18nSelectLanguage`](http://www.symfony-project.org/api/1_2/sfWidgetFormI18nSelectLanguage)

 * [`sfValidatorI18nChoiceCountry`](http://www.symfony-project.org/api/1_2/sfValidatorI18nChoiceCountry)
 * [`sfValidatorI18nChoiceLanguage`](http://www.symfony-project.org/api/1_2/sfValidatorI18nChoiceLanguage)

また明日
--------

symfonyでは国際化とローカライゼーションは第一級市民です。
symfonyはすべての基本的なツールを提供しコマンドラインタスクで素早く実行できるので、
ユーザーにローカライズされたウェブサイトを提供するのはとても簡単です。

明日はsymfonyプロジェクトを編成するためにたくさんのファイルを移動させて異なるアプローチを探求するので、
特別なチュートリアルに備えて下さい。

__ORM__