17日目: 検索
============

2日前、Jobeetのユーザーに最新の求人投稿を配信するフィードを追加しました。
今日は、Jobeetウェブサイトの最新のメイン機能: 検索エンジンを実装することで
ユーザーエクスペリエンスの改善を継続します。

テクノロジー
------------

本題に入る前に、symfonyの歴史を少し語りましょう。
私達はテストやリファクタリングのようなたくさんのベストプラクティスを推奨し、
これらをフレームワーク自身に適用することも試みています。
例えば、私達は有名な"Don't reinvent the wheel"のモットーを好みます。
実際、4年前symfonyフレームワークは2つの既存のオープンソースのソフトウェア: 
MojaviとPropelのグルー(つなぎ合わせるもの)として生まれました。
新しい問題に取り組む必要があるたびに、
1からコーディングする前に要件を満たす既存のライブラリを探します。


今日は、Jobeetに検索エンジンを追加することに取り組みます。
Zend Frameworkは
[Zend Lucene](http://framework.zend.com/manual/ja/zend.search.lucene.html)と
呼ばれる素晴らしいライブラリを提供します。
このライブラリは有名なJava Luceneプロジェクトの移植です。
非常に複雑なタスクである、Jobeet用の別の検索エンジンの作成の代わりに、 
Zend Luceneを利用します。

Zend Luceneのドキュメントページで、ライブラリは次のように説明されています:

>... 完全なPHP5で書かれた汎用のテキスト検索エンジンです。
>ファイルシステムにインデックスを保存しデータベースサーバーを要求しないので、
>PHPで動くウェブサイトのほとんどに検索機能を追加できます。
>Zend_Search_Luceneは次の機能をサポートします:
>
>  * 重要度による検索 - 最初に返される最良の結果
>  * 強力で多彩な検索方式: フレーズ検索、boolean検索、ワイルドカード検索
>    あいまい検索、範囲指定検索など
>  * 指定フィールド検索(例えば、タイトル、著者、内容)

-

>**NOTE**
>この章はZend Luceneライブラリのチュートリアルではありませんが、
>Jobeetウェブサイトに統合する方法; もしくはより一般的に、
>symfonyプロジェクトにサードパーティのライブラリを統合する方法を説明します。
>このテクノロジーに関してもっと情報が欲しければ、
>[Zend Luceneのドキュメント](http://framework.zend.com/manual/ja/zend.search.lucene.html)を参照して下さるようお願いします。

昨日Eメールを送信したので
Zend Frameworkの一部として昨日Zend Luceneを既にインストールしました。


インデックス作成
----------------

Jobeet検索エンジンはユーザーが入力するキーワードにマッチするすべての求人情報を返すことができるようになります。

検索できるようにする前に、求人情報用にインデックスをビルドしなければなりません; 
Jobeetに関して、it will be stored in the `data/`ディレクトリに保存されます。

Zend Luceneはインデックスの存在の有無に対応してインデックスを検索するために2つのメソッドを提供します。
既存のインデックスを返すもしくは新しいものを返す`JobeetJobPeer`クラスのヘルパーメソッドを作りましょう:

    [php]
<propel>
    // lib/model/JobeetJobPeer.php
</propel>
<doctrine>
    // lib/model/doctrine/JobeetJobTable.class.php
</doctrine>
    static public function getLuceneIndex()
    {
      ProjectConfiguration::registerZend();

      if (file_exists($index = self::getLuceneIndexFile()))
      {
        return Zend_Search_Lucene::open($index);
      }
      else
      {
        return Zend_Search_Lucene::create($index);
      }
    }

    static public function getLuceneIndexFile()
    {
      return sfConfig::get('sf_data_dir').'/job.'.sfConfig::get('sf_environment').'.index';
    }

### `save()`メソッド

求人が作成され、更新されもしくは削除されるたびに、インデックスを更新しなければなりません。
求人情報がデータベースにシリアライズされるたびにインデックスが更新されるように
`JobeetJob`を編集します:

<propel>
    [php]
    // lib/model/JobeetJob.php
    public function save(PropelPDO $con = null)
    {
      // ...

      $ret = parent::save($con);

      $this->updateLuceneIndex();

      return $ret;
    }
</propel>
<doctrine>
    [php]
    public function save(Doctrine_Connection $conn = null)
    {
      // ...

      $ret = parent::save($conn);

      $this->updateLuceneIndex();

      return $ret;
</doctrine>

実際の作業を行う`updateLuceneIndex()`メソッドを作ります:

    [php]
<propel>
    // lib/model/JobeetJob.php
</propel>
<doctrine>
    // lib/model/doctrine/JobeetJob.class.php
</doctrine>
    public function updateLuceneIndex()
    {
<propel>
      $index = JobeetJobPeer::getLuceneIndex();
</propel>
<doctrine>
      $index = $this->getTable()->getLuceneIndex();
</doctrine>

      // remove an existing entry
      if ($hit = $index->find('pk:'.$this->getId()))
      {
        $index->delete($hit->id);
      }

      // don't index expired and non-activated jobs
      if ($this->isExpired() || !$this->getIsActivated())
      {
        return;
      }

      $doc = new Zend_Search_Lucene_Document();

      // store job primary key URL to identify it in the search results
      $doc->addField(Zend_Search_Lucene_Field::UnIndexed('pk', $this->getId()));

      // index job fields
      $doc->addField(Zend_Search_Lucene_Field::UnStored('position', $this->getPosition(), 'utf-8'));
      $doc->addField(Zend_Search_Lucene_Field::UnStored('company', $this->getCompany(), 'utf-8'));
      $doc->addField(Zend_Search_Lucene_Field::UnStored('location', $this->getLocation(), 'utf-8'));
      $doc->addField(Zend_Search_Lucene_Field::UnStored('description', $this->getDescription(), 'utf-8'));

      // add job to the index
      $index->addDocument($doc);
      $index->commit();
    }

Zend Luceneは既存のエントリを更新できないので、
インデックスに求人情報が既にある場合に最初に既存のエントリが削除されます。

求人のインデックス作成自身はシンプルです: 主キーは将来の参照用に保存されます。
求人とメインカラム(`position`, `company`,
`location`, and `description`)を検索するとき、インデックスが作成されますが、
結果を表示する本物のオブジェクトを使用するので、インデックスには保存されません。

### ##ORM## トランザクション

求人のインデックス作成に問題がある場合もしくは求人がデータベースに保存されない場合はどうなるでしょうか？
##ORM##とZend Luceneの両方が例外を投げます。
しかしある状況において、対応するインデックス作成をせずにデータベースに求人を保存するかもしれません。 
これが発生するのを防ぐためには、
エラーの場合にトランザクションとロールバックで2つの更新をラップできます:

<propel>
    [php]
    // lib/model/JobeetJob.php
    public function save(PropelPDO $con = null)
    {
      // ...

      if (is_null($con))
      {
        $con = Propel::getConnection(JobeetJobPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
      }

      $con->beginTransaction();
      try
      {
        $ret = parent::save($con);

        $this->updateLuceneIndex();

        $con->commit();

        return $ret;
      }
      catch (Exception $e)
      {
        $con->rollBack();
        throw $e;
      }
    }
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJob.class.php
    public function save(Doctrine_Connection $conn = null)
    {
      // ...

      $conn = $conn ? $conn : $this->getTable()->getConnection();
      $conn->beginTransaction();
      try
      {
        $ret = parent::save($conn);

        $this->updateLuceneIndex();

        $conn->commit();

        return $ret;
      }
      catch (Exception $e)
      {
        $conn->rollBack();
        throw $e;
      }
    }
</doctrine>

### `delete()`

インデックスから削除された求人のエントリを除外するために
`delete()`メソッドをオーバーライドすることも必要です:

<propel>
    [php]
    // lib/model/JobeetJob.php
    public function delete(PropelPDO $con = null)
    {
      $index = JobeetJobPeer::getLuceneIndex();

      if ($hit = $index->find('pk:'.$this->getId()))
      {
        $index->delete($hit->id);
      }

      return parent::delete($con);
    }
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJob.class.php
    public function delete(Doctrine_Connection $conn = null)
    {
      $index = $this->getTable()->getLuceneIndex();

      if ($hit = $index->find('pk:'.$this->getId()))
      {
        $index->delete($hit->id);
      }

      return parent::delete($conn);
    }
</doctrine>

<propel>
### 大規模な削除

`propel:data-load`タスクでフィクスチャをロードするとき、
symfonyは`JobeetJobPeer::doDeleteAll()`メソッドを呼び出すことで既存の求人レコードをすべて削除します。
インデックスも一緒に削除するように
デフォルトの振る舞いをオーバーライドしましょう:

    [php]
    // lib/model/JobeetJobPeer.php
    public static function doDeleteAll($con = null)
    {
      if (file_exists($index = self::getLuceneIndexFile()))
      {
        sfToolkit::clearDirectory($index);
        rmdir($index);
      }

      return parent::doDeleteAll($con);
    }
</propel>

検索する
--------

用意が整ったので、フィクスチャのデータのインデックスを作成するために
これらをリロードできます:

    $ php symfony propel:data-load --env=dev

インデックスは環境に依存していてタスク用のデフォルト環境は`cli`なので
タスクは`--env`オプション付きで実行します。

>**TIP**
>Unix系のユーザーのために: インデックスはコマンドラインとウェブからも修正されるので、
>設定に依存してインデックスパーミッションを変更しなければなりません:
>使用するコマンドラインユーザーとウェブサーバーのユーザーが
>インデックスディレクトリに書き込みできることをチェックします。

-

>**NOTE**
>PHPの`zip`エクステンションをコンパイルしなかった場合、
>`ZipArchive`クラスに関する警告が表示されることがあります。 
>これは`Zend_Loader`クラスの既知のバグです。

フロントエンドの検索機能の実装はたやすいものです。
最初に、ルートを作成します:

    [yml]
    job_search:
      url:   /search
      param: { module: job, action: search }

そして対応するアクションです:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    class jobActions extends sfActions
    {
      public function executeSearch(sfWebRequest $request)
      {
        if (!$query = $request->getParameter('query'))
        {
          return $this->forward('job', 'index');
        }

<propel>
        $this->jobs = JobeetJobPeer::getForLuceneQuery($query);
</propel>
<doctrine>
        $this->jobs = Doctrine::getTable('JobeetJob')
         ➥ ->getForLuceneQuery($query);
</doctrine>
      }

      // ...
    }

テンプレートも非常に単刀直入です:

    [php]
    // apps/frontend/modules/job/templates/searchSuccess.php
    <?php use_stylesheet('jobs.css') ?>

    <div id="jobs">
      <?php include_partial('job/list', array('jobs' => $jobs)) ?>
    </div>

検索自身は`getForLuceneQuery()`メソッドにデリゲートされます:

<propel>
    [php]
    // lib/model/JobeetJobPeer.php
    static public function getForLuceneQuery($query)
    {
      $hits = self::getLuceneIndex()->find($query);

      $pks = array();
      foreach ($hits as $hit)
      {
        $pks[] = $hit->pk;
      }

      $criteria = new Criteria();
      $criteria->add(self::ID, $pks, Criteria::IN);
      $criteria->setLimit(20);

      return self::doSelect(self::addActiveJobsCriteria($criteria));
    }
</propel>
<doctrine>
    [php]
    // lib/model/doctrine/JobeetJobTable.class.php
    public function getForLuceneQuery($query)
    {
      $hits = $this->getLuceneIndex()->find($query);

      $pks = array();
      foreach ($hits as $hit)
      {
        $pks[] = $hit->pk;
      }

      if (empty($pks))
      {
        return array();
      }

      $q = $this->createQuery('j')
        ->whereIn('j.id', $pks)
        ->limit(20);
      $q = $this->addActiveJobsQuery($q);

      return $q->execute();
    }
</doctrine>

Luceneインデックスからすべての結果を取得した後で、
アクティブでない求人を除外して、結果数を`20`に制限します。

動作させるために、レイアウトを更新します:

    [php]
    // apps/frontend/templates/layout.php
    <h2>Ask for a job</h2>
    <form action="<?php echo url_for('@job_search') ?>" method="get">
      <input type="text" name="query" value="<?php echo $sf_request->getParameter('query') ?>" id="search_keywords" />
      <input type="submit" value="search" />
      <div class="help">
        Enter some keywords (city, country, position, ...)
      </div>
    </form>

>**NOTE**
>Zend LuceneはBoolean、ワイルドーカード、曖昧検索などのオペレーションをサポートする
>リッチなクエリ言語を定義します。
>[Zend Luceneのマニュアル](http://framework.zend.com/manual/ja/zend.search.lucene.query-api.html)
>にすべての内容のドキュメントが作成されています。

単体テスト
----------

検索エンジンをテストするために作成する必要のある単体テストの種類は？
Zend Luceneライブラリ自身は明らかにテストしませんが、
`JobeetJob`クラスとの統合機能はテストします。

`JobeetJobTest.php`ファイルの最後に次のテストを追加し
ファイルの始めでテストの数を`7`にすることを忘れないで下さい:

    [php]
    // test/unit/model/JobeetJobTest.php
    $t->comment('->getForLuceneQuery()');
    $job = create_job(array('position' => 'foobar', 'is_activated' => false));
    $job->save();
<propel>
    $jobs = JobeetJobPeer::getForLuceneQuery('position:foobar');
</propel>
<doctrine>
    $jobs = Doctrine::getTable('JobeetJob')->getForLuceneQuery('position:foobar');
</doctrine>
    $t->is(count($jobs), 0, '::getForLuceneQuery() does not return non activated jobs');

    $job = create_job(array('position' => 'foobar', 'is_activated' => true));
    $job->save();
<propel>
    $jobs = JobeetJobPeer::getForLuceneQuery('position:foobar');
</propel>
<doctrine>
    $jobs = Doctrine::getTable('JobeetJob')->getForLuceneQuery('position:foobar');
</doctrine>
    $t->is(count($jobs), 1, '::getForLuceneQuery() returns jobs matching the criteria');
    $t->is($jobs[0]->getId(), $job->getId(), '::getForLuceneQuery() returns jobs matching the criteria');

    $job->delete();
<propel>
    $jobs = JobeetJobPeer::getForLuceneQuery('position:foobar');
</propel>
<doctrine>
    $jobs = Doctrine::getTable('JobeetJob')->getForLuceneQuery('position:foobar');
</doctrine>
    $t->is(count($jobs), 0, '::getForLuceneQuery() does not return deleted jobs');

アクティブではないもしくは削除された求人は検索結果に表示されないことをテストします; 
渡されたcriteriaにマッチする求人が結果に表示されることもチェックします。

タスク
------

最終的に、(例えば求人が期限切れするとき)古いエントリからインデックスをクリーンナップして
時々インデックスを最適化するタスクを作る必要があります。
クリーンナップタスクは既に作成したので、
これらの機能を追加するためにこのタスクを更新しましょう:

    [php]
    // lib/task/JobeetCleanupTask.class.php
    protected function execute($arguments = array(), $options = array())
    {
      $databaseManager = new sfDatabaseManager($this->configuration);

<propel>
      // cleanup Lucene index
      $index = JobeetJobPeer::getLuceneIndex();

      $criteria = new Criteria();
      $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::LESS_THAN);
      $jobs = JobeetJobPeer::doSelect($criteria);
</propel>
<doctrine>
      // cleanup Lucene index
      $index = Doctrine::getTable('JobeetJob')->getLuceneIndex();

      $q = Doctrine_Query::create()
        ->from('JobeetJob j')
        ->where('j.expires_at < ?', date('Y-m-d'));

      $jobs = $q->execute();
</doctrine>
      foreach ($jobs as $job)
      {
        if ($hit = $index->find('pk:'.$job->getId()))
        {
          $hit->delete();
        }
      }

      $index->optimize();

      $this->logSection('lucene', 'Cleaned up and optimized the job index');

      // Remove stale jobs
<propel>
      $nb = JobeetJobPeer::cleanup($options['days']);

      $this->logSection('propel', sprintf('Removed %d stale jobs', $nb));
</propel>
<doctrine>
      $nb = Doctrine::getTable('JobeetJob')->cleanup($options['days']);

      $this->logSection('doctrine', sprintf('Removed %d stale jobs', $nb));
</doctrine>
    }

タスクはインデックスからすべての期限切れの求人を削除し
Zend Lucene組み込みの`optimize()`メソッドのおかげでこれを最適化します。

また明日
--------

今日は、1時間以内に多く野機能を持つ検索エンジンを実装しました。
プロジェクトに新しい機能を追加したいと思うたびに、
他のどこかで未解決であることを確認します。
最初に、[symfonyフレームワーク](http://www.symfony-project.org/api/1_2/)で
ネイティブに実装されてないことをチェックし、
[symfonyプラグイン](http://www.symfony-project.org/plugins/)をチェックします。
A[Zend Frameworkライブラリ](http://framework.zend.com/manual/ja/)
と[ezComponent](http://ezcomponents.org/docs)をチェックするのはお忘れ無く。

明日は、ユーザーが検索ボックスで入力する際にリアルタイムで検索結果を更新することで
検索エンジンのレスポンスを強化するために慎ましくJavaScriptを使います。
もちろん、symfonyでAJAXを使う方法を語る機会があります。


__ORM__
