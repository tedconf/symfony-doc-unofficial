Giorno 16: Web Service
======================

*************************************
QUI VA LA PRIMA PARTE
*************************************

### L'azione

Tutti i formati condivideranno la stessa azione `list`:

    [php]
    // apps/frontend/modules/api/actions/actions.class.php
    public function executeList(sfWebRequest $request)
    {
      $this->jobs = array();
      foreach ($this->getRoute()->getObjects() as $job)
      {
        $this->jobs[$this->generateUrl('job_show_user', $job, true)] = $job->asArray($request->getHost());
      }
    }
Al posto di passare un array di oggetti di tipo `JobeetJon` ai template, passiamo
un array di stringhe. Dato che abbiamo tre diversi template per la stessa azione,
la logica di processare i valori è stata spostata fuori nel metodo `JobeetJob::asArray()`:

    [php]
<propel>
    // lib/model/JobeetJob.php
</propel>
<doctrine>
    // lib/model/doctrine/JobeetJob.class.php
</doctrine>
    class JobeetJob extends BaseJobeetJob
    {
      public function asArray($host)
      {
        return array(
          'category'     => $this->getJobeetCategory()->getName(),
          'type'         => $this->getType(),
          'company'      => $this->getCompany(),
          'logo'         => $this->getLogo() ? 'http://'.$host.'/uploads/jobs/'.$this->getLogo() : null,
          'url'          => $this->getUrl(),
          'position'     => $this->getPosition(),
          'location'     => $this->getLocation(),
          'description'  => $this->getDescription(),
          'how_to_apply' => $this->getHowToApply(),
<propel>
          'expires_at'   => $this->getCreatedAt('c'),
</propel>
<doctrine>
          'expires_at'   => $this->getCreatedAt(),
</doctrine>
        );
      }

### Il formato `xml`

Supportare il formato `xml` è semplice come creare un template:

    [php]
    <!-- apps/frontend/modules/api/templates/listSuccess.xml.php -->
    <?xml version="1.0" encoding="utf-8"?>
    <jobs>
    <?php foreach ($jobs as $url => $job): ?>
      <job url="<?php echo $url ?>">
    <?php foreach ($job as $key => $value): ?>
        <<?php echo $key ?>><?php echo $value ?></<?php echo $key ?>>
    <?php endforeach; ?>
      </job>
    <?php endforeach; ?>
    </jobs>

### Il formato `json`

Il supporto al [formato JSON](http://json.org) è simile:

    [php]
    <!-- apps/frontend/modules/api/templates/listSuccess.json.php -->
    [
    <?php $nb = count($jobs); $i = 0; foreach ($jobs as $url => $job): ++$i ?>
    {
      "url": "<?php echo $url ?>",
    <?php $nb1 = count($job); $j = 0; foreach ($job as $key => $value): ++$j ?>
      "<?php echo $key ?>": <?php echo json_encode($value).($nb1 == $j ? '' : ',') ?>

    <?php endforeach; ?>
    }<?php echo $nb == $i ? '' : ',' ?>

    <?php endforeach; ?>
    ]

### Il formato `yaml`

Per i formati built-in, symfony fornisce una configurazione nel background, come
cambiare il content type, o disabilitare il layout.

Dato che il formato YAML non è nella lista del formati built-in di richiesta, il
content type della risposta può venir cambiato ed il layout disabilitato nell'azione:

    [php]
    class apiActions extends sfActions
    {
      public function executeList(sfWebRequest $request)
      {
        $this->jobs = array();
        foreach ($this->getRoute()->getObjects() as $job)
        {
          $this->jobs[$this->generateUrl('job_show_user', $job, true)] = $job->asArray($request->getHost());
        }

        switch ($request->getRequestFormat())
        {
          case 'yaml':
            $this->setLayout(false);
            $this->getResponse()->setContentType('text/yaml');
            break;
        }
      }
    }

Nell'azione, il metodo `setLayout()` cambia il layout di default o lo disabilita
quando viene impostato a `false`.

Il template per YAML è il seguente:

    [php]
    <!-- apps/frontend/modules/api/templates/listSuccess.yaml.php -->
    <?php foreach ($jobs as $url => $job): ?>
    -
      url: <?php echo $url ?>

    <?php foreach ($job as $key => $value): ?>
      <?php echo $key ?>: <?php echo sfYaml::dump($value) ?>

    <?php endforeach; ?>
    <?php endforeach; ?>

Se cercate di chiamare il web service con un token non valido, riceverete una pagina
404 in XML per il formato XML, e una pagina 404 JSON per il formato JSON. Ma per
il formato YAML, symfony non sa cosa visualizzare.

Quando create un formato, una pagina d'errore personalizzata dev'essere creata.
Il template sarà usato per le pagine 404, e tutte le altre eccezioni.

Dato che le eccezioni dovrebbero essere differenti negli ambienti di produzione
e di sviluppo, due file sono necessari (`config/error/exception.yaml.php` per il
debug, e `config/error/error.yaml.php` per la produzione):

    [php]
    // config/error/exception.yaml.php
    <?php echo sfYaml::dump(array(
      'error'       => array(
        'code'      => $code,
        'message'   => $message,
        'debug'     => array(
          'name'    => $name,
          'message' => $message,
          'traces'  => $traces,
        ),
    )), 4) ?>

    // config/error/error.yaml.php
    <?php echo sfYaml::dump(array(
      'error'       => array(
        'code'      => $code,
        'message'   => $message,
    ))) ?>

Prima di provare, dovere creare un layout per il formato YAML:

    [php]
    // apps/frontend/templates/layout.yaml.php
    <?php echo $sf_content ?>

![404](http://www.symfony-project.org/images/jobeet/1_2/16/404.png)

>**TIP**
>Sovrascrivere i template dell'errore 404 e delle eccezioni è semplice come creare
>un file nella directory `config/error/`.

Test per i Web Service
-----------------

Per testare il web service, copiate le fixture degli affiliati da `data/fixtures/`
a `text/fixtures/`, e rimpiazzate il contenuto del file auto generata
`apiActionsTest.php` con il seguente:

    [php]
    // test/functional/frontend/apiActionsTest.php
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new JobeetTestFunctional(new sfBrowser());
    $browser->loadData();

    $browser->
      info('1 - Web service security')->

      info('  1.1 - A token is needed to access the service')->
      get('/api/foo/jobs.xml')->
      with('response')->isStatusCode(404)->

      info('  1.2 - An inactive account cannot access the web service')->
      get('/api/symfony/jobs.xml')->
      with('response')->isStatusCode(404)->

      info('2 - The jobs returned are limited to the categories configured for the affiliate')->
      get('/api/sensio_labs/jobs.xml')->
      with('request')->isFormat('xml')->
      with('response')->checkElement('job', 33)->

      info('3 - The web service supports the JSON format')->
      get('/api/sensio_labs/jobs.json')->
      with('request')->isFormat('json')->
      with('response')->contains('"category": "Programming"')->

      info('4 - The web service supports the YAML format')->
      get('/api/sensio_labs/jobs.yaml')->
      with('response')->begin()->
        isHeader('content-type', 'text/yaml; charset=utf-8')->
        contains('category: Programming')->
      end()
    ;

In questo test, noterete due nuovi metodi:

  * `isFormat()`: Testa il formato della richiesta
  * `contains()`: Per i formati non-HTML, controlla se la risposta contiene l'estratto dal testo aspettato

Il form di richiesta di affiliazione
------------------------------------

Ora che il web service è pronto da usare, creiamo il form per creare
gli account degli affiliati. Descriveremo ancora il classico
processo di aggiunta di una nuova feature all'applicazione.

### Rotte

Avete indovinato. La rotta è la prima cosa che creiamo:

    [yml]
    // apps/frontend/config/routing.yml
    affiliate:
      class:   sfPropelRouteCollection
      options:
        model: JobeetAffiliate
        actions: [new, create]
        object_actions: { wait: GET }

È un classico insiemre di rotte ##ORM## con una nuova opzione di
configurazione: `actions`. Poiché non abbiamo bisogno di tutte e
sette le azioni definite dalla rotta, l'opzione `actions` dice
alla rotta di far corrispondere solo le azioni `new` e `create`.
La rotta aggiuntiva `wait` sarà usata per dare al novello
affiliato un po' di feedback sul suo account.

### Inizio

Il classico secondo passo è generare un modulo:

    $ php symfony propel:generate-module frontend affiliate JobeetAffiliate --non-verbose-templates

### Template

Il task `propel:generate-module` genera le classiche sette azioni ed i loro
template corrispondenti. Nella cartella `templates/`, cancelliamo tutti i
file tranne `_form.php` e `newSuccess.php`. E per i file che manteniamo,
sostituiamo il contenuto con il seguente:

    [php]
    <!-- apps/frontend/modules/affiliate/templates/newSuccess.php -->
    <?php use_stylesheet('job.css') ?>

    <h1>Become an Affiliate</h1>

    <?php include_partial('form', array('form' => $form)) ?>

    <!-- apps/frontend/modules/affiliate/templates/_form.php -->
    <?php include_stylesheets_for_form($form) ?>
    <?php include_javascripts_for_form($form) ?>

    <?php echo form_tag_for($form, 'affiliate') ?>
      <table id="job_form">
        <tfoot>
          <tr>
            <td colspan="2">
              <input type="submit" value="Submit" />
            </td>
          </tr>
        </tfoot>
        <tbody>
          <?php echo $form ?>
        </tbody>
      </table>
    </form>

Creiamo il template `waitSuccess.php`:

    [php]
    <!-- apps/frontend/modules/affiliate/templates/waitSuccess.php -->
    <h1>Your affiliate account has been created</h1>

    <div style="padding: 20px">
      Thank you! 
      You will receive an email with your affiliate token
      as soon as your account will be activated.
    </div>

Infine, cambiamo il link nel footer per puntare al modulo `affiliate`:

    [php]
    // apps/frontend/templates/layout.php
    <li class="last"><a href="<?php echo url_for('@affiliate_new') ?>">Become an affiliate</a></li>

### Azioni

Di nuovo, siccome useremo solo il form di creazione, apriamo il file
`actions.class.php` e rimuoviamo tutti i metodi tranne `executeNew()`,
`executeCreate()`, e `processForm()`.

Per l'azione `processForm()`, cambiamo l'URL di redirezione all'aizone `wait`:

    [php]
    // apps/frontend/modules/affiliate/actions/actions.class.php
    $this->redirect($this->generateUrl('affiliate_wait', $jobeet_affiliate));

L'azione `wait` è semplice, perché non vogliamo passare nulla al template:

    [php]
    // apps/frontend/modules/affiliate/actions/actions.class.php
    public function executeWait()
    {
    }

L'affiliato non può scegliere il suo token, né può attivare il suo account.
Apriamo il file `JobeetAffiliateForm` per personalizzare il form:

    [php]
    // lib/form/JobeetAffiliateForm.class.php
    class JobeetAffiliateForm extends BaseJobeetAffiliateForm
    {
      public function configure()
      {
<propel>
        unset($this['is_active'], $this['token'], $this['created_at']);
        $this->widgetSchema['jobeet_category_affiliate_list']->setOption('expanded', true);
        $this->widgetSchema['jobeet_category_affiliate_list']->setLabel('Categories');

        $this->validatorSchema['jobeet_category_affiliate_list']->setOption('required', true);
</propel>
<doctrine>
        unset($this['is_active'], $this['token'], $this['created_at'], $this['updated_at']);

        $this->widgetSchema['jobeet_categories_list']->setOption('expanded', true);
        $this->widgetSchema['jobeet_categories_list']->setLabel('Categories');

        $this->validatorSchema['jobeet_categories_list']->setOption('required', true);
</doctrine>

        $this->widgetSchema['url']->setLabel('Your website URL');
        $this->widgetSchema['url']->setAttribute('size', 50);

        $this->widgetSchema['email']->setAttribute('size', 50);

        $this->validatorSchema['email'] = new sfValidatorEmail(array('required' => true));
      }
    }

Il framework dei form supporta le relazioni molti-a-molti, come ogni altra
colonna. Per default, una relazione del genere è visualizzata come un menù
a tendina, grazie al widget `sfWidgetFormChoice`. Come abbiamo visto nel giorno
10, abbiamo modificato la visualizzazione usando l'opzione `expanded`.
Le email e gli URL tendono ad essere un po' più lunghi della dimensione
predefinita di un tag input, ma gli attributi HTML possono essere impostati
usando il metodo `setAttribute()`.

![Form affiliati](http://www.symfony-project.org/images/jobeet/1_2/16/affiliate_form.png)

### Test

L'ultimo passo è scrivere alcuni test funzionali per la nuova feature:

    [php]
    // test/functional/frontend/affiliateActionsTest.php
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new JobeetTestFunctional(new sfBrowser());
    $browser->loadData();

    $browser->
      info('1 - An affiliate can create an account')->

      get('/affiliate/new')->
      click('Submit', array('jobeet_affiliate' => array(
        'url'                            => 'http://www.example.com/',
        'email'                          => 'foo@example.com',
<propel>
        'jobeet_category_affiliate_list' => array($browser->getProgrammingCategory()->getId()),
</propel>
<doctrine>
        'jobeet_categories_list'         => array(Doctrine::getTable('JobeetCategory')->findOneBySlug('programming')->getId()),
</doctrine>
      )))->
      isRedirected()->
      followRedirect()->
      with('response')->checkElement('#content h1', 'Your affiliate account has been created')->

      info('2 - An affiliate must at leat select one category')->

      get('/affiliate/new')->
      click('Submit', array('jobeet_affiliate' => array(
        'url'   => 'http://www.example.com/',
        'email' => 'foo@example.com',
      )))->
<propel>
      with('form')->isError('jobeet_category_affiliate_list')
</propel>
<doctrine>
      with('form')->isError('jobeet_categories_list')
</doctrine>
    ;

<propel>
Per simulare la selezione dei checkbox, passiamo un array di identificatori
da spuntare. Per semplificare il compito, un nuovo metodo
`getProgrammingCategory()` è stato creato nella classe
`JobeetTestFunctional`:

    [php]
    // lib/model/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function getProgrammingCategory()
      {
        $criteria = new Criteria();
        $criteria->add(JobeetCategoryPeer::SLUG, 'programming');

        return JobeetCategoryPeer::doSelectOne($criteria);
      }

      // ...
    }

Ma siccome abbiamo già questo codice nel metodo `getMostRecentProgrammingJob()`,
è ora di rifattorizzare il codice e creare un metodo `getForSlug()` in
`JobeetCategoryPeer`:

    [php]
    // lib/model/JobeetCategoryPeer.php
    static public function getForSlug($slug)
    {
      $criteria = new Criteria();
      $criteria->add(self::SLUG, $slug);

      return self::doSelectOne($criteria);
    }

Quindi, sostituiamo le due occorrenze di questo codice in `JobeetTestFunctional`.
</propel>


*******************************
QUI VA LA QUARTA E ULTIMA PARTE
*******************************


__ORM__
