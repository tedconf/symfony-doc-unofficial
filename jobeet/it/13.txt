Giorno 13: L'utente
===================

Precedentemente su Jobeet
-------------------------

La giornata di ieri è stata archiviata con un sacco di informazioni. Con
pochissime linee di codice PHP l'admin generator di symfony permette allo
sviluppatore di creare interfacce di backend in pochi minuti.

Oggi scopriremo come symfony gestisce i dati persistenti tra le richieste
HTTP. Come dovreste sapere il protocollo HTTP è di tipo stateless, questo significa
che ogni richiesta è indipendente da quelle che la precedono o la seguono.
I siti web moderni hanno bisogno di mantenere i dati persistenti tra le varie 
richieste per migliorare la user experience dell'utente.

Una sessione utente può essere identificata usando un cookie. In symfony 
lo sviluppatore non ha bisogno di manipolare la sessione in modo diretto,
piuttosto utilizza l'oggetto `sfUser` che rappresenta l'utente finale
dell'applicazione.

Flash utente
------------

Abbiamo già visto l'oggetto utente in azione con i flash. Un flash è un 
messaggio salvato nella sessione dell'utente che viene cancellato automaticamente
dopo la prima richiesta successiva. È molto comodo quando avete bisogno
di mostrare un messaggio all'utente dopo un redirect. L'admin generator
fa un largo uso di messaggi flash per dare feedback all'utente ogni
qual volta un'offerta di lavoro viene salvata, cancellata o rinnovata.

![Flash](http://www.symfony-project.org/images/jobeet/1_2/13/flashes.png)

Un flash è impostato usando il metodo `setFlash()` di `sfUser`:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    public function executeExtend(sfWebRequest $request)
    {
      $request->checkCSRFProtection();

      $job = $this->getRoute()->getObject();
      $this->forward404Unless($job->extend());

<propel>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extend until %s.', $job->getExpiresAt('m/d/Y')));
</propel>
<doctrine>
      $this->getUser()->setFlash('notice', sprintf('Your job validity has been extend until %s.', date('m/d/Y', strtotime($job->getExpiresAt()))));
</doctrine>

      $this->redirect($this->generateUrl('job_show_user', $job));
    }

Il primo argomento è l'identificatore del flash mentre il secondo è il
messaggio da mostrare. Potete definire tutti i flash che volete ma `notice`
e `error` sono due dei più comuni (sono usati dall'admin generator).

È lasciato allo sviluppatore includere i messaggi flash nei template. Per
Jobeet vengono visualizzati dal `layout.php`:

    [php]
    // apps/frontend/templates/layout.php
    <?php if ($sf_user->hasFlash('notice')): ?>
      <div class="flash_notice"><?php echo $sf_user->getFlash('notice') ?></div>
    <?php endif; ?>

    <?php if ($sf_user->hasFlash('error')): ?>
      <div class="flash_error"><?php echo $sf_user->getFlash('error') ?></div>
    <?php endif; ?>

Nei template la sessione utente è accessibile dalla variabile speciale `sf_user`.

>**NOTE**
>Alcuni oggetti di symfony sono sempre accessibili nei template senza il 
>bisogno passarli dall'action: `sf_request`, `sf_user` e `sf_response`.

Attributi utente
----------------

Sfortunatamente le user story di Jobeet non richiedono che qualcosa possa
essere incluso nella sessione utente. Quindi aggiungiamo un nuovo requisito:
per rendere più semplice la navigazione le ultime tre offerte visualizzate
dall'utente dovranno essere mostrate nel menù con i link per tornare 
alla pagina dell'offerta.

Quando un utente accede alla pagina di un'offerta di lavoro l'oggetto stesso
dell'offerta visualizzata deve essere aggiunto nella history dell'utente e 
salvato nella sessione:

    [php]
    // apps/frontend/modules/job/actions/actions.class.php
    class jobActions extends sfActions
    {
      public function executeShow(sfWebRequest $request)
      {
        $this->job = $this->getRoute()->getObject();

        // fetch jobs already stored in the job history
        $jobs = $this->getUser()->getAttribute('job_history', array());

        // add the current job at the beginning of the array
        array_unshift($jobs, $job->getId());

        // store the new job history back into the session
        $this->getUser()->setAttribute('job_history', $jobs);
      }

      // ...
    }

>**NOTE**
>Avremmo potuto salvare gli oggetti `JobeetJob` direttamente nella sessione.
>Vi scoraggiamo fortemente di agire in questo modo perché le variabili di sessione
>vengono serializzate tra le richieste. Quando la sessione viene caricata
>gli oggetti `JobeetJob` vengono de-serializzati e possono presentare dati 
>incoerenti se nel frattempo sono stati modificati o cancellati.

### `getAttribute()`, `setAttribute()`

Dato un identificatore il metodo `sfUser::getAttribute()`prende i valori 
dalla sessione utente. Al contrario il metodo `setAttribute()` salva 
qualsiasi variabile PHP nella sessione con l'identificatore passato.

Il metodo `getAttribute()` prende un valore opzionale per segnalare se 
l'identificatore passato non è ancora stato definito.

>**NOTE**
>Il valore di default preso dal metodo `getAttribute()` è una scorciatoia per:
>
>     [php]
>     if (!$value = $this->getAttribute('job_history'))
>     {
>       $value = array();
>     }


***********************
QUI VA LA SECONDA PARTE
***********************


Sicurezza dell'applicazione
---------------------------

### Autenticazione

Come molte altre feature di symfony, la sicurezza è gestita da un file YAML,
`security.yml`. Ad esempio, si può trovare la configurazione di default per
l'applicazione di backend nella cartella `config/`:

    [yml]
    // apps/backend/config/security.yml
    default:
      is_secure: off

Se si cambia la voce `is_secure` a `on`, l'intera applicazione di backend
richiederà l'autenticazione dell'utente.

![Login](http://www.symfony-project.org/images/jobeet/1_2/13/login.png)

>**TIP**
>In un file YAML, un booleano può essere espresso con la stringa  `true` e
>`false`, oppure con `on` e `off`.

Se si dà un'occhiata ai log nella web debug toolbar, si noterà che il metodo
`executeLogin()` della classe `defaultActions` è richiamato ad ogni pagina
in cui si tenta di accedere.

![Web debug](http://www.symfony-project.org/images/jobeet/1_2/13/web_debug.png)

Quando un utente non autenticato prova ad accedere ad una azione messa in
sicurezza, symfony rimanda la richiesta all'azione `login` configurata in
`settings.yml`:

    [yml]
    all:
      .actions:
        login_module: default
        login_action: login

>**NOTE**
>Non è possibile mettere in sicurezza l'azione di login. Questo per evitare
>una ricorsione.

>**TIP**
>Come abbiamo visto durante il giorno 5, lo stesso file di configurazione può
>essere definito in diversi posti. Questo è anche il caso di `security.yml`.
>Per mettere in sicurezza (o togliere) una singola azione o un intero modulo,
>basta creare un file `security.yml` nella cartella `config/` del modulo:
>
>     [yml]
>     index:
>       is_secure: off
>     all:
>       is_secure: on

Di default, la classe `myUser` estende
[`sfBasicSecurityUser`](http://www.symfony-project.org/api/1_2/sfBasicSecurityUser),
e non `sfUser`. `sfBasicSecurityUser` fornisce metodi addizionali per gestire
l'autenticazione e l'autorizzazione degli utenti.

Per gestire l'autenticazione degli utenti, usare i metodi `isAuthenticated()` e
`setAuthenticated()`:

    [php]
    if (!$this->getUser()->isAuthenticated())
    {
      $this->getUser()->setAuthenticated(true);
    }

### Autorizzatione

Quando un utente è autenticato, l'accesso ad alcune azioni può essere
ulteriormente ristretto definendo delle **credenziali**. Un utente deve
avere le credenziali richieste per accedere alla pagina:

    [yml]
    default:
      is_secure:   off
      credentials: admin

Il sistema di credenziali di symfony è molto semplice e potente. Una credenziale
può rappresentare qualsiasi cosa si abbia bisogno di descrivere nel modello
di sicurezza dell'applicazione (come  gruppi o permessi).

>**SIDEBAR**
>Credenziali complesse
>
>La voce `credentials` di `security.yml` supporta operazioni booleane per
>descrivere requisiti di credenziali complesse.
>
>Se un utente deve avere le credenziali A **e** B, includi le credenziali tra
>parentesi quadre:
>
>     [yml]
>     index:
>       credentials: [A, B]
>
>Se un utente deve avere le credenziali A **o** B, includi le credenziali tra
>doppie parentesi quadre:
>
>     [yml]
>     index:
>       credentials: [[A, B]]
>
>Si possono anche mescolare le parentesi quadre per descrivere ogni tipo
>di espressione booleana con qualsiasi numero di credenziali.

Per gestire le credenziali degli utenti, `sfBasicSecurityUser` fornisce diversi
metodi:

    [php]
    // Aggiunge una o più credenziali
    $user->addCredential('foo');
    $user->addCredentials('foo', 'bar');

    // Verifica se l'utente ha una credenziale
    echo $user->hasCredential('foo');                      =>   true

    // CVerifica se l'utente ha entrambe le credenziali
    echo $user->hasCredential(array('foo', 'bar'));        =>   true

    // Verifica se l'utente ha una delle credenziali
    echo $user->hasCredential(array('foo', 'bar'), false); =>   true

    // Rimuove una credenziale
    $user->removeCredential('foo');
    echo $user->hasCredential('foo');                      =>   false

    // Rimuove tutte le credenziali (utile per il logout)
    $user->clearCredentials();
    echo $user->hasCredential('bar');                      =>   false

Per il backend di Jobeet, non ci servono credenziali, perché abbiamo un solo
profilo: l'amministratore,

Plugin
------

Siccome non ci piace reinventare la ruota, non vogliamo sviluppare un'azione
di login da zero. Invece, installeremo un **plugin di symfony**.

Una delle grandi forze del framework symfony è l'
[ecostistema di plugin](http://www.symfony-project.org/plugins/). Come vedremo
nei prossimi giorni, è molto semplice creare un plugin. È anche molto potente,
perché un plugin può contenere ogni cosa, dalla configurazioni ai moduli, agli
asset.

<propel>
Oggi installeremo
[`sfGuardPlugin`](http://www.symfony-project.org/plugins/sfGuardPlugin) per
rendere sicura l'applicazione di backend:

    $ php symfony plugin:install sfGuardPlugin
</propel>
<doctrine>
Oggi installeremo
[`sfDoctrineGuardPlugin`](http://www.symfony-project.org/plugins/sfDoctrineGuardPlugin)
per rendere sicura l'applicazione di backend:

    $ php symfony plugin:install sfDoctrineGuardPlugin
</doctrine>

Il task `plugin:install` installa un plugin in base al nome. Tutti i plugin sono
memorizzati sotto la cartella `plugins/` ed ognuno ha la sua cartella, che prende
il nome dal plugin stesso.

>**NOTE**
>Per poter usare il task `plugin:install` occorre avere PEAR installato.

Quando si installa un plugin con il task `plugin:install`, symfony installa
l'ultima versione stabile. Per installare una versione specifica di un plugin,
usare l'opzione `--release`.

<propel>
La 
[pagina dei plugin](http://www.symfony-project.org/plugins/sfGuardPlugin?tab=plugin_all_releases)
elenca tutte le versioni disponibili, raggruppate per versione di symfony.

Essendo un plugin contenuto in una cartella, si può anche
[scaricare il pacchetto](http://www.symfony-project.org/plugins/sfGuardPlugin?tab=plugin_installation)
dal sito di symfony ed estrarlo, oppure creare un collegamento `svn:externals` al
suo [repository di Subversion](http://svn.symfony-project.com/plugins/sfGuardPlugin).
</propel>
<doctrine>
La 
[pagina dei plugin](http://www.symfony-project.org/plugins/sfDoctrineGuardPlugin?tab=plugin_all_releases)
elenca tutte le versioni disponibili, raggruppate per versione di symfony.

Essendo un plugin contenuto in una cartella, si può anche
[scaricare il pacchetto](http://www.symfony-project.org/plugins/sfDoctrineGuardPlugin?tab=plugin_installation)
dal sito di symfony ed estrarlo, oppure creare un collegamento `svn:externals` al
suo [repository di Subversion](http://svn.symfony-project.com/plugins/sfDoctrineGuardPlugin).
</doctrine>




*******************************
QUI VA LA QUARTA E ULTIMA PARTE
*******************************



__ORM__
