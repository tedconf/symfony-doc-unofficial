Giorno 24: Un altro sguardo a symfony
=====================================

Oggi è l'ultima fermata del nostro viaggio nel meraviglioso mondo di symfony.
Durante questi ventitré giorni, avete imparato ad usare symfony per esempi:
dai design pattern usati dal framework, alle potenti feature incluse. Non
siete ancora degli esperti di symfony, ma avete tutta la conoscenza
necessaria per costruire la vostra applicazione symfony con fiducia.

In chiusura del tutorial, diamo un altro sguardo al framework.
Dimentichiamo Jobeet per un'ora, e ricordiamo tutte le feature imparate
durante le ultime tre settimane.

Cos'è symfony?
--------------

Il framework symfony è un insieme di
[sotto-framework coesi ma disaccoppiati](#day_11_sidebar_using_the_form_framework_without_symfony),
che formano un completo [framework MVC](#day_04_l_architettura_mvc)
(Modello, Vista, Controllore).

Prima di pensare al codice, prendetevi un po' di tempo per leggere
la [storia e la filosofia di symfony](#day_01_introduzione).
Quindi, verificate i [prerequisiti](#day_01_prerequisiti) del framework.
ed usate lo [script `check_configuration.php`](#day_01_installazione_di_symfony)
per validare la vostra configurazione.

Infine, [installate symfony](#day_01_installazione_di_symfony). Dopo un po'
di tempo forse vorrete anche [aggiornare](#day_23_sub_aggiornare_symfony)
all'ultima versione del framework.

Il framework fornisce anche degli strumenti per facilitare il [deployment](#day_23_deploying).

Il Modello
----------

La parte di symfony del Modello può essere fatta con l'aiuto di
<propel>
[Propel](http://propel.phpdb.org/). Basato sulla
</propel>
<doctrine>
[Doctrine](http://www.doctrine-project.org/). Basato sulla
</doctrine>
[descrizione del database](#day_03_lo_schema), genera delle classi per
[oggetti](#day_03_l_orm), [form](#day_10_form_##ORM_LOWER##), e
[filtri](#day_12_configurazione_dei_filtri). ##ORM## inoltre genera le
istruzioni [SQL](#day_03_l_orm) usati per creare le tabelle del database.

la configurazione del database può essere fatta con un [task](#day_03_il_database)
o modificando un [file di configurazione](#day_03_il_database). Oltre
alla configurazione, è possibile inserire dei dati iniziali, grazie ai
[file fixture](#day_03_i_dati_iniziali). Si possono anche rendere tali file
[dinamici](#day_06_fixture_dinamiche).

<propel>
Gli oggetti Propel possono anche essere facilmente
[internazionalizzati](#day_19_sub_oggetti_propel).
</propel>
<doctrine>
Gli oggetti Doctrine possono anche essere facilmente
[internazionalizzati](#day_19_sub_oggetti_doctrine).
</doctrine>

La Vista
--------

Di default, il livello della Vista dell'architettura MVC usa semplici file
PHP come template.

I template possono usare degli [helper](#day_04_i_fogli_di_stile_le_immagini_e_i_javascript)
per compiti ricorrenti, come la creazione di [URL](#day_05_il_routing_nelle_azioni_e_nei_template)
o di [link](#day_05_il_routing_nelle_azioni_e_nei_template).

Un template può essere decorato da un [layout](#day_04_il_layout) per astrarre
header e footer delle pagine. Per rendere le viste ancora più riusabili,
si possono definire [slot](#day_04_slot), [partial](#day_07_partial), e
[component](#day_19_cambio_di_lingua).

Per accelerare le cose, si può usare il
[sotto-framework della cache](#day_22_configurazione_della_cache) per mettere
in cache una [pagina intera](#day_22_cache_della_pagina), solo
[l'azione](#day_22_cache_dell_azione), o anche solo
[partial o component](#day_22_cache_di_partial_e_component).
Si può anche [pulire la cache](#day_22_rimuovere_la_cache) a mano.

Il Controllore
--------------

La parte del Controllore è gestita dai [front controller](#day_01_gli_ambienti)
e dalle [azioni](#day_03_vediamolo_in_azione_nel_browser).

I task possono essere usati per creare [semplici moduli](#day_07_creazione_del_modulo_delle_categorie),
[moduli CRUD](#day_03_vediamolo_in_azione_nel_browser), o anche per generare
[moduli di amministrazione](#day_12_moduli_di_backend) pienamente funzionanti
per le classi del modello.

I moduli di amministrazione consentono di costruire un'applicazione pienamente
funzionante senza scrivere codice.

Per astrarre l'implementazione tecnica di un sito, symfony usa un
sotto-framework per il [routing](#day_05_configurazione_del_routing) 
che genera [URL carini](#day_05_url). Per rendere ancora più facile
l'implementazione dei web service, symfony supporta i
[formati](#day_15_formati) in modo nativo. Si possono anche creare
i propri [formati](#day_16_sub_il_formato_code_yaml_code_).

Un'azione può essere [rimandata](#day_04_sidebar_la_famiglia_dei_metodi_forward)
ad un'altra, oppure [redirezionata](#day_05_sidebar_la_famiglia_dei_metodi_redirect).

Configurazione
--------------

Il framework symfony rende facile avere diverse impostazioni di configurazione
per diversi ambienti. Un [ambiente](#day_01_gli_ambienti) è un insieme di
impostazioni che consentono comportamenti diversi sui server di sviluppo
o di produzione. Si possono anche creare nuovi
[ambienti](#day_22_creare_un_nuovo_ambiente).

I file di configurazione di symfony possono essere definiti a
[diversi livelli](#day_04_sidebar_principi_di_configurazione_in_symfony) e
la maggior parte di essi sono
[sensibili all'ambiente](#day_08_sidebar_principi_di_configurazione_in_symfony):

 * [`app.yml`](#day_06_configurazione_personalizzata)
 * [`cache.yml`](#day_22_configurazione_della_cache)
 * [`databases.yml`](#day_03_il_database)
 * [`factories.yml`](#day_23_i_factory)
 * [`generator.yml`](#day_12_la_cache_di_symfony)
 * [`routing.yml`](#day_05_configurazione_del_routing)
 * [`schema.yml`](#day_03_lo_schema)
 * [`security.yml`](#day_13_sub_autenticazione)
 * [`settings.yml`](#day_11_sub_feature_di_sicurezza_incluse)
 * [`view.yml`](#day_04_i_fogli_di_stile_le_immagini_e_i_javascript)

I file di configurazione usano per lo più il
[formato YAML](#day_03_sidebar_il_formato_yaml).

Invece di usare la struttura predefinita di cartelle ed organizzare i file
della propria applicazione per livelli, si può anche organizzarli per feature,
e distribuirli in un [plugin](#day_20_sub_un_modo_diverso_di_organizzare_il_codice).
Parlando di struttura predefinita delle cartelle, si può anche
[personalizzarla](#day_23_personalizzare_la_struttura_delle_cartelle) a
seconda delle proprie esigenze.

Debug
-----

<propel>
Dai [log](#day_06_debug_dell_sql_generato_da_propel) alla
[web debug toolbar](#day_06_debug_dell_sql_generato_da_propel), alle
</propel>
<doctrine>
Dai [log](#day_06_debug_dell_sql_generato_da_doctrine) to the
[web debug toolbar](#day_06_debug_dell_sql_generato_da_doctrine), alle
</doctrine>
[eccezioni](#day_01_gli_ambienti), symfony fornisce molti strumenti
utili per aiutare lo sviluppatore a risolvere velocemente i problemi.

Oggetti principali di symfony
-----------------------------

Il framework symfony fornisce pochi oggetti che astraggono le
esigenze frequenti nei progetti web: la [richiesta](#day_04_sub_la_richiesta),
la [risposta](#day_04_sub_la_risposta), l'[utente](#day_13_sub_la_classe_code_myuser_code_),
i [log](#day_23_sub_log), il [routing](#day_05_configurazione_del_routing), ed il
[gestore della cache della vista](#day_22_rimuovere_la_cache).

Questi oggetti principali sono gestiti dall'oggetto
[`sfContext`](#day_22_sidebar_la_classe_code_sfcontext_code_), e sono
cunfigurati tramite i [factory](#day_23_i_factory).

La classe `user` gestisce l'[autenticazione](#day_13_sub_autenticazione) degli
utenti, l'[autorizzazione](#day_13_sub_autorizzazione), i [flash](#day_13_flash_utente),
e gli [attributi](#day_13_attributi_utente) da serializzare nella sessione.

Sicurezza
---------

Il framework symfony ha delle protezioni incluse contro gli attacchi
[XSS](#day_01_sub_creazione_dell_applicazione) e
[CSRF](#day_01_sub_creazione_dell_applicazione). Queste impostazioni
possono essere configurate dalla
[linea di comando](#day_01_sub_creazione_dell_applicazione),
oppure modificando un [file di configurazione](#day_11_sub_protezione_da_xss_e_da_csrf).

Il framework dei form fornisce anche delle
[feature di sicurezza incluse](#day_11_sub_feature_di_sicurezza_incluse).

Form
----

Siccome la gestione dei form è uno dei compiti più noiosi per uno
sviluppatore web, symfony fornisce un [sotto-framework](#day_10_il_framework_dei_form).
Il framework dei form è distribuito con molti [widget](http://www.symfony-project.org/api/1_2/widget)
e [validatori](http://www.symfony-project.org/api/1_2/validator). Uno dei
punti di forza del sotto-framework dei form è la grande facilità di
[personalizzazione](#day_10_sidebar_personalizzare_l_aspetto_di_un_form)
dei template.

Se si usa ##ORM##, il framework dei form rende anche facile
<propel>
[generare form e filtri](#day_10_form_propel) basati sui modelli.
</propel>
<doctrine>
[generare form e filtri](#day_10_form_doctrine) basati sui modelli.
</doctrine>

Internazionalizzazione e localizzazione
---------------------------------------

[Internazionalizzazione](#day_19_internazionalizzazione) e
[localizzaeione](#day_19_localizzazione) sono supportate da symfony,
grazie allo standard ICU. La [cultura dell'utente](#day_19_sub_la_cultura_dell_utente)
determina la lingua ed il paese dell'utente. Può essere definita dall'utente
stesso, oppure inclusa nell'[URL](#day_19_cultura_nell_url).

Test
----

La libreria lime, usata per i **test unitari**, fornisce molti
[metodi di test](#day_08_il_framework_di_test_code_lime_code_). Anche gli
<propel>
[oggetti Propel possono essere testati](#day_08_test_unitari_con_propel) da
</propel>
<doctrine>
[oggetti Doctrine possono essere testati](#day_08_test_unitari_con_doctrine) da
</doctrine>
un [database dedicato](#day_08_sub_configurazione_del_database) e
con [fixture](#day_08_sub_dati_dei_test) dedicate.

I test unitari possono essere eseguiti
[uno alla volta](#day_08_eseguire_i_test_unitari) o
[tutti insieme](#day_08_imbrigliare_i_test_unitari).

**I test funzionali** sono scritti con la classe 
[`sfFunctionalTest`](#day_09_la_classe_code_sftestfunctional_code_), che
usa un [simulatore di browser](#day_09_la_classe_code_sfbrowser_code_) e
consente agli oggetti principali di symfony l'introspezione tramite i
[Tester](#day_09_la_classe_code_sftestfunctional_code_). I Tester esistono
per l'[oggetto richiesta](#day_09_sub_il_tester_della_richiesta), per
l'[oggetto risposta](#day_09_sub_il_tester_della_risposta), per
l'[oggetto utente](#day_13_test_degli_utentig), per
l'[oggetto form attuale](#day_11_il_form_tester), per
il [livello della cache](#day_22_test_della_cache) e per
<propel>
[gli oggetti Propel](#day_11_il_tester_propel).
</propel>
<doctrine>
[gli oggetti Doctrine](#day_11_il_tester_doctrine).
</doctrine>

Si possono anche usare strumenti di debug per la
[risposta](#day_09_debug_dei_test_funzionali)
e per i [form](#day_11_il_form_tester).

Come per i test unitari, i test funzionali possono essere eseguiti
[uno alla volta](#day_09_eseguire_test_funzionali) o
[tutti insieme](#day_09_imbrigliare_i_test_funzionali).

Si possono anche eseguire [tutti i test insieme](#day_09_imbrigliare_i_test).

Plugin
------

Il framework symfony fornisce solo i fondamenti per le applicazioni web e
si appoggia a dei [plugin](#day_20_uso_dei_plugin) per aggiungere
altre funzionalità. In questo tutorial, abbiamo parlato di [`sfGuardPlugin`](#day_13_plugin),
[`sfFormExtraPlugin`](#day_19_cambio_di_lingua), e
[`sfTaskExtraPlugin`](#day_20_contribuire_con_un_plugin).

Un plugin deve essere [attivato](#day_20_sidebar_attivazione_plugin) dopo
l'installazione.

I plugin sono il modo migliore per [contribuire](#day_20_contribuire_con_un_plugin)
al progetto symfony.

Task
----

La CLI di symfony fornisce molti task, ed i più utili sono stati discussi
in questo tutorial:

 * [`app:routes`](#day_05_debug_delle_rotte)
 * [`cache:clear`](#day_22_pulire_la_cache)
 * [`configure:database`](#day_03_il_database)
 * [`generate:project`](#day_01_sub_creazione_del_progetto)
 * [`generate:app`](#day_01_sub_creazione_dell_applicazione)
 * [`generate:module`](#day_07_job_creazione_del_modulo_delle_categorie)
 * [`help`](#day_03_l_orm)
 * [`i18n:extract`](#day_19_sub__code_i18n_extract_code_)
 * [`list`](#day_13_sicurezza_nel_backend)
 * [`plugin:install`](#day_13_plugin)
 * [`plugin:publish-assets`](#day_20_sub_le_risorse)
 * [`project:deploy`](#day_23_sub_strategie_di_deploy)
 * [`propel:build-all`](#day_03_l_orm)
 * [`propel:build-all-load`](#day_07_aggiornare_il_database)
<propel>
 * [`propel:build-forms`](#day_10_form_propel)
</propel>
<doctrine>
 * [`doctrine:build-forms`](#day_10_form_doctrine)
</doctrine>
 * [`propel:build-model`](#day_03_l_orm)
 * [`propel:build-sql`](#day_03_l_orm)
 * [`propel:data-load`](#day_03_i_dati_iniziali)
 * [`propel:generate-admin`](#day_12_moduli_di_backend)
 * [`propel:generate-module`](#day_03_vediamolo_in_azione_nel_browser)
 * [`propel:insert-sql`](#day_03_l_orm)
 * [`test:all`](#day_09_imbrigliare_i_test)
 * [`test:coverage`](#day_08_sidebar_copertura_del_codice)
 * [`test:functional`](#day_09_eseguire_test_funzionali)
 * [`test:unit`](#day_08_eseguire_i_test_unitari)

Si possono anche creare [i propri task](#day_11_task_di_manutenzione).

Riconoscimenti
--------------

Scrivere un tutorial come Jobeet è sia eccitante che sfibrante. Si spendono
ore ed ore a cercare di immaginare come veicolare il messaggio, come
spiegare i concetti, come fornire esempi semplici ma sensati e riusabili.

Scrivere un tutorial così grosso è semplicemente impossibile senza la gente
che ti supporta durante il processo. Per Jobeet, io (**Fabien Potencier**) 
ho avuto la fortuna di beneficiare di revisori di prima qualità. Essi sono
tutti parte dell'avventura di symfony e vorrei ringraziarli tutti per il
tempo che hanno dedicato al progetto Jobeet.

**Kris Wallsmith**, il nostro manager della community e release manager
dell'imminente symfony 1.3, ha preso il tempo di correggere il mio Inglese
poco perfetto. Siccome questo tutorial è stato pubblicato su base
giornaliera, e siccome io vivo in Francia e lui negli Stati Uniti, si
è alzato molto presto ogni mattina questo mese, inclusi i fine settimana,
per leggere e correggere ogni giorno.

**Stefan Koopmanschap**, uno dei più attivi promotori di symfony, ha assunto
la responsabilità di mantenere il repository Subversion. Grazie al suo
lavoro, si può vedere il codice ed iniziare a leggere il tutorial
perun qualsiasi giorno.

**Fabian Lange**, il release manager di symfony 1.2, nonché "ragazzo"
symfony, ha letto il libro con una prospettiva Windows ed ha cercato di
essere un lettore neofita. A margine, ha comprato da poco un Mac, quindi
avremo bisogno di qualcun altro che si prenda la responsabilità
del "ragazzo Windows".

**Jonathan Wage**, lo sviluppatore principale di Doctrine, ha speso del
tempo per creare un'edizione Doctrine del tutorial. Grazie ai suoi
grandi sforzi, si può scegliere tra Propel e Doctrine come ORM
principale per symfony, e godere ugualmente dello stesso tutorial.

**Pascal Borreli**, un frequentatore del canale IRC francese di symfony, ed
il membro più amichevole della community di symfony, ha letto il
tutorial capitolo dopo capitolo alla velocità della luce. Il suo
continuo supporto e le sue parole gentili mi hanno mantenuto nell'umore
giusto per scrivere questo tutorial dall'inizio alla fine.

A presto
--------

Prima di lasciarci, vorrei dire un'ultima cosa su symfony. Il framework ha
un sacco di grandi feature e molta documentazione libera. Ma una delle
più grandi risorse preziose che un progetto Open Source può avere è la
sua community. E symfony ha una delle più incredibili ed attive community
del mondo. Se iniziate ad usare symfony per i vostri progetti, considerate
di unirvi alla community di symfony:

  * Iscrivendovi alla [mailing list degli utnti](http://groups.google.com/group/symfony-users)
  * Iscrivendovi al [feed del blog ufficiale](http://feeds.feedburner.com/symfony/blog)
  * Iscrivendovi al [feed di symfony planet](http://feeds.feedburner.com/symfony/planet)
  * Chattando sul canale[IRC #symfony](irc://irc.freenode.net/symfony) su freenode

Joyeux Noël !

__ORM__
