Giorno 11: Testare i Form
=========================

Precedentemente su Jobeet
-------------------------

Ieri abbiamo creato il nostro primo form con symfony. Gli utenti possono ora 
inserire una nuova offerta di lavoro si Jobeet, però abbiamo finito il
tempo a disposizione prima che potessimo aggiungere alcuni test.

È quello che faremo oggi. Nel mentre impareremo ancora qualcosa sul form
framework.

>**SIDEBAR**
>Usare il Form Framewor senza symfony
>
>I componenti di symfony framework sono disaccoppiati. Questo significa che
>la maggior parte di essi può essere usata senza ricorrere all'intero framework
>MVC. Questo è il caso del form framework il quale non ha dipendenze da symfony.
>Potete usarlo in ogni applicazione PHP usando le directory `lib/form/`, `lib/widgets/`
>e `lib/validators/`.
>
>Un altro componente riutilizzabile è il routing framework. Copiate la directory
>`lib/routing/` nel vostro progetto non-symfony e sfruttatene i benefici per gli URL
>gratuitamente.
>
>Ecco i componenti che sono indipendenti da symfony dalla **symfony platform**:
>
>![The symfony plaform](http://www.symfony-project.org/images/jobeet/1_2/11/platform.png)

Inviare un Form
---------------

Aprite il file `jobActionsTest` per aggiungere i test per la creazione di 
un'offerta di lavoro e per il processo di validazione.

Alla fine del file aggiungete il seguente codice per avere la pagina di creazione
offerta:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()
    ;

Abbiamo già usato il metodo `click()` per simulare i click sui link. Lo stesso
metodo `click()` può essere usato per inviare un form. Per un form potete passare
i valori da inviare per ogni campo come secondo argomento di un metodo. Come 
un vero broswer l'oggetto browser si occuperà del merge dei valori di default
con i valori inviati dal form.

Ma per inviare i valori dei campi abbiamo bisogno di conoscere i loro nomi. Se
aprite il codice sorgente oppure utilizzare la Firefox Web Developer Toolbar con 
la funzione "Forms > Display Form Details" potrete vedere che il nome del campo
`company` è `jobeet_job[company]`.

>**NOTE**
>Quando PHP incontra un campo di input con un nome tipo `jobeet_job[company]`
>lo converte automaticamente in un array di nome `jobeet_job`.

Per far sembrare le cose un po' più semplici cambiamo il formato a `job[%s]`
aggiungendo il seguente codice alla fine del metodo `configure()` del `JobeetJobForm`:

    [php]
    // lib/form/JobeetJobForm.class.php
    $this->widgetSchema->setNameFormat('job[%s]');

Dopo questa modifica il nome del campo `company` dovrebbe essere `job[company]`.
È giunto quindi il momento di cliccare sul pulsante "Preview your job" passando
dati validi al form:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->info('3 - Post a Job page')->
      info('  3.1 - Submit a Job')->

      get('/job/new')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'new')->
      end()->

      click('Preview your job', array('job' => array(
        'company'      => 'Sensio Labs',
        'url'          => 'http://www.sensio.com/',
        'logo'         => sfConfig::get('sf_uploads_dir').'/jobs/sensio-labs.gif',
        'position'     => 'Developer',
        'location'     => 'Atlanta, USA',
        'description'  => 'You will work with symfony to develop websites for our customers.',
        'how_to_apply' => 'Send me an email',
        'email'        => 'for.a.job@example.com',
        'is_public'    => false,
      )))
    ;

Il form deve essere inviato all'action `create`:

    [php]
    with('request')->begin()->
      isParameter('module', 'job')->
      isParameter('action', 'create')->
    end()->

Il browser inoltre simula l'upload di file passando il path assoluto del file 
da caricare.

Il Form Tester
--------------

Il form che abbiamo inviato dovrebbe essere valido. Potete testarlo usando il
**form tester**:

    [php]
    with('form')->begin()->
      hasErrors(false)->
    end()->

Il form tester ha diversi metodi per testare lo stato corrente di un form, come
gli per gli errori.

Se fate un errore nel test, ed il test non passa, potete usare lo statement
`with('response')->debug()` visto durante il giorno 9. Ma dovrete scavare nell'HTML
generato per verificare i messaggi d'errore. Non è molto conveniente. Quindi il 
form tester mette a disposizione un metodo `debug()` che mostra lo stato del
form e tutti i messaggi d'errore associati:

    [php]
    with('form')->debug()

Redirection Test
----------------

Con un form valido l'offerta di lavoro dovrebbe venire creata e l'utente rediretto
alla pagina `show`:

    [php]
    isRedirected()->
    followRedirect()->

    with('request')->begin()->
      isParameter('module', 'job')->
      isParameter('action', 'show')->
    end()->

`isRedirected()` verifica se la pagina è stata redirezionata ed il metodo
`followRedirect()` segue il redirect.

Il Propel Tester
----------------

Alla fine vorremo verificare che l'offerta di lavoro sia stata creata sul database
e verificare che la colonna `is_activated` sia impostata sul valore `false`
visto che l'utente non l'ha ancora pubblicata.

Questo può essere fatto facilmente utilizzando un altro tester, il **Propel
tester**. Visto che il Propel tester non è inserito di default aggiungiamolo
ora:

    [php]
    $browser->setTester('propel', 'sfTesterPropel');

Il Propel tester offre il metodo `check()` per verificare che uno o più oggetti
nel database corrispondano al criterio passato come argomento.

    [php]
    with('propel')->begin()->
      check('JobeetJob', array(
        'location'     => 'Atlanta, USA',
        'is_activated' => false,
        'is_public'    => false,
      ))->
    end()

Il criterio può essere un array di valori come qui sopra o un'istanza di 
`Criteria` per query più complesse. Potete verificare l'esistenza di oggetti 
corrispondenti al criterio con un booleano come terzo argomento (il default è `true`)
o il numero di oggetti corrispondenti passando un intero.












Sicurezza nei form
------------------

### Magia nella serializzazione dei form!

I form propel sono molto facili da usare, perché automatizzano un sacco
di lavoro. Per esempio, serializzare un form nel database è facile
quanto richiamare `$form->save()`. Come funziona?

Di base, il metodo `save()` fa i seguenti passi:

 * Inizia una transazione (perché i form annidati di Propel sono tutti salvati
   in un colpo solo)
 * Processa i valori inviati (richiamando il metodo `updateCOLUMNColumn()`, se
   esiste)
 * Richiama il metodo `fromArray()` dell'oggetto Propel per aggiornare i valori
   delle colonne
 * Salva l'oggetto nel database
 * Esegue il commit della transazione

### Feature di sicurezza incluse

Il metodo `fromArray()` accetta un array di valori ed aggiorna i valori delle
colonne corrispondenti. Questo rappresenta un problema di sicurezza? Che succede
se qualcuno prova ad inviare un valore per una colonna per cui non ha
l'autorizzazione? Per esempio, si può forzare la colonna `token`?

Scriviamo un test per simulare l'inserimento di un lavoro con un campo `token`:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $browser->
      get('/job/new')->
      click('Preview your job', array('job' => array(
        'token' => 'fake_token',
      )))->

      with('form')->begin()->
        hasErrors(8)->
        hasGlobalError('extra_fields')->
      end()
    ;

Quando si invia il form, si deve ricevere un errore globale `extra_fields`.
Questo perché per default i form non consentono campi ulteriori tra i
valori inviati. Anche per questo tutti i campi del form devono avere
un validatore associato. 

>**TIP**
>Si possono inviare campi addizionali comodamente dal browser, usando
>strumenti come Web Developer Toolbar per Firefox.

Si può aggirare questa misura di sicurezza impostando l'opzione
`allow_extra_fields` a `true`:

    [php]
    class MyForm extends sfForm
    {
      public function configure()
      {
        // ...

        $this->validatorSchema->setOption('allow_extra_fields', true);
      }
    }

Il test ora deve passare, ma il valore `token` è stato filtrato ed
escluso dai valori. Quindi non si è ancora in grado di aggirare
la misura di sicurezza. Ma se si vuole veramente il valore, basta
impostare l'opzione `filter_extra_fields` a `false`:

    [php]
    $this->validatorSchema->setOption('filter_extra_fields', false);

>**NOTE**
>I test scritti in questa sezione hanno solo scopo dimostrativo. Possono essere
>rimossi dal progetto Jobeet, perché non servono a validare feature di
>symfony.

### Protezione da XSS e da CSRF

Durante il giorno 1, abbiamo creato l'applicazione `frontend` col seguente
comando:

    $ php symfony generate:app --escaping-strategy=on --csrf-secret=Unique$ecret frontend

L'opzione `--escaping-strategy` abilita la protezione da XSS. Vuol dire
che tutte le variabili usate nel template subiscono un escaping di
deafult. Se si prova ad inviare la descrizione di un lavoro con alcuni tag
HTML dentro, si noterà che quando symfony mostra la pagina del lavoro,
i tag HTML della descrizione non sono interpretati, ma mostrate come
testo semplice. 

L'opzione `--csrf-secret` abilita la protezione da CSRF. Quando si fornisce
questa opzionoe, tutti i form includono un campo nascosto `_csrf_token`.

>**TIP**
>La strategia di escaping ed il segreto CSRF possono essere cambiati in
>qualsiasi momento modificando il file di configurazione
>`apps/frontend/config/settings.yml`. Come per il file `databases.yml`,
>le impostazioni sono configurabili per ambiente:
>
>     [yml]
>     all:
>       .settings:
>         # Form security secret (CSRF protection)
>         csrf_secret: Unique$ecret
>
>         # Output escaping settings
>         escaping_strategy: on
>         escaping_method:   ESC_SPECIALCHARS

Task di manutenzione
--------------------

Anche se symfony è un framework per il web, possiede uno strumento
a linea di comando. L'abbiamo già usato per creare la struttura di
cartelle di default del progetto e dell'applicazione, ma anche per 
generare vari file del modello. Aggiungere un nuovo task è molto
semplice, perché gli strumenti usati da symfony sono
pacchettizzati in un framework.

Quando un utente crea un lavoro, deve attivarlo per metterlo online.
Ma se non lo fa, il database si riempirà di lavori inutili. Creiamo
un task che rimuove i lavori inutili. Questo task dovrà girare
regolarmente in un cron job.

    [php]
    // lib/task/JobeetCleanupTask.class.php
    class JobeetCleanupTask extends sfBaseTask
    {
      protected function configure()
      {
        $this->addOptions(array(
          new sfCommandOption('env', null, sfCommandOption::PARAMETER_REQUIRED, 'The environement', 'prod'),
          new sfCommandOption('days', null, sfCommandOption::PARAMETER_REQUIRED, '', 90),
        ));

        $this->namespace = 'jobeet';
        $this->name = 'cleanup';
        $this->briefDescription = 'Cleanup Jobeet database';

        $this->detailedDescription = <<<EOF
    The [jobeet:cleanup|INFO] task cleans up the Jobeet database:

      [./symfony jobeet:cleanup --env=prod --days=90|INFO]
    EOF;
      }

      protected function execute($arguments = array(), $options = array())
      {
        $databaseManager = new sfDatabaseManager($this->configuration);

        $nb = JobeetJobPeer::cleanup($options['days']);

        $this->logSection('propel', sprintf('Removed %d stale jobs', $nb));
      }
    }

La configurazione del task viene fatta nel metodo `configure()`. Ogni task
devono avere un nome univoco (`namespace`:`name`), e possono avere
parametri ed opzioni.

>**TIP**
>Consultate i task predefiniti di symfony (`lib/task/`) per ulteriori
>esempi di utilizzo.

Il task `jobeet:cleanup` definisce due opzioni: `--env` e `--days`, con
alcuni default sensibili.

Eseguire il task è simile ad eseguire ogni altro task predefinito di symfony:

    $ php symfony jobeet:cleanup --days=10 --env=dev

Come sempre, il codice pulito per il database è stato fattorizzato nella
classe `JobeetJobPeer`:

    [php]
    // lib/model/JobeetJobPeer.php
    static public function cleanup($days)
    {
      $criteria = new Criteria();
      $criteria->add(self::IS_ACTIVATED, false);
      $criteria->add(self::CREATED_AT, time() - 86400 * $days, Criteria::LESS_THAN);

      return self::doDelete($criteria);
    }

Il metodo `doDelete()` rimuove dal database le righe che corrispondono all'
oggetto `Criteria` dato. Può anche accettare un array di chiavi primarie.

>**NOTE**
>I task di symfony si comportano bene con i loro ambienti, perché restituiscono
>un valore in accordo al successo del task. Puoi forzare un valore di ritorno
>restituendo un intero esplicitamente alla fine del task.

A domani
--------

I test sono nel cuore della filosofia e degli strumenti di symfony. Oggi
abbiamo imparato ancora come padroneggiare gli strumenti di symfony per
rendere il processo di sviluppo più facile, più veloce, e soprattutto
più sicuro.

Il framework dei form di symfony fornisce molto più che semplici
widget e validatori: dà un modo semplice per testare i form ed
assicura che i form siano sicuri di default.

Il nostro tour delle grandi feature di symfony non finisce oggi. Domani
creeremo l'applicazione di backend per Jobeet. Creare un'interfaccia
di backend è un must per la maggior parte dei progetti web, e Jobeet
non fa differenza. Ma come potremo essere in grado di sviluppare
una simile interfaccia in solo un'ora? Semplice, useremo il
framework di generazione dell'amministrazione di symfony. Fino ad
allora, statemi bene.
