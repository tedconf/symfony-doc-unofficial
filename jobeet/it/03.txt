Giorno 3: Il Data Model
=======================

Precedentemente su Jobeet
-------------------------

Quelli di voi che non vedono l'ora di aprire l'editor di testo e scrivere
un po' di PHP saranno contenti di sapere che il tutorial di oggi darà la
possibilità di fare un po' di sviluppo. Definiremo il data model di Jobeet,
utilizzeremo un ORM per interagire con il database e creeremoil primo modulo 
della nostra applicazione. Siccome symfony fa il grosso del lavoro per noi
avremo un modulo completamente funzionante scrivendo solo poche righe di
codice PHP.

Il modello relazionale
----------------------

Le user stories che abbiamo scritto ieri descrivono le entità principali
del nostro progetto: annunci di lavoro, affiliati, categorie. Di seguito 
abbiamo il corrispondente diagramma entità-relazioni:

![Diagramma entità-relazioni](http://www.symfony-project.org/images/jobeet/1_2/03/diagram.png)

In aggiunta alle colonne descritte nelle user stories abbiamo aggiunto inoltre
il campo `created_at` ad alcune tabelle. Symfony riconosce questi campi e ne
imposta il valore all'attuale timestamp di sistema quando un record viene
creato. Vale lo stesso per il campi `updated_at`: il loro valore è impostato
all'attuale timestamp di sistema ogni volta che un record viene aggiornato.

Lo Schema
---------

Per memorizzare gli annunci di lavoro, gli affiliati e le categorie abbiamo ovviamente
bisogno di un database relazionale.

Dato che symfony è un framework Object-Oriented ci farebbe piacere manipolare
oggetti il più possibile. Per esempio invece che scrivere query SQL per ottenere
record dal database preferiamo utilizzare gli oggetti.

Le informazioni del database relazionale devono essere mappate da un modello ad
oggetti. Questo può essere fatto con un [ORM](http://en.wikipedia.org/wiki/Object-relational_mapping)
e fortunatamente symfony viene distribuito con due soluzioni di questo tipo:
[Propel](http://propel.phpdb.org/) e [Doctrine](http://www.doctrine-project.org/).
In questo tutorial useremo Propel.

L'ORM ha bisogno di della descrizione delle tabelle e delle loro relazioni
per creare le relative classi. Esistono due metodi per creare questo schema
descrittivo: analizzando un database esistente o creandone uno a mano.

>**Nota**
>Alcuni tool permettono di creare un database graficamente
>(per esempio [Fabforce's Dbdesigner](http://www.fabforce.net/dbdesigner4/))
>e di generare direttamente uno `schema.xml` (con [DB Designer 4 TO Propel Schema
>Converter](http://blog.tooleshed.com/docs/dbd2propel/transform.php)).

Siccome il database non esiste ancora e non vogliamo prendere decisioni su 
di esso (come realizzarlo), creeremo lo schema a mano editando un file vuoto
`config/schema.yml`:

    [yml]
    # config/schema.yml
    propel:
      jobeet_category:
        id:           ~
        name:         { type: varchar(255), required: true }

      jobeet_job:
        id:           ~
        category_id:  { type: integer, foreignTable: jobeet_category,
          ➥ foreignReference: id, required: true }
        type:         { type: varchar(255) }
        company:      { type: varchar(255), required: true }
        logo:         { type: varchar(255) }
        url:          { type: varchar(255) }
        position:     { type: varchar(255), required: true }
        location:     { type: varchar(255), required: true }
        description:  { type: longvarchar, required: true }
        how_to_apply: { type: longvarchar, required: true }
        token:        { type: varchar(255), required: true, index: unique }
        is_public:    { type: boolean, required: true, default: 1 }
        is_activated: { type: boolean, required: true, default: 0 }
        email:        { type: varchar(255), required: true }
        expires_at:   { type: timestamp, required: true }
        created_at:   ~
        updated_at:   ~

      jobeet_affiliate:
        id:           ~
        url:          { type: varchar(255), required: true }
        email:        { type: varchar(255), required: true, index: unique }
        token:        { type: varchar(255), required: true }
        is_active:    { type: boolean, required: true, default: 0 }
        created_at:   ~

      jobeet_category_affiliate:
        category_id:  { type: integer, foreignTable: jobeet_category,
          ➥ foreignReference: id, required: true, primaryKey: true,
          ➥ onDelete: cascade }
        affiliate_id: { type: integer, foreignTable: jobeet_affiliate,
          ➥ foreignReference: id, required: true, primaryKey: true,
          ➥ onDelete: cascade }

>**SUGGERIMENTO**
>Se avete deciso di creare le tabelle scrivendo il codice SQL sappiate che
>potete generare il corrispondente file di configurazione `schema.yml` 
>utilizzando il task `propel:build-schema`.

Lo schema è la traduzione diretta del diagramma entità-relazioni nel 
formato YAML.

>**SIDEBAR**
>Il formato YAML
>
>Secondo il sito ufficiale di [YAML](http://yaml.org/), YAML
>"è uno standard di serializzazione dei dati human friendly per tutti i 
>linguaggi di programmazione"
>
>Detto in altro modo, YAML è un semplice linguaggio per descrivere dati
>(stringhe, interi, date, array e hash).
>
>In YAML la struttura è mostrata basandosi sull'indentazione, entità conseguenti
>sono indicate con un trattino e le coppie chiave/valore sono separate dai duepunti.
>YAML ha anche una sintassi ridotta per descrivere la stessa struttura con meno
>linee dove gli array sono espressi con `[]` e gli hash con `{}`.
>
>Se non avete familiarità con YAML è il momento di iniziare ad usarlo visto
>che symfony framework lo utilizza ampiamente per i suoi file di configurazione.

Il file `schema.yml` contiene la descrizione di tutte le tabelle e delle loro
colonne. Ogni colonna è descritta con le seguenti informazioni:

  * `type`: Il tipo della colonna (`boolean`, `tinyint`, `smallint`, `integer`,
            `bigint`, `double`, `float`, `real`, `decimal`, `char`,
            `varchar(size)`, `longvarchar`, `date`, `time`, `timestamp`,
            `blob`, and `clob`)
  * `required`: Impostarlo a `true` se la colonna è obbligatoria (not null)
  * `index`: Impostarlo a `true` se volete creare un indice per quella colonna o
            a `unique` se volete un indice con vincolo di unicità per quella colonna.

Per le colonne impostate a `~` (`id`, `created_at`, e `updated_at`) symfony 
deciderà la migliore configurazione (chiave primaria per `id` e timestamp per
`created_at` e `updated_at`).

>**NOTA**
>L'attributo `onDelete` definisce il comportamento `ON DELETE` delle chiavi esterne,
>Propel supporta `CASCADE`, `SETNULL` e `RESTRICT`. Per esempio quando un 
>record `job` viene eliminato tutti i record `jobeet_category_affiliate`
>associati verranno automaticamente eliminati dal database o da Propel se 
>il sottostante engine non dovesse supportare tale funzionalità.

=================
QUI SECONDA PARTE
=================

    [yml]
    # data/fixtures/010_categories.yml
    JobeetCategory:
      design:        { name: Design }
      programming:   { name: Programming }
      manager:       { name: Manager }
      administrator: { name: Administrator }

    # data/fixtures/020_jobs.yml
    JobeetJob:
      job_sensio_labs:
        category_id:  programming
        type:         full-time
        company:      Sensio Labs
        logo:         /uploads/jobs/sensio_labs.png
        url:          http://www.sensiolabs.com/
        position:     Web Developer
        location:     Paris, France
        description:  |
          You've already developed websites with symfony and you want to work
          with Open-Source technologies. You have a minimum of 3 years
          experience in web development with PHP or Java and you wish to
          participate to development of Web 2.0 sites using the best
          frameworks available.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_sensio_labs
        email:        job@example.com
        expires_at:   2010-10-10

      job_extreme_sensio:
        category_id:  design
        type:         part-time
        company:      Extreme Sensio
        logo:         /uploads/jobs/extreme_sensio.png
        url:          http://www.extreme-sensio.com/
        position:     Web Designer
        location:     Paris, France
        description:  |
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
          enim ad minim veniam, quis nostrud exercitation ullamco laboris
          nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor
          in reprehenderit in.

          Voluptate velit esse cillum dolore eu fugiat nulla pariatur.
          Excepteur sint occaecat cupidatat non proident, sunt in culpa
          qui officia deserunt mollit anim id est laborum.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_extreme_sensio
        email:        job@example.com
        expires_at:   2010-10-10

Un file fixture è scritto in YAML e definisce gli oggetti del modello, etichettati con un
nome univoco. Questa etichetta è molto utile per collegare gli oggetti correlati senza
dover definire delle chiavi primarie (che sono spesso degli auto-increment e quindi non
possono essere impostate). Per esempio, la categoria `job_sensio_labs` è `programming`,
che è l'etichetta assegnata alla categoria 'Programming'.

Un file fixture può contenere oggetti provenienti da diversi modelli.

>**TIP**
>Nota i numeri che precedono i nomi dei file. Questo è un modo semplice per controllare
>l'ordine del caricamento dei dati. Più avanti nel progetto, se avremo bisogno di inserire
>nuovi file fixture, sarà facile perché avremo alcuni numeri liberi tra quelli
>esistenti.

In un file fixture, non hai bisgno di definire tutti i valori delle colonne. Se non lo
fai, symfony userà i valori di default definiti nello schema del database. E siccome
syfmony usa Propel per caricare i dati nel database, tutti i comportamenti predefiniti
(come impostare le colonne `created_at` o `updated_at`), o i comportamenti personalizzati
che potresti aver aggiunto alle classi del modello saranno attivati.

Caricare i dati iniziali nel database è facile come eseguire il task:
`propel:data-load`:

    $ php symfony propel:data-load

Vediamolo in azione nel browser
-------------------------------

Abbiamo usato molto la linea di comando ma questo non è molto eccitante, specialmente
per un progetto web. Ora abbiamo tutto ciò che ci serve per creare pagine web che
interagiscano col database.

Vediamo come mostrare una lista di lavori, come modificare un lavoro esistente, e com
cancellare un lavoro. Come spiegato nel giorno 1, un progetto symfony è composto da
applicazioni. Ciascuna applicazione è composta da **moduli**. Un modulo è un insieme
autonomo di codice PHP che rappresenta una feature dell'applicazione (ad esempio il
modulo delle API), o un insieme di manipolazioni che l'utente può fare su un oggetto del
modello (ad esempio il modulo `job`).

Symfony è in grado di generare automaticamente per un modello dato un modulo che fornisce
delle feature basilari di manipolazione:

    $ php symfony propel:generate-module --with-show --non-verbose-templates frontend job JobeetJob

Il comando `propel:generate-module` genera un modulo `job` nell'applicazione `frontend`
per il modello `JobeetJob`. Come per molti task di symfony, alcuni file e cartelle sono
stati creati per te sotto la cartella `apps/frontend/modules/job`:

 | Cartella   | Descrizione
 | ---------- | --------------------
 | actions/   | Le azioni del modulo
 | templates/ | I template del modulo

Il file `actions/actions.class.php` definisce tutte le azioni disponibili per il modulo
`job`:

 | Nome azione  | Descrizione
 | ------------ | -------------------------------------------------------
 | index        | Mostra le righe della tabella
 | show         | Mostra i campi di una data riga
 | new          | Mostra una form per creare una nuova riga
 | create       | Crea una nuova riga
 | edit         | Mostra una form per modificare una riga esistente
 | update       | Aggiorna una riga con i valori inseriti dall'utente
 | delete       | Cancella una data riga dalla tabella

Ora puoi provare il modulo `job` in un browser:

     http://jobeet.localhost/frontend_dev.php/job

![Job module](http://www.symfony-project.org/images/jobeet/1_2/03/job.png)

Se provi a modificare un lavoro, avrai un'eccezione perché symfony ha bisogno di una
rappresentazione testuale di una categoria. La rappresentazione testuale di un oggetto
PHP può essere definita col metodo magico `__toString()`. La rappresentazione testuale di
una categoria andrebbe definita nella classe del modello `JobeetCategory`:

    [php]
    // lib/model/JobeetCategory.php
    class JobeetCategory extends BaseJobeetCategory
    {
      public function __toString()
      {
        return $this->getName();
      }
    }

Ora ogni volta che symfony ha bisogno della rappresentazione testuale di una categoria,
chiama il metodo `__toString()` che restituisce il nome della categoria. Siccome abbiamo
bisogno di una rappresentazione testuale di tutte le classi del modello in un punto o
nell'altro, definiamo un metodo `__toString()` per ogni classe del modello:

    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function __toString()
      {
        return sprintf('%s at %s (%s)', $this->getPosition(), $this->getCompany(), $this->getLocation());
      }
    }

    // lib/model/JobeetAffiliate.php
    class JobeetAffiliate extends BaseJobeetAffiliate
    {
      public function __toString()
      {
        return $this->getUrl();
      }
    }

Ora puoi creare e modificare i lavori. Prova a lasciare un campo richiesto in bianco, o
prova ad immettere una data non valida. Tutto bene, symfony ha creato delle regole di
validazione di base, partendo dallo schema del database.


![validation](http://www.symfony-project.org/images/jobeet/1_2/03/validation.png)

A domani
--------

Per oggi è tutto. Siete stati avvertiti nell'introduzione. Oggi abbiamo scritto poco
codice PHP, ma abbiamo un modulo web funzionante per il modello `job`, pronto per essere
aggiustato e personalizzato. Ricorda, niente codice PHP significa anche niente bug!

Se vi è rimasta un po' di energia, puoi anche leggere il codice generato per il modulo e
per il modello, e provare a capire come funziona. Altrimenti, non preoccupati e dormi
bene, perché domani parleremo di uno dei paradigmi più usati nei framework per il web, il
[design pattern MVC](http://it.wikipedia.org/wiki/Model-view-controller).

Il codice scritto oggi è stato reso pubblico sul repository SVN di Jobeet sotto il tag
`release_day_03` tag (`http://svn.jobeet.org/tags/release_day_03/`).
