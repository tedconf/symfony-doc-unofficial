Day 6: Di più sul Modello
=========================

Precedentemente su Jobeet
-------------------------

Ieri è stato un grande giorno. Avete imparato come creare URL carini e come usare
il symfony framework per automatizzare parecchie cose per voi.

Oggi miglioreremo il sito web di Jobeet ottimizzando il codice qui è là. Facendolo
imparerete ulteriormente ad utilizzare tutte le feature introdotte questa settimana.

Il Propel Criteria Object
-------------------------

Dai requisiti del giorno 2:

  "Quando un utente arriva sul sito web di Jobeet vede una lista di offert di 
  lavoro attive."

Ma al momento tutti le offerte di lavoro sono visualizzate, indipendentemente dal
fatto che siano attive o meno:

    [php]
    class jobActions extends sfActions
    {
      public function executeIndex(sfWebRequest $request)
      {
        $this->jobs = JobeetJobPeer::doSelect(new Criteria());
      }

      // ...
    }

Un'offerta di lavoro attiva è un'offerta pubblicata da meno di 30 giorni. Il 
metodo `doSelect()` utilizza un oggetto di tipo `Criteria` che descrive la 
richiesta da fare al database. Nel codice seguente viene passato un `Criteria`
vuoto, questo significa che tutti i record vengono recuperati dal database.

Modifichiamolo per ottenere solamente le offerte attive:

    [php]
    public function executeIndex(sfWebRequest $request)
    {
      $criteria = new Criteria();
      $criteria->add(JobeetJobPeer::CREATED_AT, time() - 86400 * 30, Criteria::GREATER_THAN);

      $this->jobs = JobeetJobPeer::doSelect($criteria);
    }

Il metodo `Criteria::add()` aggiunge una clausola `WHERE` all'SQL generato. Qui
abbiamo ristretto il criterio di selezione per recuperate solamente le offerte
di lavoro che sono state inserite da meno di 30 giorni. Questo metodo offre
molti operatori di comparazione; di seguito trovate i più comuni:

  * `Criteria::EQUAL`
  * `Criteria::NOT_EQUAL`
  * `Criteria::GREATER_THAN`, `Criteria::GREATER_EQUAL`
  * `Criteria::LESS_THAN`, `Criteria::LESS_EQUAL`
  * `Criteria::LIKE`, `Criteria::NOT_LIKE`
  * `Criteria::CUSTOM`
  * `Criteria::IN`, `Criteria::NOT_IN`
  * `Criteria::ISNULL`, `Criteria::ISNOTNULL`
  * `Criteria::CURRENT_DATE`, `Criteria::CURRENT_TIME`,
    `Criteria::CURRENT_TIMESTAMP`

Debugging dell'SQL generato da Propel
-------------------------------------

Visto che non scriverete direttamente le query SQL a mano Propel si prenderà cura
delle differenze tra i diversi database engine è genererà codice SQL ottimizzato
per il database engine selezionato durante il giorno 3. Alcune volte però è molto
utile verificare il codice SQL generato da Propel; per esempio per fare del debug
di un `Criteria` che non funziona come ci si aspetta. Nell'ambiente di sviluppo
(`dev`) symfony logga queste query (assieme a molto altro) nella directory `log/`.
Esiste un file di log per ogni combinazione di applicazione ed ambiente. Il file 
che stiamo cercando si chiama `frontend_dev.log`:

    # log/frontend_dev.log
    Dec 6 15:47:12 symfony [debug] {sfPropelLogger} exec: SET NAMES 'utf8'
    Dec 6 15:47:12 symfony [debug] {sfPropelLogger} prepare: SELECT
    ➥ jobeet_job.ID, jobeet_job.CATEGORY_ID, jobeet_job.TYPE,
    ➥ jobeet_job.COMPANY, jobeet_job.LOGO, jobeet_job.URL, jobeet_job.POSITION,
    ➥ jobeet_job.LOCATION, jobeet_job.DESCRIPTION, jobeet_job.HOW_TO_APPLY,
    ➥ jobeet_job.TOKEN, jobeet_job.IS_PUBLIC, jobeet_job.CREATED_AT,
    ➥ jobeet_job.UPDATED_AT FROM `jobeet_job` WHERE jobeet_job.CREATED_AT>:p1
    Dec 6 15:47:12 symfony [debug] {sfPropelLogger} Binding '2008-11-06 15:47:12'
    ➥ at position :p1 w/ PDO type PDO::PARAM_STR

Potete vedere da soli che Propel ha generato una clusola where per la colonna
`created_at` (`WHERE jobeet_job.CREATED_AT > :p1`).

>**NOTA**
>La string `:p1` nella query indica che Propel genera prepared
>statements. Il valore attuale di `:p1` ('2008-11-06 15:47:12' nell'esempio precedente)
>è passato durante l'esecuzione della query e su di esso viene eseguito l'apposito
>escape dal database engine. L'utilizzo dei prepared statementsriduce drasticamente
>l'esposizione al problema dell'[SQL injection](http://en.wikipedia.org/wiki/Sql_injection).

Questo è bene ma è un po' scomodo dover passare dal browser, all'IDE ed al file 
di log ogni volta che si ha bisogno di testare un cambiamento. Grazie alla
symfony web debug toolbar, tutte le informazioni necessarie sono comodamente
disponibili all'interno del browser:

![query SQL nella web debug toolbar](http://www.symfony-project.org/images/jobeet/1_2/06/web_debug_sql.png)

Serializzazione degli oggetti
-----------------------------

Anche se il codice precedente funziona non rappresenta la strada da percorrere.
Nel giorno 2 i requisiti specificano:

  "Un utente può tornare per riattivare o estendere la validità di un'offerta
  di lavoro per ulteriori 30 giorni..."

Questo non è possibile con il codice precedente visto che il valore di `created_at`
non andrebbe cambiato una volta che il record viene creato.

Se ricordate lo schema del database abbiamo una colonna `expires_at`. Attualmente
questo valore è sempre vuoto. Quando un'offerta di lavoro viene creata il valore
va impostato a 30 giorni successivi alla data corrente. Per fare qualcosa prima 
che un oggetto di tipo Propel venga serializzato sul database potete fare l'override
del metodo `save()`:

    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function save(PropelPDO $con = null)
      {
        if ($this->isNew() && !$this->getExpiresAt())
        {
          $now = $this->getCreatedAt() ? $this->getCreatedAt() : time();
          $this->setExpiresAt($now + 86400 * 30);
        }

        return parent::save($con);
      }

      // ...
    }

Il metodo `isNew()` restituisce il valore `true` quando l'oggetto non è ancora 
stato serializzato a database e `false` altrimenti.

Modifichiamo l'action per utilizzare la colonna `expires_at`:

    [php]
    public function executeIndex(sfWebRequest $request)
    {
      $criteria = new Criteria();
      $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::GREATER_THAN);

      $this->jobs = JobeetJobPeer::doSelect($criteria);
    }

Abbiamo ristretto il criterio per selezionare solamente le offerte di lavoro
con la data `expires_at` nel futuro.
