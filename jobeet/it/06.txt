Day 6: Di più sul Modello
=========================

Precedentemente su Jobeet
-------------------------

Ieri è stato un grande giorno. Avete imparato come creare URL carini e come usare
il symfony framework per automatizzare parecchie cose per voi.

Oggi miglioreremo il sito web di Jobeet ottimizzando il codice qui è là. Facendolo
imparerete ulteriormente ad utilizzare tutte le feature introdotte questa settimana.

Il Propel Criteria Object
-------------------------

Dai requisiti del giorno 2:

  "Quando un utente arriva sul sito web di Jobeet vede una lista di offert di 
  lavoro attive."

Ma al momento tutti le offerte di lavoro sono visualizzate, indipendentemente dal
fatto che siano attive o meno:

    [php]
    class jobActions extends sfActions
    {
      public function executeIndex(sfWebRequest $request)
      {
        $this->jobs = JobeetJobPeer::doSelect(new Criteria());
      }

      // ...
    }

Un'offerta di lavoro attiva è un'offerta pubblicata da meno di 30 giorni. Il 
metodo `doSelect()` utilizza un oggetto di tipo `Criteria` che descrive la 
richiesta da fare al database. Nel codice seguente viene passato un `Criteria`
vuoto, questo significa che tutti i record vengono recuperati dal database.

Modifichiamolo per ottenere solamente le offerte attive:

    [php]
    public function executeIndex(sfWebRequest $request)
    {
      $criteria = new Criteria();
      $criteria->add(JobeetJobPeer::CREATED_AT, time() - 86400 * 30, Criteria::GREATER_THAN);

      $this->jobs = JobeetJobPeer::doSelect($criteria);
    }

Il metodo `Criteria::add()` aggiunge una clausola `WHERE` all'SQL generato. Qui
abbiamo ristretto il criterio di selezione per recuperate solamente le offerte
di lavoro che sono state inserite da meno di 30 giorni. Questo metodo offre
molti operatori di comparazione; di seguito trovate i più comuni:

  * `Criteria::EQUAL`
  * `Criteria::NOT_EQUAL`
  * `Criteria::GREATER_THAN`, `Criteria::GREATER_EQUAL`
  * `Criteria::LESS_THAN`, `Criteria::LESS_EQUAL`
  * `Criteria::LIKE`, `Criteria::NOT_LIKE`
  * `Criteria::CUSTOM`
  * `Criteria::IN`, `Criteria::NOT_IN`
  * `Criteria::ISNULL`, `Criteria::ISNOTNULL`
  * `Criteria::CURRENT_DATE`, `Criteria::CURRENT_TIME`,
    `Criteria::CURRENT_TIMESTAMP`

Debugging dell'SQL generato da Propel
-------------------------------------

Visto che non scriverete direttamente le query SQL a mano Propel si prenderà cura
delle differenze tra i diversi database engine è genererà codice SQL ottimizzato
per il database engine selezionato durante il giorno 3. Alcune volte però è molto
utile verificare il codice SQL generato da Propel; per esempio per fare del debug
di un `Criteria` che non funziona come ci si aspetta. Nell'ambiente di sviluppo
(`dev`) symfony logga queste query (assieme a molto altro) nella directory `log/`.
Esiste un file di log per ogni combinazione di applicazione ed ambiente. Il file 
che stiamo cercando si chiama `frontend_dev.log`:

    # log/frontend_dev.log
    Dec 6 15:47:12 symfony [debug] {sfPropelLogger} exec: SET NAMES 'utf8'
    Dec 6 15:47:12 symfony [debug] {sfPropelLogger} prepare: SELECT
    ➥ jobeet_job.ID, jobeet_job.CATEGORY_ID, jobeet_job.TYPE,
    ➥ jobeet_job.COMPANY, jobeet_job.LOGO, jobeet_job.URL, jobeet_job.POSITION,
    ➥ jobeet_job.LOCATION, jobeet_job.DESCRIPTION, jobeet_job.HOW_TO_APPLY,
    ➥ jobeet_job.TOKEN, jobeet_job.IS_PUBLIC, jobeet_job.CREATED_AT,
    ➥ jobeet_job.UPDATED_AT FROM `jobeet_job` WHERE jobeet_job.CREATED_AT>:p1
    Dec 6 15:47:12 symfony [debug] {sfPropelLogger} Binding '2008-11-06 15:47:12'
    ➥ at position :p1 w/ PDO type PDO::PARAM_STR

Potete vedere da soli che Propel ha generato una clusola where per la colonna
`created_at` (`WHERE jobeet_job.CREATED_AT > :p1`).

>**NOTA**
>La string `:p1` nella query indica che Propel genera prepared
>statements. Il valore attuale di `:p1` ('2008-11-06 15:47:12' nell'esempio precedente)
>è passato durante l'esecuzione della query e su di esso viene eseguito l'apposito
>escape dal database engine. L'utilizzo dei prepared statementsriduce drasticamente
>l'esposizione al problema dell'[SQL injection](http://en.wikipedia.org/wiki/Sql_injection).

Questo è bene ma è un po' scomodo dover passare dal browser, all'IDE ed al file 
di log ogni volta che si ha bisogno di testare un cambiamento. Grazie alla
symfony web debug toolbar, tutte le informazioni necessarie sono comodamente
disponibili all'interno del browser:

![query SQL nella web debug toolbar](http://www.symfony-project.org/images/jobeet/1_2/06/web_debug_sql.png)

Serializzazione degli oggetti
-----------------------------

Anche se il codice precedente funziona non rappresenta la strada da percorrere.
Nel giorno 2 i requisiti specificano:

  "Un utente può tornare per riattivare o estendere la validità di un'offerta
  di lavoro per ulteriori 30 giorni..."

Questo non è possibile con il codice precedente visto che il valore di `created_at`
non andrebbe cambiato una volta che il record viene creato.

Se ricordate lo schema del database abbiamo una colonna `expires_at`. Attualmente
questo valore è sempre vuoto. Quando un'offerta di lavoro viene creata il valore
va impostato a 30 giorni successivi alla data corrente. Per fare qualcosa prima 
che un oggetto di tipo Propel venga serializzato sul database potete fare l'override
del metodo `save()`:

    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function save(PropelPDO $con = null)
      {
        if ($this->isNew() && !$this->getExpiresAt())
        {
          $now = $this->getCreatedAt() ? $this->getCreatedAt() : time();
          $this->setExpiresAt($now + 86400 * 30);
        }

        return parent::save($con);
      }

      // ...
    }

Il metodo `isNew()` restituisce il valore `true` quando l'oggetto non è ancora 
stato serializzato a database e `false` altrimenti.

Modifichiamo l'action per utilizzare la colonna `expires_at`:

    [php]
    public function executeIndex(sfWebRequest $request)
    {
      $criteria = new Criteria();
      $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::GREATER_THAN);

      $this->jobs = JobeetJobPeer::doSelect($criteria);
    }

Abbiamo ristretto il criterio per selezionare solamente le offerte di lavoro
con la data `expires_at` nel futuro.



================================

TODO aggiungere SECONDA PARTE qui


================================





Limitare i risultati
--------------------

C'è ancora una richiesta da implementare per la lista dei lavori sulla homepage:

  "Per ogni categoria, la lista mostra solo i primi 10 lavori ed un link
  consente di elencare tutti i lavori per una data categoria."

Questo è semplice quanto aggiungere il metodo `getActiveJobs()`:

<propel>
    [php]
    // lib/model/JobeetCategory.php
    public function getActiveJobs($max = 10)
    {
      $criteria = new Criteria();
      $criteria->add(JobeetJobPeer::CATEGORY_ID, $this->getId());
      $criteria->setLimit($max);

      return JobeetJobPeer::getActiveJobs($criteria);
    }
</propel>
<doctrine>
    public function getActiveJobs($max = 10)
    {
      $q = Doctrine_Query::create()
        ->from('JobeetJob j')
        ->where('j.category_id = ?', $this->getId())
        ->limit($max);

      return Doctrine::getTable('JobeetJob')->getActiveJobs($q);
    }
</doctrine>

L'appropriata clausola `LIMIT` è ora insita nel Modello, ma è meglio che tale
valore sia configurabile. Cambiamo il template in modo che passi un numero
massimo di lavori, impostato in `app.yml`:

    [php]
    <?php foreach ($category->getActiveJobs(sfConfig::get('app_max_jobs_on_homepage')) as $i => $job): ?>

ed aggiungiamo una nuova impostazione in `app.yml`:

    [yml]
    all:
      active_days:          30
      max_jobs_on_homepage: 10

Fixture dinamiche
-----------------

A meno che non si abbassi l'impostazione `max_jobs_on_homepage` ad uno, non si
vedrà nessuna differenza. Abbiamo bisogno di aggiungere un sacco di lavori alle
fixture. Si potrebbe copiare e incollare un lavoro esistente per dieci o venti
volte a mano... ma c'è un modo migliore.
La duplicazione è male, anche nei file fixture.

symfony al salvataggio! I file YAML in symfony possono contenere codice PHP,
che viene valutato appena prima di leggere il file. Modifichiamo il file fixture
`020_jobs.yml` ed aggiungiamo alla fine il seguente codice:

    [php]
    JobeetJob:
    # Inizia all'inizio della riga (senza spazi bianchi prima)
    <?php for ($i = 100; $i <= 130; $i++): ?>
      job_<?php echo $i ?>:
<propel>
        category_id:  programming
</propel>
<doctrine>
        JobeetCategory: programming
</doctrine>
        company:      Company <?php echo $i."\n" ?>
        position:     Web Developer
        location:     Paris, France
        description:  Lorem ipsum dolor sit amet, consectetur adipisicing elit.
        how_to_apply: |
          Send your resume to lorem.ipsum [at] company_<?php echo $i ?>.sit
        is_public:    true
        is_activated: true
        token:        job_<?php echo $i."\n" ?>
        email:        job@example.com

    <?php endfor; ?>

State attenti, il parser YAML si arrabbierà se si fa confusione con l'
indentazione. Tenete a mente i seguenti semplici consigli, quando
aggiungete codice PHP ad un file YAML:

 * Le istruzioni `<?php ?>` devono sempre iniziare la riga od essere compresi in
   un valore.
 * Se un'istruzione `<?php ?>` termina una riga, si deve esplicitamente mandare
   in output un "a capo" ("\n").

Rendere sicura la pagina del lavoro
-----------------------------------

Quando un lavoro scade, anche se si conosce l'URL, non deve essere possibile
accedervi ancora. Proviamo l'URL per il lavoro scaduto (sostituire l'`id` con il
vero valore di `id` contenuto nel proprio database):

    /frontend_dev.php/job/sensio-labs/paris-france/4/web-developer-expired

Invece di mostrare il lavoro, dobbiamo rimandare l'utente ad una pagina 404.
Ma come possiamo farlo, visto che il lavoro è recuperato automaticamente
dalla rotta?

<propel>
Di default, `sfPropelRoute` usa il metodo standard `doSelectOne()` per recuperare
l'oggetto, ma si può cambiare questo comportamento fornendo un'opzione
`method_for_criteria` nella configurazione della rotta:
</propel>

    [yml]
    # apps/frontend/config/routing.yml
    job_show_user:
      url:     /job/:company_slug/:location_slug/:id/:position_slug
      class:   sfPropelRoute
      options:
        model: JobeetJob
        type:  object
<propel>
        method_for_criteria: doSelectActive
</propel>
<doctrine>
        method: retrieveActiveJob
</doctrine>
      param:   { module: job, action: show }
      requirements:
        id: \d+

<propel>
Il metodo `doSelectActive()` riceverà l'oggetto `Criteria` costruito dalla rotta:

    [php]
    // lib/model/JobeetJobPeer.php
    static public function doSelectActive(Criteria $criteria)
    {
      $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::GREATER_THAN);

      return self::doSelectOne($criteria);
    }
</propel>
<doctrine>
Il metodo `doSelectActive()` riceverà l'oggetto `Doctrine_Query` costruito dalla rotta:

    [php]
    // lib/model/doctrine/JobeetJobTable.class.php
    public function retrieveActiveJob(Doctrine_Query $q)
    {
      $q->andWhere('a.expires_at > ?', date('Y-m-d h:i:s', time()));

      return $q->fetchOne();
    }
</doctrine>

Se ora si prova ad ottenere un lavoro scaduto, si verrà rimandati ad una pagina 404.

Link alla pagina della categoria
--------------------------------

Aggiungiamo ora un link alla pagina della cateogoria sulla homepage e creiamo la
pagina della categoria.

Ma aspettate un minuto. C'è ancora tempo e non abbiamo lavorato molto. Avete un
sacco di tempo libero ed abbastanza conoscenze per implementare tutto questo da
soli! Rendiamolo un esercitazione. Tornate domani a controllare l'implementazione.

A domani
--------

Lavorate ad un'implementazione del vostro progetto Jobeet in locale. Abusate pure
dellae [documentazione API](http://www.symfony-project.org/api/1_2/) online e di
tutta la [documentazione](http://www.symfony-project.org/doc/1_2/) liberamente
disponibile sul sito di symfony per aiutarvi. Ci vediamo domani con la nostra
implementazione.

Buona fortuna!

Come sempre, si può fare un checkout del codice sorgente di Jobeet di oggi:

    http://svn.jobeet.org/tags/release_day_06/

__ORM__
