Giorno 9: I test funzionali
===========================

Precedentemente su Jobeet
-------------------------

Ieri abbiamo visto come realizzare unit test per le classi di Jobeet 
usando la libreria per il testing lime distribuita con symfony.

Oggi scriveremo test funzionali per le feature già implementate nei
moduli `job` e `category`.

Test funzionali
---------------

I test funzionali sono un ottimo strumento per testare la vostra applicazione
in modo completo: dalla richiesta fatta da un browser alla risposta inviata
dal server. Permettono di testare tutti i layer di un'applicazione: il routing,
il modello, le action e i template. Molto probabilmente sono molto simili a
ciò che fate già manualmente: ogni volta che aggiungete o modificate un'action
c'è bisogno di andare sul browser e verificare che tutto funzioni a dovere
cliccando sui link e controllando gli elementi nella pagina visualizzata. In
altre parole eseguite lo scenario relativo al caso d'uso appena implementato.

Visto che il processo è manuale può risultare noioso e fonte di errori. Ogni
volta che cambiate qualcosa nel codice dovete passare attraverso tutti gli
scenari per assicurarvi che quello che avete fatto non abbia rotto qualcosa.
Non va bene. I test funzionali in symfony mettono a disposizione una via per 
descrivere in modo semplice gli scenari. Ogni scenario può essere eseguito 
automaticamente più e più volte per simulare la user experience di un utente
attraverso il suo browser. Come gli unit test vi danno la possibilità di 
scrivere codice in tranquillità.

La classe `sfBrowser`
---------------------

In symfony i test funzionali vengono eseguiti attraverso un browser speciale
implementato dalla classe [`sfBrowser`](http://www.symfony-project.org/api/1_2/sfBrowser).
Si comporta come un browser realizzato per la vostra applicazione e direttamente
connesso ad essa, senza il bisogno di un web server. Vi dà l'accesso a tutti gli
oggetti di symfony prima e dopo ogni richiesta dandovi l'opportunità di analizzarli
e fare i controlli di cui avete bisogno.

`sfBrowser` mette a disposizione i metodi che simulano le azioni compiute in un
classico broswer:

 | Metodo       | Descrizione
 | ------------ | -------------------------------------------------
 | `get()`      | Get di un URL
 | `post()`     | Post a un URL
 | `call()`     | Chiama un URL (usato per i metodi `PUT` e `DELETE`)
 | `back()`     | Torna indietro di una pagina nella history
 | `forward()`  | Avanza di una pagina nella history
 | `reload()`   | Ricarica la pagina corrente
 | `click()`    | Clicca un link o un pulsante
 | `select()`   | Seleziona un radiobutton o checkbox
 | `deselect()` | Deseleziona un radiobutton o checkbox
 | `restart()`  | Rilancia il browser

Vediamo alcuni esempi di utilizzo dei metodi `sfBrowser`:

    [php]
    $browser = new sfBrowser();

    $browser->
      get('/')->
      click('Design')->
      get('/category/programming?page=2')->
      get('/category/programming', array('page' => 2))->
      post('search', array('keywords' => 'php'))
    ;

`sfBrowser` contiene metodi addizionali per configurare l'aspetto del browser:

 | Method             | Description
 | ------------------ | ---------------------------------------------------
 | `setHttpHeader()`  | Imposta gli HTTP header
 | `setAuth()`        | Imposta le credenziali di base per l'autenticazione
 | `setCookie()`      | Imposta un cookie
 | `removeCookie()`   | Rimuove un cookie
 | `clearCookie()`    | Rimuove tutti i cookies correnti
 | `followRedirect()` | Segue un redirect

La classe `sfTestFunctional`
----------------------------

Abbiamo un broser ma abbiamo anche bisogno di un modo per analizzare gli oggetti
di symfony per eseguire i test attuali. Può essere fatto con lime e alcuni metodi
di `sfBrowser` come `getResponse()` e `getRequest()`, symfony però mette a
disposizione una via migliore.

I metodi di test sono messi a disposizione da un'altra classe
[`sfTestFunctional`](http://www.symfony-project.org/api/1_2/sfTestFunctional)
che prende un'istanza di `sfBrowser` nel suo costruttore. La classe `sfTestFunctional`
delega i test agli oggetti **tester**. Svariati tester sono distribuiti con 
symfony, inoltre potete realizzarne di vostri.

Come abbiamo visto ieri i test funzionali vengono memorizzati nella directory
`test/functional`. Per Jobeet trovate i test nella sotto-directory `test/functional/frontend`
visto che ogni applicazione ha la propria sotto-directory. Questa directory
contiene 2 file: `categoryActionsTest.php` e `jobActionsTest.php` semplici 
test funzionali creati automaticamente dai task che generano i moduli

    [php]
    // test/functional/frontend/categoryActionsTest.php
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new sfTestFunctional(new sfBrowser());

    $browser->
      get('/category/index')->

      with('request')->begin()->
        isParameter('module', 'category')->
        isParameter('action', 'index')->
      end()->

      with('response')->begin()->
        isStatusCode(200)->
        checkElement('body', '!/This is a temporary page/')->
      end()
    ;

A prima vista lo script precevente vi potrà sembrare un po' strano. Questo perchè
i metodi di `sfBrowser` e `sfTestFunctional` ritornano sempre `$this` per
abilitare una [fluent interface](http://en.wikipedia.org/wiki/Fluent_interface).
Questo permette di concatenare le chiamate ai metodi per una migliore leggibilità.

I test sono eseguiti in un tester block context. Ogni tester block context inizia
con `with('TESTER NAME')->begin()` e termina con `end()`:

    [php]
    $browser->
      with('request')->begin()->
        isParameter('module', 'category')->
        isParameter('action', 'index')->
      end()
    ;

Il codice verifica che il parametro `module` della richiesta sia uguale a 
`category` e che `action` sia uguale a `index`.

>**TIP**
>Quando avete bisogno di chiamare un solo metodo in un tester non è necessario
>creare un blocco: `with('request')->isParameter('module', 'category')`.

### Il Tester della Richiesta

Il **request tester** mette a disposizione i metodi per analizzare e testare
gli oggetti `sfWebRequest`:

 | Metodo             | Descrizione
 | ------------------ | -------------------------------------------------------
 | `isParameter()`    | Controlla il valore di un parametro di una richiesta
 | `isFormat()`       | Controlla il formato di una richiesta
 | `isMethod()`       | Controlla un metodo
 | `hasCookie()`      | Controlla se la richiesta ha un cookie con un dato nome
 | `isCookie()`       | Controlla il valore di un cookie

### Il Tester della Risposta

C'è anche una classe **response tester** che mette a disposizione i metodi per analizzare e testare
gli oggetti `sfWebResponse`:

 | Metodo             | Descrizione
 | ------------------ | -----------------------------------------------------
 | `checkElement()`   | Checks if a response CSS selector match some criteria
 | `isHeader()`       | Controlla il valore dell'header
 | `isStatusCode()`   | Controlla lo status code della risposta
 | `isRedirected()`   | Controlla se la risposta corrente è un redirect

>**NOTE**
>Descriveremo altre classi [tester](http://www.symfony-project.org/api/1_2/test)
>nei prossimi giorni (per form, user, cache, ...).

Eseguire Test funzionali
------------------------

Come per i test unitari, eseguire test funzionali può essere fatto eseguendo
il file di test direttamente

    $ php test/functional/frontend/categoryActionsTest.php

O utilizzando il task `test:functional`:

    $ php symfony test:functional frontend categoryActions

![Tests on the command line](http://www.symfony-project.org/images/jobeet/1_2/09/cli_tests.png)

Dati da testare
---------

Come per i test unitari per ##ORM##, dobbiamo caricare i dati da testare
ogni volta che eseguiamo un test funzionale. Possiamo riutilizzare il
codice scritto ieri:

    [php]
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new JobeetTestFunctional(new sfBrowser());
<propel>
    $loader = new sfPropelData();
    $loader->loadData(sfConfig::get('sf_test_dir').'/fixtures');
</propel>
<doctrine>
    Doctrine::loadData(sfConfig::get('sf_test_dir').'/fixtures');
</doctrine>

Caricare dati in un test funzionale è più facile rispetto ad un test unitario
in quanto il database è già stato inizializzato dallo script di bootstrap.

Come per i test unitari, non copieremo questo pezzo di codice in ogni file di
test, ma creeremo piuttosto una nostra classe che eredita da `sfTestFunctional`:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function loadData()
      {
<propel>
        $loader = new sfPropelData();
        $loader->loadData(sfConfig::get('sf_test_dir').'/fixtures');
</propel>
<doctrine>
        Doctrine::loadData(sfConfig::get('sf_test_dir').'/fixtures');
</doctrine>
        return $this;
      }
    }

Scrivere Test Funzionali
------------------------

Scrivere test funzionali è come eseguire uno scenario in un browser. Abbiamo
già descritto tutti gli scenari che abbiamo bisogno di testare nel giorno 2.

Per prima cosa, testiamo l'homepage modificando il file `jobActionsTest.php`.
Rimpiazziamo il codice esistente con il seguente:

### I lavori scaduti non sono listati

    [php]
    // test/functional/frontend/jobActionsTest.php
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new JobeetTestFunctional(new sfBrowser());
    $browser->loadData();

    $browser->info('1 - The homepage')->
      get('/')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'index')->
      end()->
      with('response')->begin()->
        info('  1.1 - Expired jobs are not listed')->
        checkElement('.jobs td.position:contains("expired")', false)->
      end()
    ;

Come con `lime`, un messaggio d'informazione può venir inserito chiamando
il metodo `info()` per rendere l'output più leggibile. Per l'esclusione di
lavori scaduti dall'homepage, controlliamo che il selettore CSS
`.jobs td.position:contains("expired")` non trovi corrispondenze
in nessun posto dell'HTML generato (ricordate che nei file con le fixtures,
i lavori scaduti che abbiamo contengono "expired" nella posizione).

>**TIP**
>Il metodo `checkElement()` è capace di interpretare la maggioranza dei selettori
>CSS3 validi.

### Solo n lavori sono listati per una categoria

Aggiungi il seguente codice alla fine del file di test:

    [php]
    // test/functional/frontend/jobActionsTest.php
    $max = sfConfig::get('app_max_jobs_on_homepage');

    $browser->info('1 - The homepage')->
      get('/')->
      info(sprintf('  1.2 - Only %s jobs are listed for a category', $max))->
      with('response')->
        checkElement('.category_programming tr', $max)
    ;

Il metodo `checkElement()` può inoltre controllare che un selettore abbia n corrispondenze.

### Una categoria ha un link alla pagina della categoria solo se ha troppi lavori

    [php]
    $browser->info('1 - The homepage')->
      get('/')->
      info('  1.3 - A category has a link to the category page only if too many jobs')->
      with('response')->begin()->
        checkElement('.category_design .more_jobs', false)->
        checkElement('.category_programming .more_jobs')->
      end()
    ;

Qui, dobbiamo controlalre che non ci sia il link "more jobs"  per la categoria
design (`.category_design .more_jobs` non esista), e che ci sia il link
"more jobs" per la categoria programming (`.category_programming .more_jobs`
esista).

### I lavori sono ordinati cronologicamente

    [php]
<propel>
    // most recent job in the programming category
    $criteria = new Criteria();
    $criteria->add(JobeetCategoryPeer::SLUG, 'programming');
    $category = JobeetCategoryPeer::doSelectOne($criteria);

    $criteria = new Criteria();
    $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::GREATER_THAN);
    $criteria->add(JobeetJobPeer::CATEGORY_ID, $category->getId());
    $criteria->addDescendingOrderByColumn(JobeetJobPeer::CREATED_AT);

    $job = JobeetJobPeer::doSelectOne($criteria);
</propel>
<doctrine>
    $q = Doctrine_Query::create()
      ->select('j.*')
      ->from('JobeetJob j')
      ->leftJoin('j.JobeetCategory c')
      ->where('c.slug = ?', 'programming')
      ->andWhere('j.expires_at > ?', date('Y-m-d', time()))
      ->orderBy('j.created_at DESC');

    $job = $q->fetchOne();
</doctrine>

    $browser->info('1 - The homepage')->
      get('/')->
      info('  1.4 - Jobs are sorted by date')->
      with('response')->begin()->
        checkElement('.category_programming tr:last:contains("102")')->
        checkElement(sprintf('.category_programming tr:first a[href*="/%d/"]', $job->getId()))->
      end()
    ;

Per testare se i lavori sono ordinati cronologicamente, controlliamo che l'ultimo
lavoro nell'homepage contenga `102` nella compagnia. Ma testare il primo lavoro
nella lista programming è più impegnativo, dato che i primi due lavori hanno
esattamente la stessa posizione, compagnia e locazione. Per cui abbiamo bisogno
di controllare che l'URL contenga la corretta chiave primaria. Dato che la chiave
primaria può cambiare tra le varie esecuzioni, abbiamo bisogno che delll'oggetto
##ORM## dal database innanzitutto.

Anche se il test funziona così com'è, dobbiamo eseguire un leggero refactoring,
dato che ottenere il primo lavoro della categoria programming può venir riutilizzato
da qualche altra parte nei test. Non sposteremo il codice nel modello dato che
è specifico per il test. Al contrario, lo sposteremo all'interno della classe
`JobeetTestFunctional` che abbiamo creato in precedenza. Questa classe si comporta
come una classe per il test specifica per Jobeet:

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function getMostRecentProgrammingJob()
      {
<propel>
        // most recent job in the programming category
        $criteria = new Criteria();
        $criteria->add(JobeetCategoryPeer::SLUG, 'programming');
        $category = JobeetCategoryPeer::doSelectOne($criteria);

        $criteria = new Criteria();
        $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::GREATER_THAN);
        $criteria->addDescendingOrderByColumn(JobeetJobPeer::CREATED_AT);

        return JobeetJobPeer::doSelectOne($criteria);
</propel>
<doctrine>
        $q = Doctrine_Query::create()
          ->select('j.*')
          ->from('JobeetJob j')
          ->leftJoin('j.JobeetCategory c')
          ->where('c.slug = ?', 'programming')
          ->andWhere('j.expires_at > ?', date('Y-m-d', time()))
          ->orderBy('j.created_at DESC');

        return $q->fetchOne();
</doctrine>
      }

      // ...
    }

### Ogni lavoro nella homepage è cliccabile

    [php]
    $browser->info('2 - The job page')->
      get('/')->

      info('  2.1 - Each job on the homepage is clickable')->
      click('Web Developer', array('position' => 1))->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'show')->
        isParameter('company_slug', 'sensio-labs')->
        isParameter('location_slug', 'paris-france')->
        isParameter('position_slug', 'web-developer')->
        isParameter('id', $browser->getMostRecentProgrammingJob()->getId())->
      end()
    ;

Per testare il link al lavoro nella homepage, simuliamo il click nel testo
"Web Developer". Dato che questo testo è presente più volte nella stessa
pagina, abbiamo chiesto esplicitamente al browser di cliccare il primo
(`array('position' => 1)`).

Ogni parametro di richiesta è cosi testato per assicurare che il routing ha
fatto il suo lavoro correttamente.

Imparare per esempi
-------------------

In questa sezione abbiamo fornito tutto il codice necessario per testare le
pagine dei lavori e delle categorie. Leggete attentamente il codice, perché
potreste imparare alcuni interessanti nuovi trucchi.

    [php]
    // lib/test/JobeetTestFunctional.class.php
    class JobeetTestFunctional extends sfTestFunctional
    {
      public function loadData()
      {
<propel>
        $loader = new sfPropelData();
        $loader->loadData(sfConfig::get('sf_test_dir').'/fixtures');
</propel>
<doctrine>
        Doctrine::loadData(sfConfig::get('sf_test_dir').'/fixtures');
</doctrine>

        return $this;
      }

      public function getMostRecentProgrammingJob()
      {
<propel>
        // lavori più recenti nella categoria programming
        $criteria = new Criteria();
        $criteria->add(JobeetCategoryPeer::SLUG, 'programming');
        $category = JobeetCategoryPeer::doSelectOne($criteria);

        $criteria = new Criteria();
        $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::GREATER_THAN);
        $criteria->addDescendingOrderByColumn(JobeetJobPeer::CREATED_AT);

        return JobeetJobPeer::doSelectOne($criteria);
</propel>
<doctrine>
        $q = Doctrine_Query::create()
          ->select('j.*')
          ->from('JobeetJob j')
          ->leftJoin('j.JobeetCategory c')
          ->where('c.slug = ?', 'programming')
          ->andWhere('j.expires_at > ?', date('Y-m-d', time()))
          ->orderBy('j.created_at DESC');

        return $q->fetchOne();
</doctrine>
      }

      public function getExpiredJob()
      {
<propel>
        // expired job
        $criteria = new Criteria();
        $criteria->add(JobeetJobPeer::EXPIRES_AT, time(), Criteria::LESS_THAN);

        return JobeetJobPeer::doSelectOne($criteria);
</propel>
<doctrine>
        $q = Doctrine_Query::create()
          ->from('JobeetJob j')
          ->where('j.expires_at < ?', date('Y-m-d', time()));

        return $q->fetchOne();
</doctrine>
      }
    }

    // test/functional/frontend/jobActionsTest.php
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new JobeetTestFunctional(new sfBrowser());
    $browser->loadData();

    $browser->info('1 - The homepage')->
      get('/')->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'index')->
      end()->
      with('response')->begin()->
        info('  1.1 - Expired jobs are not listed')->
        checkElement('.jobs td.position:contains("expired")', false)->

        info(sprintf('  1.2 - Only %s jobs are listed for a category', sfConfig::get('app_max_jobs_on_homepage')))->
        checkElement('.category_programming tr', sfConfig::get('app_max_jobs_on_homepage'))->

        info('  1.3 - A category has a link to the category page only if too many jobs')->
        checkElement('.category_design .more_jobs', false)->
        checkElement('.category_programming .more_jobs')->

        info('  1.4 - Jobs are sorted by date')->
        checkElement(sprintf('.category_programming tr:first a[href*="/%d/"]', $browser->getMostRecentProgrammingJob()->getId()))->
        checkElement('.category_programming tr:last:contains("102")')->
      end()
    ;

    $browser->info('2 - The job page')->
      info('  2.1 - Each job on the homepage is clickable and give detailed information')->
      click('Web Developer', array('position' => 1))->
      with('request')->begin()->
        isParameter('module', 'job')->
        isParameter('action', 'show')->
        isParameter('company_slug', 'sensio-labs')->
        isParameter('location_slug', 'paris-france')->
        isParameter('position_slug', 'web-developer')->
        isParameter('id', $browser->getMostRecentProgrammingJob()->getId())->
      end()->

      info('  2.2 - A non-existent job forwards the user to a 404')->
      get('/job/foo-inc/milano-italy/0/painter')->
      with('response')->isStatusCode(404)->

      info('  2.3 - An expired job page forwards the user to a 404')->
      get(sprintf('/job/sensio-labs/paris-france/%d/web-developer', $browser->getExpiredJob()->getId()))->
      with('response')->isStatusCode(404)
    ;

    // test/functional/frontend/categoryActionsTest.php
    include(dirname(__FILE__).'/../../bootstrap/functional.php');

    $browser = new JobeetTestFunctional(new sfBrowser());
    $browser->loadData();

    $browser->info('1 - The category page')->
      info('  1.1 - Categories on homepage are clickable')->
      get('/')->
      click('Programming')->
      with('request')->begin()->
        isParameter('module', 'category')->
        isParameter('action', 'show')->
        isParameter('slug', 'programming')->
      end()->

      info(sprintf('  1.2 - Categories with more than %s jobs also have a "more" link', sfConfig::get('app_max_jobs_on_homepage')))->
      get('/')->
      click('22')->
      with('request')->begin()->
        isParameter('module', 'category')->
        isParameter('action', 'show')->
        isParameter('slug', 'programming')->
      end()->

      info(sprintf('  1.3 - Only %s jobs are listed', sfConfig::get('app_max_jobs_on_category')))->
      with('response')->checkElement('.jobs tr', sfConfig::get('app_max_jobs_on_category'))->

      info('  1.4 - The job listed is paginated')->
      with('response')->begin()->
        checkElement('.pagination_desc', '/32 jobs/')->
        checkElement('.pagination_desc', '#page 1/2#')->
      end()->

      click('2')->
      with('request')->begin()->
        isParameter('page', 2)->
      end()->
      with('response')->checkElement('.pagination_desc', '#page 2/2#')
    ;

Debug dei test funzionali
-------------------------

A volte un test funzionale fallisce. Siccome symfony simula un browser senza
interfaccia grafica, può essere difficile diagnosticare il problema.
Fortunatamente, symfony fornisce il metodo `debug()` per mostrare gli header
e i contenuti della risposta:

    [php]
    $browser->with('response')->debug();

Il metodo `debug()` può essere inserito ovunque un un blocco di test `response`
e fermerà l'esecuzione dello script.

Imbrigliare i test funzionali
-----------------------------

Il task `test:functional` può essere anche usato per lanciare tutti i test
funzionali per un'applicazione:

    $ php symfony test:functional frontend

Il task mostra una riga per ogni file di test:

![Functional tests harness](http://www.symfony-project.org/images/jobeet/1_2/09/test_harness.png)

Imbrigliare i test
------------------

Come ci si poteva aspettare, c'è anche un task per lanciare tutti i test di
un progetto (unitari e funzionali):

    $ php symfony test:all

![Tests harness](http://www.symfony-project.org/images/jobeet/1_2/09/tests_harness.png)

A domani
--------

Concludiamo il nostro tour degli strumenti di test di symfony. Non avete più
scuse per non testare le vostre applicazioni! Con il framework lime e con il
framework dei test, symfony fornisce strumenti potenti per aiutarvi a scrivere
test con poco sforzo.

Abbiamo solo scalfito la superfici dei test funzionali. D'ora in poi, ogni volta
che implementeremo una feature, scriveremo anche dei test, per imparare di più
sul framework dei test.

Il framework dei test non sostituisce strumenti come
"[Selenium](http://selenium.seleniumhq.org/)". Selenium gira direttamente nel
browser per automatizzare i test, su diverse piattaforme e diversi browser, ed
è quindi in grado di testare i JavaScript dell'applicazione.

Tornate domani, perché parleremo di un'altra grande feature di symfony: il
framework dei form.

__ORM__
