Day 3: El Modelo De Datos
=========================

Anteriormente en Jobeet
-----------------------

Aquellos de ustedes locos por abrir el editor de texto y hacer algo de PHP estarán encantados de saber que el tutorial de hoy nos introduce algo en el desarrollo. Vamos a definir el modelo de datos Jobeet, utilizaremos un ORM para interactuar con la base de datos, y construiremos el primer módulo de nuestra aplicación. Pero como symfony hace una gran parte del trabajo por nosotros, vamos a tener un módulo web totalmente funcional sin tener que escribir mucho código PHP.

El Modelo Relacional
--------------------

Los casos de uso que escribimos ayer describen los principales objetos de nuestro proyecto: puestos de trabajo, afiliados, y las categorías. Aquí está el correspondiente diagrama de entidad relación:

![Entity relationship diagram](http://www.symfony-project.org/images/jobeet/1_2/03/diagram.png)

Además de las columnas descriptas en los casos de uso, también hemos añadido un campo `created_at` a algunos tablas. Symfony reconoce esos campos y establece el valor de la hora actual de sistema cuando un registro es creado. Esto es el mismo para el campo `updated_at` : Su valor se establece de la hora del sistema siempre que el registro se actualiza.

El Esquema
----------

Para almacenar los puestos de trabajo, afiliados, y las categorías, es evidente que necesitamos una base de datos relacional.

Pero como symfony es un framework Orientado a Objetos, nos gustaría manipular los objetos cada vez que podamos. Por ejemplo, en lugar de escribir sentencias SQL para recuperar los registros de la base de datos, preferimos usar mas los objetos.

La información de la base de datos relacional de debe ser mapeada a un modelo de objetos. Esto se puede hacer con una [herramienta ORM](http://en.wikipedia.org/wiki/Object-relational_mapping)
y afortunadamente, symfony viene incluido con dos de ellos:
[Propel](http://propel.phpdb.org/) and [Doctrine](http://www.doctrine-project.org/).
En este tutorial, usaremos Propel.

El ORM necesita una descripción de las tablas y sus relaciones para crear las clases relacionadas. Hay dos maneras de crear este esquema de descripción:
ingenieria reversa de una base de datos existente o creandolo a mano.

>**Nota**
>Algunas herramientas te permiten crear una base de datos gráficamente
>(por ejemplo [Fabforce's Dbdesigner](http://www.fabforce.net/dbdesigner4/))
>y generar directamente un `schema.xml` (con [DB Designer 4 TO Propel Schema
>Converter](http://blog.tooleshed.com/docs/dbd2propel/transform.php)).

Como la base de datos no existe todavía y, como queremos mantener la base de datos Jobeet agnóstica, vamos a crear el archivo de esquema a mano editando el archivo vacío `config/schema.yml`:

    [yml]
    # config/schema.yml
    propel:
      jobeet_category:
        id:           ~
        name:         { type: varchar(255), required: true }

      jobeet_job:
        id:           ~
        category_id:  { type: integer, foreignTable: jobeet_category,
          ➥ foreignReference: id, required: true }
        type:         { type: varchar(255) }
        company:      { type: varchar(255), required: true }
        logo:         { type: varchar(255) }
        url:          { type: varchar(255) }
        position:     { type: varchar(255), required: true }
        location:     { type: varchar(255), required: true }
        description:  { type: longvarchar, required: true }
        how_to_apply: { type: longvarchar, required: true }
        token:        { type: varchar(255), required: true, index: unique }
        is_public:    { type: boolean, required: true, default: 1 }
        is_activated: { type: boolean, required: true, default: 0 }
        email:        { type: varchar(255), required: true }
        expires_at:   { type: timestamp, required: true }
        created_at:   ~
        updated_at:   ~

      jobeet_affiliate:
        id:           ~
        url:          { type: varchar(255), required: true }
        email:        { type: varchar(255), required: true, index: unique }
        token:        { type: varchar(255), required: true }
        is_active:    { type: boolean, required: true, default: 0 }
        created_at:   ~

      jobeet_category_affiliate:
        category_id:       { type: integer, foreignTable: jobeet_category,
          ➥ foreignReference: id, required: true, primaryKey: true,
          ➥ onDelete: cascade }
        affiliate_id: { type: integer, foreignTable: jobeet_affiliate,
          ➥ foreignReference: id, required: true, primaryKey: true,
          ➥ onDelete: cascade }

>**TIP**
>Si decidiste crear las tablas escribiendoi las sentencias SQL, puedes
>generar el archivo de configuración `schema.yml` correspondiente ejecutando la tarea
>`propel:build-schema`.

El esquema es la traducción directa de un diagrama de entidad relación en formato YAML.

>**BARRA LATERAL**
>El Formato YAML
>
>De acuerdo con el sitio web oficial [YAML](http://yaml.org/), YAML es
>"es una serialización de datos estándar muy amigable para todos los lenguajes de programación"
>
>Dicho de otra manera, YAML es un lenguaje sencillo para describir los datos (strings,
>integers, dates, arrays, y hashes).
>
>Enn YAML, la estructura se muestra a través de la sangría, secuencia de elementos se denotan por
>un guión, y los pares clave/valor dentro de un mapa están separados por dos puntos. YAML también
>tiene una sintaxis abreviada para describir la misma estructura con menos líneas, donde
>los arrays explícitamente se muestran con `[]` y hashes con `{}`.
>
>Si todavía no están familiarizados con YAML, es hora de empezar con él pues el 
>framework symfony lo utiliza ampliamente para sus archivos de configuración.

El archivo `schema.yml` contiene la descripción de todas las tablas y sus columnas.
Cada columna se describe con la siguiente información:

  * `type`: El tipo de columna (`boolean`, `tinyint`, `smallint`, `integer`,
            `bigint`, `double`, `float`, `real`, `decimal`, `char`,
            `varchar(size)`, `longvarchar`, `date`, `time`, `timestamp`,
            `blob`, and `clob`)
  * `required`: Es `true` si deseas que la columna sea obligadoria
  * `index`: Es `true` si desea crear un índice para la columna o
            a `unique` si quieres que un índice único se cree en la columna.

Para las columnas establecidas a `~` (`id`, `created_at`, y `updated_at`), symfony adivinará la mejor configuración (primary key para `id` y timestamp para
`created_at` y `updated_at`).

>**NOTA**
>El atributo `onDelete` define el comportamiento `ON DELETE` para claves foráneas,
>y Propel da soporte para `CASCADE`, `SETNULL`, y `RESTRICT`. Por ejemplo, cuando
>un registro de `job` es borrado, todos los registros `jobeet_category_affiliate` relacionados 
>serán automáticamente eliminados de la base de datos o por Propel si el subyacente motor
>no soporta esta funcionalidad.

La Base De Datos
----------------

El framework symfony soporta todas las Base De Datos soportadas por PDO (MySQL, PostgreSQL,
SQLite, Oracle, MSSQL, ...). PDO es la capa de abstracción de base de datos que viene con PHP.

Vamos a usar MySQL para este tutorial:

    $ mysqladmin -uroot -pmYsEcret create jobeet

>**Nota**
>Siéntete libre de elegir otro motor de base de datos si deseas. No será difícil 
>adaptar el código que vamos a escribir ya que vamos a utilizar el ORM quien sera quien escriba el  SQL por
>nosotros.

Tenemos que decirle a symfony que base de datos usar para el proyecto Jobeet:

    $ php symfony configure:database "mysql:host=localhost;dbname=jobeet" root mYsEcret

La tarea `configure:database` emplea tres argumentos: el
[PDO DSN](http://www.php.net/manual/en/pdo.drivers.php), el nombre de usuario, y
la clave de acceso a la base de datos. Si no tienes ninguna contraseña en el servidor de desarrollo, basta con omitir el tercer argumento.

>**NOTA**
>La tarea `configure:database` almacena la configuración de la base de datos en el archivo de configuración 
>`config/databases.yml`. En lugar de utilizar la tarea, puedes
>editar este archivo manualmente.

El ORM
-------

Gracias al archivo de descripción de la base de datos `schema.yml`, podemos utilizar algunas de las tareas Propel para generar los comandos SQL necesarios para crear tablas de la base de datos:

    $ php symfony propel:build-sql

La tarea `propel:build-sql` genera comandos SQL en el directorio `data/sql`
, optimizado para el motor de base de datos que hemos configurado:

    [sql]
    # snippet from data/sql/lib.model.schema.sql
    CREATE TABLE `jobeet_category`
    (
      `id` INTEGER  NOT NULL AUTO_INCREMENT,
      `name` VARCHAR(255)  NOT NULL,
      PRIMARY KEY (`id`)
    )Type=InnoDB;

Para realmente crear las tablas en la base de datos, necesitas ejecutar la tarea `propel:insert-sql`:

    $ php symfony propel:insert-sql

Como la tarea elimina las tablas existentes antes de re-crearlas, necesitas confirmar la operación. También puedes añadir la opción `--no-confirmation` para saltearte la pregunta, lo cual es útil si deseas ejecutar la tarea desde un proceso no interactivo:

    $ php symfony propel:insert-sql --no-confirmation

>**TIP**
>Como con cualquier herramienta de línea de comandos, las tareas symfony pueden tener argumentos y opciones.
>Cada tarea viene con un mensaje de ayuda que se puede mostrar ejecutando
>la tarea `help`:
>
>     $ php symfony help propel:insert-sql
>
>El mensaje de ayuda lista de todos los posibles argumentos y opciones, da los 
>valores por defecto para cada uno de ellos, y proporciona algunos ejemplos útiles.

El ORM también genera las clases PHP que mapa los registros de la tabla con los objetos:

    $ php symfony propel:build-model

La tarea `propel:build-model` genera archivos PHP en el directorio `lib/model` que se pueden utilizar para interactuar con la base de datos.

Navegando por los archivos generados, probablemente habrás notado que Propel genera cuatro clases por tabla. Para la tabla `jobeet_job`:

  * `JobeetJob`: Un objeto de esta clase representa una registro único de la tabla `jobeet_job`. La clase está vacío por defecto.
  * `BaseJobeetJob`: La clase padre de `JobeetJob`. Cada vez que ejecutas `propel:build-model`, esta clase es sobreescrita, por lo que todas las personalizaciones se debe hacer en la clase `JobeetJob`.

  * `JobeetJobPeer`: La clase define los métodos estátivos que la mayormente devuelve colecciones de objectos `JobeetJob`. La clase está vacío por defecto.
  * `BaseJobeetJobPeer`:  La clase padre de `JobeetJobPeer`. Cada vez que ejecutas `propel:build-model`, esta clase es sobreescrita, por lo que todas las personalizaciones se debe hacer en la clase `JobeetJobPeer`.

Los valores de columnaw de un registro se puede manipular con el modelo de objetos mediante el uso de algunos accesores (métodos `get*()`) y mutadores (métodos `set*()`):

    [php]
    $job = new JobeetJob();
    $job->setPosition('Web developer');
    $job->save();

    echo $job->getPosition();

    $job->delete();

También puedes definir claves foráneas directamente por la vinculación de objetos:

    [php]
    $category = new JobeetCategory();
    $category->setName('Programming');

    $job = new JobeetJob();
    $job->setCategory($category);

La tarea `propel:build-all` es un acceso directo para las tareas que han ejecutado en esta sección y algunos más. Por lo tanto, ejecuta esta tarea ahora para generar formularios y validadores para el modelo de clases Jobeet:

    $ php symfony propel:build-all

Verás los validadores en acción al final del día y los formularios se explicarán en gran detalle en el día 10.

>**TIP**
>La tarea `propel:build-all-load` es un acceso directo para la tarea `propel:build-all` 
>seguida por la tarea `propel:data-load`.
Como se verás más adelante, symfony autocarga las clases PHP por nosotros, lo que significa que usted nunca mas necesitaras utilizar un `require` en tu código. Esta es una de las numerosas cosas que automatiza symfony para el desarrollador, pero hay un inconveniente:
siempre que agreges una nueva clase, necesitarás borrar la caché de symfony. Como la tarea `propel:build-model` ha creado un montón de nuevas clases, vamos a borrar la caché:

     $ php symfony cache:clear

>**TIP**
>Una tarea symfony está hecho de un nombre y un espacio de nombres. Cada uno puede ser más breve
>tanto como no haya ambigüedad con otras tareas. Por lo tanto, el siguiente comando
>es equivalente a `cache:clear`:
>
>     $ php symfony cc

Los Datos Iniciales
-------------------

Los tablas se han creado en la base de datos, pero no hay datos en ellas.
Para cualquier aplicación web, hay tres tipos de datos:

  * **Datos Iniciales**: Los datos iniciales son necesarios para que la aplicación funcione. Por ejemplo, obeet necesita algunas categorías iniciales. Si no, nadie será capaz de presentar un trabajo. También necesitamos un administrador de usuarios para poder acceder al backend.

  * **Datos de Prueba**: Los datos de Prueba son necesarios para que la aplicación sea probada. Como desarrollador, escribes pruebas para asegurar que Jobeet se comporta como se describe en los casos de uso, y la mejor manera es escribir pruebas automaticas. Por lo tanto, cada vez que ejecute tus pruebas, necesitas una base de datos limpia con algunos datos nuevos de prueba en ella.

  * **Los datos del usuario**: Los datos del usuario son creados por los usuarios durante la vida normal de la aplicación.

Cada vez symfony crea las tablas en la base de datos, todos los datos se pierden.
Para rellenar la base de datos con los datos iniciales que podría crear un script PHP,
o ejecutar SQL con algun programa `mysql`. Pero como la necesidad es bastante común, hay una mejor manera con symfony: crear archivos YAML en el directorio `data/fixtures/` y usar la tarea `propel:data-load` para cargarlos en la base de datos:

    [yml]
    # data/fixtures/010_categories.yml
    JobeetCategory:
      design:        { name: Design }
      programming:   { name: Programming }
      manager:       { name: Manager }
      administrator: { name: Administrator }

    # data/fixtures/020_jobs.yml
    JobeetJob:
      job_sensio_labs:
        category_id:  programming
        type:         full-time
        company:      Sensio Labs
        logo:         /uploads/jobs/sensio_labs.png
        url:          http://www.sensiolabs.com/
        position:     Web Developer
        location:     Paris, France
        description:  |
          You've already developed websites with symfony and you want to work
          with Open-Source technologies. You have a minimum of 3 years
          experience in web development with PHP or Java and you wish to
          participate to development of Web 2.0 sites using the best
          frameworks available.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_sensio_labs
        email:        job@example.com
        expires_at:   2010-10-10

      job_extreme_sensio:
        category_id:  design
        type:         part-time
        company:      Extreme Sensio
        logo:         /uploads/jobs/extreme_sensio.png
        url:          http://www.extreme-sensio.com/
        position:     Web Designer
        location:     Paris, France
        description:  |
          Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do
          eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut
          enim ad minim veniam, quis nostrud exercitation ullamco laboris
          nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor
          in reprehenderit in.

          Voluptate velit esse cillum dolore eu fugiat nulla pariatur.
          Excepteur sint occaecat cupidatat non proident, sunt in culpa
          qui officia deserunt mollit anim id est laborum.
        how_to_apply: |
          Send your resume to fabien.potencier [at] sensio.com
        is_public:    true
        is_activated: true
        token:        job_extreme_sensio
        email:        job@example.com
        expires_at:   2010-10-10

Es escrito en YAML, y define el modelo de objetos, etiquetados con un nombre único. Esta etiqueta es de gran utilidad para vincular objetos relacionados sin tener que definir claves primarias (que a menudo son auto-incrementales y no se puede establecer).
Por ejemplo, la categoría de `job_sensio_labs` es `programming`, que es la etiqueta dada a la categoría 'Programming'.

El archivo puede contener objeto de uno o varios modelos.

>**TIP**
>Nota los números de prefijo del nombre de archivo. Es un amanera simple de controlar 
>el orden de carga de datos. Más adelante en el proyecto, si es necesario insertar algunos
>nuevos archivos, será fácil como tengamos algunos números libres entre 
>los existentes.

En un archivo de datos, no es necesario para definir todos los valores de las columnas. Si no, symfony utilizará el valor predeterminado definido en el esquema de base de datos. Y como
symfony usa Propel para cargar los datos en la base de datos, todos los incorporados comportamientos (como el seteo a `created_at` o `updated_at`), o los comportamientos personalizados que puedes haber sumado al modelo de las clases son activados.

La carga de los datos iniciales en la base de datos es tan simple como ejecutar la tarea `propel:data-load`:

    $ php symfony propel:data-load

Miralo en Acción en el Navegador
--------------------------------

Hemos utilizado la interfaz de línea de comandos mucho, pero eso no es realmente emocionante, especialmente para un proyecto web. Ahora tenemos todo lo que necesitamos para crear páginas Web que interactúan con la base de datos.

Vamos a ver cómo mostrar la lista de puestos de trabajo, cómo editar un trabajo, y cómo eliminar un puesto de trabajo. Como se explicó durante el día 1, un proyecto symfony se hace de las aplicaciones. Cada aplicación se hace de **módulos**. Un módulo es un conjunto de código PHP auto-contenido que representa una característica de la aplicación
(el módulo API, por ejemplo), o un conjunto de manipulaciones que el usuario puede hacer sobre un modelo de objeto (un módulo job, por ejemplo).

Symfony es capaz de generar automáticamente un módulo para un determinado modelo que proporciona las características básicas de manipulación:

    $ php symfony propel:generate-module --with-show --non-verbose-templates frontend job JobeetJob

La tarea `propel:generate-module` genera módulo `job` en la 
aplicación `frontend` para el modelo `JobeetJob`. Como con la mayoría de las tareas symfony, algunos archivos y directorios se han creado para ti bajo la directorio `apps/frontend/modules/job`:

 | Directorio | Descripción
 | ---------- | --------------------
 | actions/   | El módulo de acciones
 | templates/ | El módulo de plantillas

El archivo `actions/actions.class.php` define todas las acciones disponibles para el módulo `job`:

 | Nombre de la acción  | Descripción
 | -------------------- | -------------------------------------------------------
 | index                | Muestra los registros de la tabla
 | show                 | Muestra los campos de un registro
 | new                  | Muestra una formulario para crear un nuevo registro
 | create               | Crea un nuevo registro
 | edit                 | Muestra un formulario para crear editar un registro existente
 | update               | Actualiza un registro con los valores que envió el usuario 
 | delete               | Borra un registro de la tabla

Ahora puedes probar el módulo job en un navegador:

     http://jobeet.localhost/frontend_dev.php/job

![Job module](http://www.symfony-project.org/images/jobeet/1_2/03/job.png)

Si intentas editar un trabajo, tendrás una excepción porque symfony necesita de un texto que represente una categoría. A objeto de PHP se representa definiendo el método mágico PHP `__toString()`. El texto de la representación de una categoría
debería definirse en la clase del modelo `JobeetCategory`:

    [php]
    // lib/model/JobeetCategory.php
    class JobeetCategory extends BaseJobeetCategory
    {
      public function __toString()
      {
        return $this->getName();
      }
    }

Ahora cada vez que symfony necesita un texto de representación de una categoría, llama al método `__toString()` que devuelve el nombre de la categoría. Como vamos a necesitar un texto de representación de todas las clases de modelo en un momento u otro, vamos a definir un método mágico `__toString()` para cada modelo:

    [php]
    // lib/model/JobeetJob.php
    class JobeetJob extends BaseJobeetJob
    {
      public function __toString()
      {
        return sprintf('%s at %s (%s)', $this->getPosition(), $this->getCompany(), $this->getLocation());
      }
    }

    // lib/model/JobeetAffiliate.php
    class JobeetAffiliate extends BaseJobeetAffiliate
    {
      public function __toString()
      {
        return $this->getUrl();
      }
    }

Ahora puedes editar y crear puestos de trabajo. Trata de saltear un campo requerido en blanco, o tratar de entrar en una fecha no válida. Así es, symfony ha creado básicas reglas de validación analizando el esquema de base de datos.

![validation](http://www.symfony-project.org/images/jobeet/1_2/03/validation.png)

Nos vemos mañana
----------------

Eso es todo por hoy. Te lo adverti en la introducción. Hoy, apenas hemos escrito el código PHP, pero tenemos un módulo web para el modelo job, listo para ser personalizado. Recuerda, sin código PHP también significa sin errores!

Si todavía te queda algo de energía, no dudes en leer el código generado para el módulo y el modelo y tratar de entender cómo funciona. Si no, no te preocupes y duerme bien, mañana, vamos a hablar de uno de los paradigmas más utilizados en los frameworks web, el
[patrón de diseño MVC](http://en.wikipedia.org/wiki/Model-view-controller).

El código escrito hoy está disponible en el repositorio de SVN Jobeet en la etiqueta
`release_day_03` (`http://svn.jobeet.org/tags/release_day_03/`).
