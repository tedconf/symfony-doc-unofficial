Día 5: El Enrutamiento
======================

Antes de empezar
----------------

Ayer, iniciamos el concurso de diseños Jobeet. Si quieres participar, hemos preparado un 
[archivo](http://www.symfony-project.org/images/jobeet/mockups.zip) con las principales páginas que vamos a desarrollar durante el tutorial (el archivo contiene los archivos HTML, las hojas de estilo, y las imágenes). El día 21 lo destinaremos a la votación, deberías enviarme (fabien.potencier [.at.]
symfony-project.org) los mockups con tu diseño antes de esa fecha. Buena suerte!

Anteriormente en Jobeet
-----------------------

Si has completado el día 4, ahora deberías estar familiarizado con el patrón MVC y 
deberías sentir mas y mas natural esta forma de codificación. Dedica un poco más de tiempo con esto para no tener que colver y mirar hacia atrás. Para practicar un poco el día de ayer, hemos personalizado la páginas Jobeet y en el proceso, también examinamos varios conceptos de symfony, como el layout, los helpers, y los slots.

Hoy nos sumergiremos en el maravilloso mundo del framework de Enrutamiento Symfony .

Las URLs
--------

Si haces clic en un puesto de trabajo en la página principal Jobeet, la URL se parece a esto:
`/job/show/id/1`. Si ya has desarrollado sitios web PHP, probablemente estes más acostumbrados a las URL como `/job.php?id=1`. ¿Cómo Symfony hace para que funcione? ¿Cómo Symfony determina la acción a llamar basabdose en esta URL?
¿Porqué el `id` de un job se obtiene con `$request->getParameter('id')`?
Hoy, vamos a responder a todas estas preguntas.

Pero primero, vamos a hablar acerca de las URL y exactamente que son ellas. En un contexto web, una URL es el identificador único de un recurso web. Cuando accedes a una URL, estas pidiendo al navegador obtener un recurso identificado por esa URL. So, como la dirección URL es la interfaz entre la página web y el usuario, debe transmitir información significativa sobre algun recurso al que hace referencia. Pero las "tradicionales" URLs realmente no describen al recurso, sino que exponen la estructura interna de la aplicación. Al usuario no le importa que tu sitio web sea desarrollado con el lenguaje PHP o que el puesto de trabajo tiene un cierto identificador en la base de datos.
Exponer el funcionamiento interno de tu aplicación es también es bastante malo en lo que medida de seguridad se refiere: ¿Qué pasa si el usuario intenta adivinar la dirección URL de los recursos que no tienen acceso? Así es, el desarrollador debe asegurarlos de la manera adecuada, pero más te vale ocultar la información sensible.

Las URL son tan importantes en symfony que tiene todo un framework dedicado a su gestión: el framework de **enrutamiento**. El enrutamiento gestiona URI interna y la URL externa. Cuando una petición llega el enrutamiento analiza la URL y la convierte en una URI interna.

Ya has visto la URI interna de la página de puestos de trabajo en la plantilla
`showSuccess.php`:

    'job/show?id='.$job->getId()

El helper `url_for()` convierte esta URI interna a una correcta URL:

    /job/show/id/1

La URI interna está hecha de varias partes: `job` es el módulo, `show` es la acción y la cadena de consulta añade los parámetros a pasar a la acción. El modelo genérico para las URIs internas es:

    MÓDULO/ACCIÓN?clave=valor&clave_1=valor_1&...
Como el enrutamiento de symfony es un proceso bidireccional, puedes cambiar las URLs sin cambiar la implementación técnica. Esta es una de las principales ventajas del patrón de diseño sobre controlador frontal.

La Configuración del Enrutamiento
---------------------------------

El mapeo entre las URIs internas y las URLs externas esta listo en el archivo de configuración `routing.yml`:

    [yml]
    # apps/frontend/config/routing.yml
    homepage:
      url:   /
      param: { module: default, action: index }

    default_index:
      url:   /:module
      param: { action: index }

    default:
      url:   /:module/:action/*

El archivo `routing.yml` describe las rutas. Una ruta tiene un nombre (`homepage`), un patrón (`/:module/:action/*`), y algunos parámetros (bajo la clave `param`).

Cuando una petición llega, el Enrutamiento trata de hacerla coincidir la URL con un patrón dado. La primera ruta que coincida gana, por lo tanto el orden en `routing.yml` es importante. Echemos un vistazo a algunos ejemplos para comprender mejor cómo funciona esto.

Cuando solicitas la página de inicio Jobeet, la cual tiene la URL `/job` URL, la primera ruta que coincide es con `default_index`. En un patrón, una palabra con un prefijo dos puntos (`:`) es una variable, por eso el patrón `/:module` significa: Concidir con un `/` seguida por cualquier cosa. En nuestro ejemplo, la variable `módulo` será `job` como su valor. Este valor puede ser obtenido con
`$request->getParameter('module')`. Esta ruta también define un valor por defecto para la variable `action`. Por eso, para todas las URLs que coincidan con esta route, la petición también tendrá un parámetro `action`  con `index` como su valor.

Si solicitas la página `/job/show/id/1`, symfony coincidirá con el último patrón:
`/:module/:action/*`. En un patrón, un asterisco (`*`) coincide con una colección de pares variable/valor separados por una barra (`/`):

  | Parámetro de petición | Valor |
  | -----------------     | ----- |
  | módulo                | job   |
  | acción                | show  |
  | id                    | 1     |

>**NOTA**
>Las variables `módulo` y `acción` son especiales ya que son utilizados por symfony 
>para determinar la acción a ejecutar.

La URL `/job/show/id/1` se pueden crear desde una plantilla utilizando la siguiente llamada al helper `url_for()`:

    [php]
    url_for('job/show?id='.$job->getId())

También puedes usar el nombre de la ruta gracias al prefijo `@`:

    [php]
    url_for('@default?id='.$job->getId())

Ambas llamadas son equivalentes, pero esta última es mucho más rápido ya que el enrutamiento no tiene que analizar todas las rutas para encontrar el mejor patrón coincidente, y es menos complicado su implementación (los nombres del módulo y la acción no están presentes en el URI interna).

Personalizaciones del Enrutamiento
----------------------------------

Por el momento, cuando la solicitas la URL `/` en un navegador, tienes por defecto la página de felicitaciones de symfony. Esto se debe a que esta URL coincide con la ruta `homepage`. Pero tiene sentido cambiarla para que sea la página de inicio de Jobeet. Para hacer el cambio, modifica la variable `module` de la ruta `homepage` a `job`:

    [php]
    # apps/frontend/config/routing.yml
    homepage:
      url:   /
      param: { module: job, action: index }

Puedes ahora cambiar el enlace al logo de Jobeet en el layout para usar la ruta
`homepage`:

    [php]
    <h1>
      <a href="<?php echo url_for('@homepage') ?>">
        <img src="/images/jobeet.gif" alt="Jobeet Job Board" />
      </a>
    </h1>

Eso fue fácil! Para algo un poco más aplicado, vamos a cambiar el la URL de la página job a algo más significativo:

    /job/sensio-labs/paris-france/1/web-developer

Sin saber nada acerca de Jobeet, y sin mirar en la página, se puede entender a partir de la URL que Sensio Labs está buscando un Web developer para trabajar en Paris, France.

>**NOTA**
>Las ricas URLs son importantes porque ellas transmiten información al usuario. Es
>también útil cuando copias y pegas la URL en un email o para optimizar
>tu sitio web para los motores de búsqueda.

El siguiente patrón coincide con esta URL:

    /job/:company/:location/:id/:position

Edita el archivo `routing.yml` y agrega la ruta `job` al principio del archivo:

    [yml]
    job:
      url:   /job/:company/:location/:id/:position
      param: { module: job, action: show }

Si actualizas la página de inicio Jobeet, los enlaces a jobs no han cambiado. Esto se debe a que para generar una ruta, necesitas pasar todas las variables requeridas. Por eso, necesitas cambiar la llamada a `url_for()` en `indexSuccess.php` a:

    [php]
    url_for('job/show?id='.$job->getId().'&company='.$job->getCompany().
      '&location='.$job->getLocation().'&position='.$job->getPosition())

Una URI interna también puede ser expresada como un array:

    [php]
    url_for(array(
      'module'   => 'job',
      'action'   => 'show',
      'id'       => $job->getId(),
      'company'  => $job->getCompany(),
      'location' => $job->getLocation(),
      'position' => $job->getPosition(),
    ))

Los Requisitos
--------------

Durante el primer día de tutoría, hemos hablado de la validación y manejo de errores por una buena razóns. El sistema de enrutamiento tiene incorporada una función de validación. Cada variable patrón pueda ser validada por una expresión regular definida utilizando la linea `requirements` en la definición de la ruta:

    [yml]
    job:
      url:   /job/:company/:location/:id/:position
      param: { module: job, action: show }
      requirements:
        id: \d+

La anterior linea `requirements` fuerza a que el `id` sea un valor numérico. Sino lo es, la ruta no coincide.

La Clase Route
--------------

Cada ruta se definida en `routing.yml` es internamente convertida en un objecto de la clase [`sfRoute`](http://www.symfony-project.org/api/1_2/sfRoute). Esta clase se puede cambiar mediante una linea `class` en la definición de la ruta. Si estás familiarizado con el protocolo HTTP, sabes que este define varios "métodos",
como `GET`, `POST`, `HEADER`, `DELETE`, y `PUT`. Los tres primeros cuentan con soporte en todos los navegadores, mientras que los otros dos no.

Para restringir una ruta a sólo la coincidencia con algunos métodos, puedes modificar la clase de enrutamiento a
[`sfRequestRoute`](http://www.symfony-project.org/api/1_2/sfRequestRoute) y añadir un requisito para la variable virtual `sf_method`:

    [yml]
    job:
      url:   /job/:company/:location/:id/:position
      class: sfRequestRoute
      param: { module: job, action: show }
      requirements:
        id: \d+
        sf_method: [GET]

>**NOTA**
>Exigir una ruta para solo algunos métodos HTTP es equivalente a usar
>`sfWebRequest::isMethod()` en tus actions.

Los Objectos de la Clase Route
------------------------------

La nueva URI interna para un puesteo de trabajo es bastante larga y tediosa de escribir, pero como recien hemos aprendido en la sección anterior, la clase route puede ser cambiada. Para la ruta `job`, es mejor utilizar
[`sfPropelRoute`](http://www.symfony-project.org/api/1_2/sfPropelRoute) ya que la clase está optimizada para las rutas que representan objetos Propel o colecciones de objetos Propel:

    [yml]
    job_show_user:
      url:     /job/:company/:location/:id/:position
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: show }
      requirements:
        id: \d+
        sf_method: [GET]

La linea `options` personaliza el comportamiento de la ruta. Aquí, la opción `model` define la clase del módelo Propel (`JobeetJob`) relacionada a la ruta, y la opción `type` define que esta ruta está vinculada a un objeto (también puedes utilizar `list` si una ruta representa una colección de objetos).

La ruta `job_show_user` es ahora consciente de su relación con `JobeetJob` y así podemos simplificar la llamada `url_for()` a:

    [php]
    url_for(array('sf_route' => 'job_show_user', 'sf_subject' => $job))

o:

    [php]
    url_for('job_show_user', $job)

>**NOTA**
>El primer ejemplo es mejor cuando necesitas pasar más argumentos que sólo
>el objeto.

Funciona porque todas las variables en la ruta tiene su método correspondiente en la clase `JobeetJob` (por ejemplo, la variable `company` es reemplazada con el valor de `getCompany()`).

Si hechas una mirada a las URL generadas, no son todavía bastantes como queremos que sean:

    http://jobeet.localhost/frontend_dev.php/job/Sensio+Labs/Paris%2C+France/1/Web+Developer

Tenemos que "slugify" los valores de columna mediante la sustitución de todos los caracteres no ASCII por un `-`. Abre el archivo `JobeetJob` y añadir el siguiente métodos para la clase:

    [php]
    // lib/model/JobeetJob.php
    public function getCompanySlug()
    {
      return Jobeet::slugify($this->getCompany());
    }

    public function getPositionSlug()
    {
      return Jobeet::slugify($this->getPosition());
    }

    public function getLocationSlug()
    {
      return Jobeet::slugify($this->getLocation());
    }

A continuación, crea el archivo `lib/Jobeet.class.php` y añadir el método `slugify` en él:

    [php]
    // lib/Jobeet.class.php
    class Jobeet
    {
      static public function slugify($text)
      {
        // replace all non letters or digits by -
        $text = preg_replace('/\W+/', '-', $text);

        // trim and lowercase
        $text = strtolower(trim($text, '-'));

        return $text;
      }
    }

Tenemos definidos tres nuevos métodos "virtuales" : `getCompanySlug()`,
`getPositionSlug()`, y `getLocationSlug()`. Ellos devuelven sus correspondiente valor de columna después de pasalos por el método `slugify()`. Ahora, puedes sustituir los nombres de las columas reales por sus virtuales en la ruta `job_show_user`:

    [yml]
    job_show_user:
      url:     /job/:company_slug/:location_slug/:id/:position_slug
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: show }
      requirements:
        id: \d+
        sf_method: [GET]

Antes de actualizar la página principal Jobeet, es necesario vaciar la caché, como hemos añadido una nueva clase (`Jobeet`):

    $ php symfony cc

Tendrás ahora las URLs esperadas:

    http://jobeet.localhost/frontend_dev.php/job/sensio-labs/paris-france/4/web-developer

Pero eso es sólo la mitad de la historia. La ruta es capaz de generar una URL sobre la base de un objeto, pero también es capaz de encontrar el objeto en relación con una determinada URL. Los objetos pueden ser recuperados con el método `getObject()` de la ruta. Al analizar una petición, el enrutamiento guarda la ruta del objeto coincidentes para que la uses en las acciones. Por lo tanto, puedes cambiar el método `executeShow()` para utilizar este método:

    [php]
    class jobActions extends sfActions
    {
      public function executeShow(sfWebRequest $request)
      {
        $this->job = $this->getRoute()->getObject();
        $this->forward404Unless($this->getRoute()->getObject());
      }

      // ...
    }

Si intentas obtener un job para un desconocido `id`, verás una página de error 404 pero el mensaje de error ha cambiado:

![404 with sfPropelRoute](http://www.symfony-project.org/images/jobeet/1_2/05/404_propel_route.png)

Esto es así porque el error 404 ha sido lanzado de forma automática por el método
`getRoute()`. Así, podemos simplificar el método `executeShow` aún más:

    [php]
    class jobActions extends sfActions
    {
      public function executeShow(sfWebRequest $request)
      {
        $this->job = $this->getRoute()->getObject();
      }

      // ...
    }

>**TIP**
>Si no deseas que la ruta genere un error 404, puede establecer la opción 
>`allow_empty` a `true`.

El Enrutamiento en Acciones y Plantillas
----------------------------------------

En una plantilla, el helper `url_for()` convierte una URI interna a una URL external. Algunos otros helpers symfony también toman una URI interna como un argumento, como el helper 
`link_to()` el cual genera una etiqueta `<a>`:

    [php]
    <?php echo link_to($job->getPosition(), 'job_show_user', $job) ?>

Genera el siguiente código HTML:

    [php]
    <a href="/job/sensio-labs/paris-france/1/web-developer">Web Developer</a>

Para ambos `url_for()` y `link_to()` también pueden generar URL absoluta:

    [php]
    url_for('job_show_user', $job, true);

    link_to($job->getPosition(), 'job_show_user', $job, true);

Si deseas generar una URL desde una acción, puedes usar el método `generateUrl()`:

    [php]
    $this->redirect($this->generateUrl('job_show_user', $job));

>**SIDEBAR**
>La Familia de Métodos "redirect"
>
>En el tutorial de ayer, hablamos acerca del método "forward". Estos métodos
>envían l apetición actual a otra acción sin regresar al navegador.
>
>El método "redirect" redirige al usuario a otra URL. Al igual que con forward,
>puedes utilizar el método `redirect()`, o los métodos `redirectIf()` y
>`redirectUnless()`.

La Clase de Colección de Rutas
------------------------------

Para el módulo `job`, ya tenemos personalizado la ruta de la acción `show`, pero
las URLs para los otros métodos (`index`, `new`, `edit`, `create`, `update`,
and `delete`) están aun gestionadas por la ruta `default`:

    [yml]
    default:
      url: /:module/:action/*

La ruta `default` es una gran manera de comenzar la codificación sin definir demasiadas rutas. Pero como la ruta actúa como un "catch-all", no puede ser configurada para necesidades específicas.

Como todas las acciones `job` están relacionadas con el modelo de la clase `JobeetJob`, podemos facilmente definir una ruta particular `sfPropelRoute` para cada uno de ellas como ya lo hemos hecho para la acción `show`. Sin embargo, como el módulo `job` define las clásicas siete posibles acciones para un modelo, también podemos utilizar la clase [`sfPropelRouteCollection`](http://www.symfony-project.org/api/1_2/sfPropelRouteCollection):

    [yml]
    // apps/frontend/config/routing.yml

    # put this definition just before the job_show_user one
    job:
      class:   sfPropelRouteCollection
      options: { model: JobeetJob }

La ruta `job` anterior es en realidad un acceso directo que generará automáticamente las siguientes siete rutas `sfPropelRoute`:

    [yml]
    job:
      url:     /job.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: list }
      param:   { module: job, action: index, sf_format: html }
      requirements: { sf_method: GET }

    job_new:
      url:     /job/new.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: new, sf_format: html }
      requirements: { sf_method: GET }

    job_create:
      url:     /job.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: create, sf_format: html }
      requirements: { sf_method: POST }

    job_edit:
      url:     /job/:id/edit.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: edit, sf_format: html }
      requirements: { sf_method: GET }

    job_update:
      url:     /job/:id.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: update, sf_format: html }
      requirements: { sf_method: PUT }

    job_delete:
      url:     /job/:id.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: delete, sf_format: html }
      requirements: { sf_method: DELETE }

    job_show:
      url:     /job/:id.:sf_format
      class:   sfPropelRoute
      options: { model: JobeetJob, type: object }
      param:   { module: job, action: show, sf_format: html }
      requirements: { sf_method: GET }

>**NOTA**
>Some routes generated by `sfPropelRouteCollection` have the same URL. The
>routing is still able to use them because they all have different HTTP method
>requirements.

Las rutas `job_delete` y `job_update` require métodos HTTP que no son compatibles con los navegadores (`DELETE` y `PUT` respectivamente). Esto funciona porque los simula symfony. Abre la plantilla `_form.php` Para ver un ejemplo:

    [php]
    // apps/frontend/modules/job/templates/_form.php
    <form action="..." ...>
    <?php if (!$form->getObject()->isNew()): ?>
      <input type="hidden" name="sf_method" value="PUT" />
    <?php endif; ?>

    <?php echo link_to(
      'Delete',
      'job/delete?id='.$form->getObject()->getId(),
      array('method' => 'delete', 'confirm' => 'Are you sure?')
    ) ?>

Todos los helpers symfony pueden ser invocados para simular cualquier método HTTP que desea pasando el parámetro especial `sf_method`.

>**NOTA**
>symfony tiene otros parámetros especiales como `sf_method`, todo lo que inicie con el prefijo
>`sf_`. En las rutas generadas antes, se puede ver otro:
>`sf_format`, que se explicará en los próximos días.

Debugeando la Ruta
------------------

Cuando se utiliza una colección de rutas, a veces es útil listar de rutas generadas. La tarea `app:routes` muestra todas las rutas para una aplicación determinada:

    $ php symfony app:routes frontend

También puedes tener una gran cantidad de información de depuración para una ruta pasando su nombre como un argumento adicional:

    $ php symfony app:routes frontend job_edit

Las Rutas por defecto
---------------------

Es una buena práctica definir las rutas para todas tus URL. Si lo haces, elimina o comenta las rutas por defecto del archivo de configuración `routing.yml`:

    [yml]
    // apps/frontend/config/routing.yml
    #default_index:
    #  url:   /:module
    #  param: { action: index }
    #
    #default:
    #  url:   /:module/:action/*

Nos vemos mañana
----------------

Hoy estuvo lleno de una gran cantidad información nueva. Ya has aprendido cómo utilizar el framework de Enrutamiento de Symfony y como desacoplar tus URLs desde la implmentación técnica.

Nosotros publicaremos un nuevo tutorial mañana, a pesar de que es sábado. No vamos a introducir nuevos conceptos, sino más bien gastando el tiempo profundizando lo que hemos cubierto hasta ahora.

El código fuente de Jobeet para el día de hoy está disponible en el repositorio de SVN:

    http://svn.jobeet.org/tags/release_day_05/

