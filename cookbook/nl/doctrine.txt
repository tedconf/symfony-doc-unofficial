Beginnen met Doctrine
=====================

Dus je wilt Doctrine een keer proberen met symfony 1.1? Eerst moeten we een nieuw symfony 1.1 project opzetten en de sfDoctrinePlugin voor 1.1 installeren. Voer de volgende commando's uit en lees verder:

    $ mkdir symfony1.1Doctrine
    $ cd symfony1.1Doctrine
    $ /path/to/symfony generate:project symfony1.1Doctrine
    $ svn co http://svn.symfony-project.com/plugins/sfDoctrinePlugin/trunk plugins/sfDoctrinePlugin
    $ php symfony cc

Typ nu het volgende commando in om een lijst te krijgen met alle commando's die `sfDoctrinePlugin` bied. Het zal je opvallen dat het alle commando's zijn die `sfPropelPlugin` ook bied, en meer!

    $ php symfony list doctrine
      Available tasks for the "doctrine" namespace:
      :build-all                   Generates Doctrine model, SQL and initializes the database (doctrine-build-all)
      :build-all-load              Generates Doctrine model, SQL, initializes database, and load data (doctrine-build-all-load)
      :build-all-reload            Generates Doctrine model, SQL, initializes database, and load data (doctrine-build-all-reload)
      :build-all-reload-test-all   Generates Doctrine model, SQL, initializes database, load data and run all test suites (doctrine-build-all-reload-test-all)
      :build-db                    Creates database for current model (doctrine-build-db)
      :build-forms                 Creates form classes for the current model (doctrine-build-forms)
      :build-model                 Creates classes for the current model (doctrine-build-model)
      :build-schema                Creates a schema.xml from an existing database (doctrine-build-schema)
      :build-sql                   Creates SQL for the current model (doctrine-build-sql)
      :data-dump                   Dumps data to the fixtures directory (doctrine-dump-data)
      :data-load                   Loads data from fixtures directory (doctrine-load-data)
      :dql                         Execute a DQL query and view the results (doctrine-dql)
      :drop-db                     Drops database for current model (doctrine-drop-db)
      :generate-crud               Generates a Doctrine CRUD module (doctrine-generate-crud)
      :generate-migration          Generate migration class (doctrine-generate-migration)
      :generate-migrations-db      Generate migration classes from existing database connections (doctrine-generate-migrations-db, doctrine-gen-migrations-from-db)
      :generate-migrations-models  Generate migration classes from an existing set of models (doctrine-generate-migrations-models, doctrine-gen-migrations-from-models)
      :init-admin                  Initializes a Doctrine admin module (doctrine-init-admin)
      :insert-sql                  Inserts SQL for current model (doctrine-insert-sql)
      :migrate                     Migrates database to current/specified version (doctrine-migrate)
      :rebuild-db                  Creates database for current model (doctrine-rebuild-db)

Allereerst moet er voor de `sfDoctrinePlugin` minimaal 1 applicatie opgezet zijn, dus laten we een `frontend` applicatie initialiseren.

    $ php symfony generate:app frontend

Laten we nu onze database configuratie opzetten in `config/databases.yml`. Open het bestand in je favoriete editor en plaats de YAML hieronder in het bestand. Voor deze test gebruiken we simpelwel een SQLite database. Doctrine kan een SQLite database voor je aanmaken op `config/doctrine.db`, en dat zullen we ook doen zodra we ons schema en wat fixtures hebben opgezet.

    [yml]
    all:
      doctrine:
        class:    sfDoctrineDatabase
        param:
          dsn:    sqlite:///<?php echo dirname(__FILE__); ?>/doctrine.db

Nu we de database hebben geconfigureerd, kunnen we onze YAML schema bestanden definieren in `config/doctrine/schema.yml`. In dit voorbeeld zetten we een simpel `BlogPost` model op die `HasMany` `Tags`.

    [yml]
	  ---
	  BlogPost:
	    actAs:
	      Sluggable:
	        fields: [title]
	      Timestampable:
	    columns:
	      title: string(255)
	      body: clob
	      author: string(255)
	    relations:
	      Tags:
	        class: Tag
	        refClass: BlogPostTag
	        foreignAlias: BlogPosts

	  BlogPostTag:
	    columns:
	      blog_post_id:
	        type: integer
	        primary: true
	      tag_id:
	        type: integer
	        primary: true

	  Tag:
	    actAs: [Timestampable]
	    columns:
	      name: string(255)
	 	
Nu we ons Doctrine schema hebben gedefinieerd, kunnen we wat test data fixtures maken in `data/fixtures/data.yml`. Open het bestand in je favoriete editor en plak onderstaande YAML in het bestand.

    [yml]
    ---
    BlogPost:
      BlogPost_1:
        title:  symfony + Doctrine
        body:   symfony and Doctrine are great!
        author: Jonathan H. Wage
        Tags:   [symfony, doctrine, php]
    
    Tag:
      symfony:
        name: symfony
      doctrine:
        name: doctrine
      php:
        name: php

OK, nu voor het leuke gedeelte. We hebben ons schema, en we hebben test gegevens, dus nu kunnen we een enkel Doctrine commando uitvoeren om de database aan te maken, de modellen te genereren, de tabellen aan te maken en de gegevens in te laden.

    $ php symfony doctrine-build-all-reload frontend
    >> doctrine  Are you sure you wish to drop your databases? (y/n)
    y
    >> doctrine  Successfully dropped database f...1.1Doctrine/config/doctrine.db"
    >> doctrine  Successfully created database f...1.1Doctrine/config/doctrine.db"
    >> doctrine  Generated models successfully
    >> doctrine  Created tables successfully
    >> doctrine  Data was successfully loaded

Nu is je `doctrine.db` SQLite database aangemaakt, alle tabellen uit je schema zijn gemaakt, en de data fixtures zijn in de tabellen geplaatst. Laten we nu wat spelen met de data om te zien hoe we de Doctrine Query Language kunnen gebruiken om data te verkrijgen.

    $ php symfony doctrine:dql frontend "FROM BlogPost p, p.Tags t"
    >> doctrine  executing: "FROM BlogPost p, p.Tags t" ()
    >> doctrine  - 
    >> doctrine    id: 1
    >> doctrine    title: symfony + Doctrine
    >> doctrine    body: symfony and Doctrine are great!
    >> doctrine    author: Jonathan H. Wage
    >> doctrine    slug: symfony-doctrine
    >> doctrine    created_at: 2008-06-16 12:28:57
    >> doctrine    updated_at: 2008-06-16 12:28:57
    >> doctrine    Tags: 
    >> doctrine      - 
    >> doctrine        id: 1
    >> doctrine        name: symfony
    >> doctrine        created_at: 2008-06-16 12:28:57
    >> doctrine        updated_at: 2008-06-16 12:28:57
    >> doctrine      - 
    >> doctrine        id: 2
    >> doctrine        name: doctrine
    >> doctrine        created_at: 2008-06-16 12:28:57
    >> doctrine        updated_at: 2008-06-16 12:28:57
    >> doctrine      - 
    >> doctrine        id: 3
    >> doctrine        name: php
    >> doctrine        created_at: 2008-06-16 12:28:57
    >> doctrine        updated_at: 2008-06-16 12:28:57

Laten we nu wat uitleggen over de data die werd teruggegeven. Zoals je kunt zien hebben de models een created_at, updated_at en slug kolom die niet in het schema bestand werden gedefinieerd. Deze kolommen zijn toegevoegd door de "behaviors" die in het schema aan de tabellen werden gekoppeld door de actAs instelling. De `created_at` en `updated_at` kolommen krijgen automatisch een waarde `onSet` en `onUpdate`, en de slug kolom is een url-vriendelijke string die is gemaakt van de waarde van de `name` kolom. Doctrine heeft een aantal "behaviors" die standaard worden meegeleverd, zoals `Sluggable` en `Timestampable`, maar het behavior-systeem is beouwd om iedereen toe te staan makkelijk behaviors voor hun modellen te schrijven en hergebruiken.

Nu dat we ons data model volledig hebben opgezet en test gegevens hebben ingeladen kunnen we een admin generator maken om de blog posts en tags te beheren.

    $ php symfony doctrine:init-admin frontend blog_posts BlogPost
    $ php symfony doctrine:init-admin frontend tags Tag

>**Let op**

>De admin generator templates voor `sfDoctrinePlugin` zijn nog niet volledig geupdate voor symfony 1.1 omdat ze nog steeds moeten werken met de `compat_10` optie die aangezet kan worden in `apps/frontend/config/settings.yml`. Ze zullen 100% worden geupdate voordat de officiele release van symfony 1.1 stabiel is.

Open nu je web browser en check je `frontend` applicatie in de `blog_posts` en `tags` modules. Het zou op de onderstaande URL beschikbaar moeten zijn:

    $ http://localhost/symfony1.1Doctrine/web/frontend_dev.php/blog_posts
    $ http://localhost/symfony1.1Doctrine/web/frontend_dev.php/tags

![blog posts](/uploads/assets/doctrine/blog_posts.gif)

Met een beetje configuratie van de blog post admin generator kan je nu beheren welke tags geassocieerd worden met welke blog posts door checkboxes aan te vinden bij het wijzigen van een blogpost. Open `apps/frontend/modules/blog_post/config/generator.yml` en vervang de inhoud met de volgende YAML.

    [yml]
    generator:
      class:              sfDoctrineAdminGenerator
      param:
        model_class:      BlogPost
        theme:            default
        list:
          display:        [=title, author]
          object_actions:
            _edit:        -
            _delete:      -
        edit:
          display:        [author, title, body, Tags]
          fields:
            author:
              type:       input_tag
            title:
              type:       input_tag
            body:
              type:       textarea_tag
              params:     size=50x10
            Tags:
              type:       doctrine_admin_check_list
              params:     through_class=BlogPostTag

Ververs nu de blog post list in je browser en je zal zien dat deze goed is opgeschoond. Wijzig een blog post door te klikken op het wijzig icoon of the titel en je zal zien  dat je de geassocieerde tags bij de blog post kan wijzigen zoals hieronder.

![edit blog posts](/uploads/assets/doctrine/edit_blog_post.gif)

Alle features die je in Propel hebt werken voor 99% hetzelfde in Doctrine, dus het zou redelijk makkelijk moeten zijn om dit aan te leren als je eerder met Propel gewerkt hebt. sfDoctrinePlugin implementeert alle functionaliteit hetzelfde als sfPropelPlugin, en daarnaast bied het nog een aantal features die in sfPropelPlugin niet aanwezig zijn. Hieronder vind je wat informatie over de belangrijkste features die Doctrine ondersteunt:

  * [Behaviors](http://www.phpdoctrine.org/documentation/manual/0_11?chapter=plugins) - Easily create reusable behaviors for your Doctrine models.
  * [Migrations](http://www.phpdoctrine.org/documentation/manual/0_11?chapter=migration) - Deploy database schema changes to your production environment through a programmatic interface.
  * [Doctrine Query Language](http://www.phpdoctrine.org/documentation/manual/0_11?chapter=dql-doctrine-query-language) - Build your database queries through a fluent OO interface
  * [Validators](http://www.phpdoctrine.org/documentation/manual/0_11?chapter=basic-schema-mapping#constraints-and-validators)  - Turn on column validators for both database and code level validation.
  * [Hierarchical Data](http://www.phpdoctrine.org/documentation/manual/0_11?chapter=hierarchical-data) - Turn your models in to nested sets easily with the flip of a switch.
  * [Caching](http://www.phpdoctrine.org/documentation/manual/0_11?chapter=caching) - Tune performance by caching your DQL query parsing and the result sets of queries.

Als deze korte tutorial je interesse in Doctrine heeft opgewekt, dan kan je op de onderstaande pagina's nog meer informatie vinden over Doctrine:

  * [Full User Manual](http://www.phpdoctrine.org/documentation/manual/0_11?one-page)
  * [API Documentation](http://www.phpdoctrine.org/documentation/api/0_11)
  * [Cheatsheet](http://www.phpdoctrine.org/Doctrine-Cheat-Sheet.pdf)
  * [Blog](http://www.phpdoctrine.org/blog)
  * [Community](http://www.phpdoctrine.org/community)
  * [Frequently Asked Questions](http://www.phpdoctrine.org/faq)
  * [Download](http://www.phpdoctrine.org/download)