How schrijf je een Propel schema met de alternatieve syntax
===========================================================

Overzicht
---------
Vanaf symfony 1.1 can je ervoor kiezen op de relationele structuur van je model te omschrijven in een nieuwe YAML syntax. Symfony herkent `schema.yml` bestanden die zijn geschreven in de syntax zoals omschreven in Hoofdstuk 8 van het symfony boek, of met de syntax zoals hieronder beschreven. De alternatieve syntax is meer object-georienteerd en maakt het proces van samenvoegen van meerdere schema's makkelijker om te begrijpen.

Basis voorbeeld
---------------

Neem het volgende voorbeeld in gedachten, met de huidige syntax:

    propel:
      _attributes:      { noXsd: false, defaultIdMethod: none, package: lib.model }
      ab_group:
        _attributes:    { phpName: Group, package: foo.bar.lib.model }
        id:
        name:           varchar(50)
    
      cd_user:
        _attributes:    { phpName: User, isI18N: true, i18nTable: cd_user_i18n }
        first_name:     { type: varchar, size: 255, default: "Anonymous" }
        last_name:      varchar(50)
        age:            { type: integer, required: true, index: true }
        ab_group_id:
        created_at:
  
      cd_user_i18n:
        description:    longvarchar
    
      ef_article:
        title:          { type: longvarchar, required: true, index: unique }
        stripped_title: { type: longvarchar, required: true, primaryKey: true, sequence: my_custom_sequence_name }
        user_id:
        my_group:       { type: integer, foreignTable: ab_group, foreignReference: id, onDelete: setnull }
        created_at:     timestamp
        updated_at:

      ij_article:
        _attributes:    { phpName: Article }
        title:          varchar(50)
        user_id:        { type: integer }
        _foreignKeys:
          -
            foreignTable: cd_user
            onDelete:     cascade
            references:
              - { local: user_id, foreign: id }
        created_at:
        _indexes:
          my_index:       [title, user_id]
        _uniques:
          my_other_index: [created_at]
        _behaviors:
          paranoid:     { column: deleted_at }
  
      ab_group_i18n:
        motto:            longvarchar

Alternatieve syntax
-------------------

### Basis voorbeeld, met de alternatieve syntax

Hier is een voorbeeld van hoe je dezelfde structuur als hierboven schrijft met de alternatieve syntax:

    connection:           propel
    noXsd:                false
    defaultIdMethod:      none
    package:              lib.model

    classes:
      Group:
        tableName:        ab_group
        package:          foo.bar.lib.model
        columns:
          id:
          name:           varchar(50)
  
      User:
        tableName:        cd_user
        isI18N:           true
        i18nTable:        cd_user_i18n
        columns:
          first_name:     { type: varchar, size: 255, default: "Anonymous" }
          last_name:      varchar(50)
          age:            { type: integer, required: true, index: true }
          ab_group_id:
          created_at:
  
      CdUserI18n:
        columns:
          description:    longvarchar
  
      EfArticle:
        columns:
          title:          { type: longvarchar, required: true, index: unique }
          stripped_title: { type: longvarchar, required: true, primaryKey: true, sequence: my_custom_sequence_name }
          user_id:
          my_group:       { type: integer, foreignClass: Group, foreignReference: id, onDelete: setnull }
          created_at:     timestamp
          updated_at:
  
      Article:
        tableName:        ij_article
        columns:
          title:          varchar(50)
          user_id:        { type: integer }
          created_at:
        foreignKeys:
          -
            foreignTable: cd_user
            onDelete:     cascade
            references:
              - { local: user_id, foreign: id }
        indexes:
          my_index:       [title, user_id]
        uniques:
          my_other_index: [created_at]
        behaviors:
          paranoid:     { column: deleted_at }
  
      AbGroupI18n:
        columns:
          motto:          longvarchar

Het belangrijkste verschil is dat je classes definieert, niet tabellen, met behulp van de `phpName` van een tabel als sleutel.

De alternatieve syntax is ook iets meer expliciet, omdat je entries voor `classes` en `columns` moet maken. Maar het zorgt er wel voor dat de lelijke `_attributes` hack verdwijnt die in de huidige syntax zit, zodat een `schema.yml` niet meer de XML syntax probeert na te doen.

Als laatste, alle 'magie' van de klassieke syntax bestaat nog steeds (automatische definitie van primary keys, foreign keys, i18n tabellen, etc.).

### Verbindingsinstellingen

De instellingen van de verbinding worden sleutels van het hoogste niveau in plaats van `_attributes` van de verbinding:

    connection:           propel
    noXsd:                false
    defaultIdMethod:      none
    package:              lib.model

Al deze sleutels zijn optioneel, inclusief de `connection`. Wanneer deze niet is gezet zal symfony de standaard `propel` gebruiken.

### Classes

Een class definitie geeft een overzicht van de tabelnaam in de database, de kolommen, foreign keys, indexes en behaviors in een natuurlijke key/value syntax:

    Article:
      tableName:        ij_article
      columns:
        title:          varchar(50)
        user_id:        { type: integer }
        created_at:
      foreignKeys:
        -
          foreignTable: cd_user
          onDelete:     cascade
          references:
            - { local: user_id, foreign: id }
      indexes:
        my_index:       [title, user_id]
      uniques:
        my_other_index: [created_at]
      behaviors:
        paranoid:     { column: deleted_at }

Let erop dat je foreign keys kan definieren zowel met het standaard `foreignTable` attribuut, die een tabelnaam verwacht, of met het nieuwe `foreignClass` attribuut, die een classnaam verwacht.

Gemengde schema's
-----------------

In een project kan je schemas hebben die de huidige en de alternatieve syntax door elkaar gebruiken. 

Het schema uitbreidingssysteem, zoals omschreven in Hoofdstuk 17 van het symfony book, werkt ongeacht de originele syntax of een eigen syntax wordt gebruikt. Dit betekent dat je een bestaand schema dat de klassieke syntax gebruikt kan aanpassen met de alternatieve syntax, en vice versa. Symfony zal intern een conversie uitvoeren zodat het altijd kan worden samengevoegd.

Let op dat het samenvoegen van een schema makkelijker te begrijpen is met de alternatieve syntax voor zowel het originele en het eigen schema. Sterker nog, dit is het interne formaat dat symfony gebruikt voor het samenvoegen. De volgende opsomming toont hoe de schema's worden samengevoegd:

    # Originele schema, in plugins/myPlugin/config/schema.yml
    classes:
      User:
        tableName:        cd_user
        columns:
          first_name:     { type: varchar, size: 255, default: "Anonymous" }
          last_name:      varchar(50)
          age:            { type: integer, required: true, index: true }
          created_at:
  
      Article:
        tableName:        ij_article
        columns:
          title:          varchar(50)
          user_id:        { type: integer }
          created_at:
        foreignKeys:
          -
            foreignTable: cd_user
            onDelete:     cascade
            references:
              - { local: user_id, foreign: id }

    # Eigen schema, in myPlugin_schema.custom.yml
    connection: myConnection
    classes:
      Group:
        tableName:        ab_group
        package:          foo.bar.lib.model
        behaviors:        [paranoid]
        columns:
          id:
          name:           varchar(50)

      User:
        tableName:        ef_user
        isI18N:           true
        i18nTable:        cd_user_i18n
        columns:
          ab_group_id:
  
      Article:
        columns:
          updated_at:

    # Uiteindelijke schema, intern samengevoegd en gebruikt voor model en sql generatie
    connection: myConnection
    classes:
      Group:
        tableName:        ab_group
        package:          foo.bar.lib.model
        behaviors:        [paranoid]
        columns:
          id:
          name:           varchar(50)
  
      User:
        tableName:        cd_user
        isI18N:           true
        i18nTable:        cd_user_i18n
        columns:
          first_name:     { type: varchar, size: 255, default: "Anonymous" }
          last_name:      varchar(50)
          age:            { type: integer, required: true, index: true }
          ab_group_id:
          created_at:
  
      Article:
        tableName:        ij_article
        columns:
          title:          varchar(50)
          user_id:        { type: integer }
          created_at:
          updated_at:
        foreignKeys:
          -
            foreignTable: cd_user
            onDelete:     cascade
            references:
              - { local: user_id, foreign: id }

Voor de duidelijkheid: Het wordt aangeraden zo veel mogelijk de alternatieve schema syntax te gebruiken.
