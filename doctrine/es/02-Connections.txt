Capítulo 2 - Conexiones
=======================

## Introducción

En este capítulo explicaremos algunas cosas acerca de las conexiones de Doctrine, como configurar multiples conexiones, bind models, and how to create and drop your databases and other connection related activities.

El `config/databases.yml` por defecto debería verse como lo siguiente.

    all:
      propel:
        class:      sfPropelDatabase
        param:
          dsn:      mysql:host=localhost;dbname=dbname
          username: user

La única diferencia entre Propel y Doctrine aquí es que la clase debe ser `sfDoctrineDatabase` en lugar de `sfPropelDatabase` y el nombre de la conexión es doctrine en lugar de propel. Ambos, Doctrine y Propel, usan PHP Data Objects (PDO) como capa de abstracción a la base de datos.

>**NOTE**
>Aunque Propel requiere al menos una conecxión nombrada `propel`, Doctrine no requiere que el nombre de la conexión sea `doctrine` por lo que puedes nombrarla como quieras.

Puedes configurar las conexiones en `config/databases.yml` con la tarea `configure:database` como sigue.

    $ ./symfony configure:database --name=doctrine --class=sfDoctrineDatabase "mysql:host=localhost;dbname=dbname" user secret

Ahora observarás una nueva conexión definida como sigue:

    doctrine:
      class: sfDoctrineDatabase
      param:
        dsn: 'mysql:host=localhost;dbname=dbname'
        username: user
        password: secret

>**NOTE**
>Necesitarás completamente quitar las referencias a propel en `config/databases.yml` si tienes deshabilitado sfPropelPlugin.

## Drivers Soportados

Doctrine soporta todos drivers con soporte PDO. PHP debe ser compilado con el driver PDO y todos los drivers PDO_* que desees usar. Debajo esta una lista de las bases de datos con la que funcionará PDO.

| Nombre            | Descripción                                          |
|-------------------|------------------------------------------------------|
| MS SQL Server     | Microsoft SQL Server and Sybase Functions (PDO_DBLIB)|
| Firebird/Interbase| Firebird/Interbase Functions (PDO_FIREBIRD)          |
| IBM               | IBM Functions (PDO_IBM)                              |
| Informix          | Informix Functions (PDO_INFORMIX)                    |
| MySQL             | MySQL Functions (PDO_MYSQL)                          |
| Oracle            | Oracle Functions (PDO_OCI)                           |
| ODBC and DB2      | ODBC and DB2 Functions (PDO_ODBC)                    |
| PostgreSQL        | PostgreSQL Functions (PDO_PGSQL)                     |
| SQLite            | SQLite Functions (PDO_SQLITE)                        |

>**NOTE**
>Puedes leer mas acerca de PDO en [http://www.php.net/pdo](http://www.php.net/pdo).

## Data Source Name(DSN)

Doctrine ofrece dos maneras de especificar tu información DSN. Puedes usar el estilo DSN de Doctrine o usar el estilo nativo de PDO.

### Estilo Doctrine

Doctrine tiene una sintaxis DSN la cual está basada en PEAR MDB2.

    all:
      doctrine:
        class:          sfDoctrineDatabase
        param:
          dsn:          driver://username:password@host/database_name

### Estilo PDO

Puedes alternativamente especificar tu info DSN en el estilo PDO.

    all:
      doctrine:
        class:          sfDoctrineDatabase
        param:
          dsn:          driver:dbname=database_name;host=localhost
          username:     username
          password:     password

>**TIP**
>Usando el estilo PDO ofrece mas flexibilidad y capacidad para especicar información no estandar acerca de tu conexión para PDO. Por ejemplo, cuando especificas paths unix_socket o puertos para usar cuando te conectas, especificandolo en la sintaxis PDO es más flexible. El comando `configure:database` también funciona con el estilo PDO.

## Importar desde la Base de Datos

Doctrine tiene la capacidad de generar un archivo esquema en `config/doctrine/schema.yml` de una base de datos existente. Solo configura tu conexión Doctrine para la base de datos que desees importar y ejecuta el siguiente comando.

>**NOTE**
>Esta es la manera correcta de convertir tu esquema Propel a Doctrine. Simplemente crea tu base de datos usando propel, y entonces genera el esquema en Doctrine desde tu base de datos creada.

    $ ./symfony doctrine:build-schema
    >> doctrine  generating yaml schema from database

Ahora tienes que mirar en `config/doctrine/schema.yml` y observarás en formato yaml la base de datos. En este ejemplo tenemos una tabla user.

    CREATE TABLE user (id BIGINT AUTO_INCREMENT, username VARCHAR(255), password VARCHAR(255), PRIMARY KEY(id)) ENGINE = INNODB;

La anterior tabla mysql debería generar un esquema yaml como el siguiente en `config/doctrine/schema.yml`

    [yml]
    User:
      tableName: user
      columns:
        id:
          type: integer(8)
          primary: true
          autoincrement: true
        username: string(255)
        password: string(255)

## Conexiones Multiples

Doctrine ofrece la capacidad de tener multiples conexiones. Fácilmente puedes asociar modelos a conexiones para que las consultas sean ejecutadas sobre la conexión apropiada. Entonces primero necesitamos agregar multiples conexiones con el comando `configure:database` como sigue.

    $ ./symfony configure:database --name=master --class=sfDoctrineDatabase "mysql:host=localhost;dbname=master" user secret
    $ ./symfony configure:database --name=client --class=sfDoctrineDatabase "mysql:host=localhost;dbname=client" user secret

Quita la conexión original que hemos creado y tu `config/databases.yml` se verá como sigue.

    all:
      master:
        class: sfDoctrineDatabase
        param:
          dsn: 'mysql:host=localhost;dbname=master'
          username: user
          password: secret
      client:
        class: sfDoctrineDatabase
        param:
          dsn: 'mysql:host=localhost;dbname=client'
          username: user
          password: secret

Ahora digamos que tenemos el modelo `Client` el cual queremos asociar a la base de datos master. Simplemente puedes hacer esto directamente en la definición del modelo como estpa debajo. Colóca el siquiete código YAML en `config/doctrine/schema.yml`

    Client:
      connection: master
      columns:
        name: string(255)
        username: string(255)
        password: string(255)

Ahora cada `Client` puede tener `Stores` pero ellos son guardados en una base de datos separada de la de `Clients`.

    Store:
      connection: client
      attributes:
        export: tables
      columns:
        name: string(255)
        description: string(500)
        client_id: integer
      relations:
        Client:
         foreignAlias: Stores

>**Note**
>Debido a que las tablas esta en base de datos separadas los datos solo pueden ser cargados de forma liviana. Doctrine actualmente no soporta sql para unir tablas entre bases de datos. 
Tambien, nota el atributo export para las tablas. Este le dice Doctrine que solo exporte la sentencia de creación de la tabla y no cualquier clave foranea.

## Atributo Conexión

sfDoctrinePlugin te permite especify conexión directamente en el archivo `config/databases.yml` como sigue.

      doctrine:
        class: sfDoctrineDatabase
        param:
          dsn: 'mysql:host=localhost;dbname=dbname'
          username: user
          password: secret
          attributes:
            use_dql_callbacks: true

Los atributos que establezcas aquí serán configurados en las instancias `Doctrine_Connection` cuando la conexión sea creada.

>**NOTE**
>Los atributos en Doctrine son para configurar y controlar características. Puedes leer mas acerca de los atributos en la [Documentación Doctrine](http://www.doctrine-project.com/documentation/manual/1_0?chapter=configuration).

## Contruir Todo

Ahora que tenemos nuestras conexiones y esquema definidos podemos construir todo con el siguiente comando.

    $ ./symfony doctrine:build-all-reload
                                                       
      This command will remove all data in your database.  
      Are you sure you want to proceed? (y/N)              
                                                       
    y
    >> doctrine  dropping databases
    >> doctrine  creating databases
    >> doctrine  generating model classes
    >> doctrine  generating sql for models
    >> doctrine  generating form classes
    >> doctrine  generating filter form classes
    >> doctrine  created tables successfully
    >> doctrine  loading data fixtures from "/Us...ymfony12doctrine/data/fixtures"

Ejecutando el anterior comando es equivalente a ejecutar los siguientes comandos separadamente.

    $ ./symfony doctrine:drop-db
                                                       
      This command will remove all data in your database.  
      Are you sure you want to proceed? (y/N)              
                                                       
    y
    >> doctrine  dropping databases
    $ ./symfony doctrine:build-db
    >> doctrine  creating databases
    $ ./symfony doctrine:build-model
    >> doctrine  generating model classes
    $ ./symfony doctrine:build-sql
    >> doctrine  generating sql for models
    $ ./symfony doctrine:build-form
    >> doctrine  generating form classes
    $ ./symfony doctrine:build-filters
    >> doctrine  generating filter form classes
    $ ./symfony doctrine:insert-sql
    >> doctrine  created tables successfully
    $ ./symfony doctrine:data-load
    >> doctrine  loading data fixtures from "/Us...ymfony12doctrine/data/fixtures"

>**Note**
>Observa los modelos generados desde tus archivos esquema YAML en lib/model/doctrine y lib/model/doctrine/base. Los archivos en el directorio generado son re-escritos cada vez que construyes tus modelos. Puedes personalizar tus modelos editando las clases en lib/model/doctrine.

Aquí esta lo que el `lib/model/doctrine/base/BaseClient.class.php` debería ser.

    [php]
    <?php
    // Connection Component Binding
    Doctrine_Manager::getInstance()->bindComponent('Client', 'master');

    /**
     * This class has been auto-generated by the Doctrine ORM Framework
     */
    abstract class BaseClient extends sfDoctrineRecord
    {
      public function setTableDefinition()
      {
        $this->setTableName('client');
        $this->hasColumn('name', 'string', 255, array('type' => 'string', 'length' => '255'));
        $this->hasColumn('username', 'string', 255, array('type' => 'string', 'length' => '255'));
        $this->hasColumn('password', 'string', 255, array('type' => 'string', 'length' => '255'));
      }

      public function setUp()
      {
        $this->hasMany('Store as Stores', array('local' => 'id',
                                                'foreign' => 'client_id'));
      }
    }

>**TIP**
>Esta es una práctica común para ejecutar el comando `./symfony doctrine:build-all-reload-test-all` cuando desarrollas. Esto re-construye todo tu ambiente y ejecuta toda la suite de pruebas. Este es un buen comando para ejecutar antes de enviar los cambios del nuevo código para asegurarse que ninguna regresión ha ocurrido.

-

>**TIP**
>Puedes leer más acerca de conexiones en el Manual Doctrine [aquí](http://www.doctrine-project.org/documentation/manual/1_0/en/connection-management).