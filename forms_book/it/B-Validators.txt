Validatori
==========

Introduzione
------------

Il form framework di symfony viene rilasciato con un gran
numero di validatori utili. Questi validatori coprono le
maggior parte delle necessità di molti progetti. Questo capitolo
descrive i validatori standard distribuiti con symfony.
Abbiamo anche incluso i validatori dai plugin `sfPropelPlugin`
e `sfDoctrinePlugin`, in quanto questi plugin sono supportati
dal team ufficiale e contengono alcuni validatori molto utili.

>**TIP**
>Anche se non usate il framework MVC di symfony, potete usare
>i validatori definiti nei plugin 
>[`sfFormExtraPlugin`](http://svn.symfony-project.com/plugins/sfFormExtraPlugin),
>`sfPropelPlugin` e `sfDoctrinePlugin` inserendo le carelle
>`validator/` nel vostro progetto.

Prima di approfondire ogni validatore in dettaglio, vediamo cosa
hanno tutti i validatori in comune.

### La classe `sfValidatorBase`

Tutti i validatori di symfony ereditano dalla classe base `sfValidator`,
che mette a disposizione alcune funzionalità standard.

I validatori hanno due scopi: pulire e validare un valore grezzo.

Quando create un validatore, potete opzionalmente passare opzioni e
messaggi di errore come argomenti:

    [php]
    $v = new sfValidatorString(
      array('required' => true),
      array('required' => 'Questo valore è necessario.')
    );

Opzioni e messaggi di errore possono essere anche settati usando i
metodi `setOptions()` e `setMessages()`:

    [php]
    $v = new sfValidatorString();
    $v->setOptions(array('required' => true));
    $v->setMessages(array('required' => 'Questo valore è necessario.'));

I metodi `setOption()` e `setMessage()` permettono di settare una
singola opzione o un singolo messaggio di errore:

    [php]
    $v = new sfValidatorString();
    $v->setOption('required', true);
    $v->setMessage('required', 'Questo valore è necessario.');

Un valore grezzo può essere validato invocando il metodo `clean()`:

    [php]
    $cleaned = $v->clean('name', 'value', array('class' => 'foo'));

Il metodo `clean()` accetta i valori grezzi come argomenti e restituisce
i valori ripuliti. Se avviene un errore di validazione, è restituito un
errore di tipo `sfValidatorError`.

>**NOTA**
>I validatori sono stateless, il che significa che una singola istanza
>di un validatore può controllare tutti i valori di input che volete.

Le opzioni definite di default da `sfValidatorBase` sono le seguenti:

| Opzione       | Errore     | Descrizione
| ------------- | ---------- | -----------
| `required`    | `required` | `true` se il valore è obbligatorio, `false` altrimenti (`true` di default)
| `trim`        | n/a        | `true` se il valore deve essere trimmed, `false` altrimenti (`false` di default)
| `empty_value` | n/a        | restituisce una stringa vuota e i valore non è richiesto

I messaggi di errore di default definiti da `sfValidatorBase` sono i seguenti:

| Errore     | Descrizione
| ---------- | -----------
| `required` | Il messaggio di errore usato quando il valore grezzo è vuoto e richiesto (`Required.` di default).
| `invalid`  | Un messaggio di errore generico restituito quando un errore viene riconosciuto (`Invalid.` di default).

Potete cambiare le stringhe di default sate per gli errori di `required`
e `invalid` invocando rispettivamente i metodi `setRequiredMessage()` e
`setInvalidMessage()`:

    [php]
    sfValidatorBase::setRequiredMessage('Questo valore è necessario.');
    sfValidatorBase::setInvalidMessage('Questo valore non è valido.');

I messaggi di errore possono contenere dei segnaposto. Questi sono
delle stringhe di testo racchiuse tra il carattere `%`. 
I segnaposto sono sostituiti a runtime. Tutti i messaggi di errore
hanno accesso alle variabili grezze usando il segnaposto `%value%`. 
Ogni messaggio di errore può, inoltre, definire un segnaposto specifico.

>**NOTA**
>Nella seguente sezione, il segnaposto predefinito `%value%` non
>è menzionato in quanto è sempre disponibile.

Per validatori è necessario sapere qual'è il charset utilizzato dai
valori grezzi. Normalmente il charset usato è `UTF-8`, ma può essere
sostituito usando il metodo `setCharset()`:

    [php]
    sfValidatorBase::setCharset('ISO-8859-1');

>**NOTA**
>Se state usando i validatori all'interno del framework MVC di symfony,
>il charset è configurato automaticamente con quello definito nel file
>`settings.yml`.

### Validator Schema

Un validator schema è un contenitore di validatori che può ospitare
uno o più validatori differenti.

Quando viene intercettato un errore, il validator schema restituisce
un'eccezione `sfValidatorErrorSchema`.


Nelle prossime sezioni i validatori saranno raggruppati in categorie.

<div class="pagebreak"></div>

Validatori
----------

 * [`sfValidatorString`](#chapter_b_sub_sfvalidatorstring)
 * [`sfValidatorRegex`](#chapter_b_sub_sfvalidatorregex)
 * [`sfValidatorEmail`](#chapter_b_sub_sfvalidatoremail)
 * [`sfValidatorUrl`](#chapter_b_sub_sfvalidatorurl)
 * [`sfValidatorInteger`](#chapter_b_sub_sfvalidatorinteger)
 * [`sfValidatorNumber`](#chapter_b_sub_sfvalidatornumber)
 * [`sfValidatorBoolean`](#chapter_b_sub_sfvalidatorboolean)
 * [`sfValidatorChoice`](#chapter_b_sub_sfvalidatorchoice)
 * [`sfValidatorPass`](#chapter_b_sub_sfvalidatorpass)
 * [`sfValidatorCallback`](#chapter_b_sub_sfvalidatorcallback)
 * [`sfValidatorDate`](#chapter_b_sub_sfvalidatordate)
 * [`sfValidatorTime`](#chapter_b_sub_sfvalidatortime)
 * [`sfValidatorDateTime`](#chapter_b_sub_sfvalidatordatetime)
 * [`sfValidatorDateRange`](#chapter_b_sub_sfvalidatordaterange)
 * [`sfValidatorFile`](#chapter_b_sub_sfvalidatorfile)
 * [`sfValidatorAnd`](#chapter_b_sub_sfvalidatorand)
 * [`sfValidatorOr`](#chapter_b_sub_sfvalidatoror)
 * [`sfValidatorSchema`](#chapter_b_sub_sfvalidatorschema)
 * [`sfValidatorSchemaCompare`](#chapter_b_sub_sfvalidatorschemacompare)
 * [`sfValidatorSchemaFilter`](#chapter_b_sub_sfvalidatorschemafilter)
 * [`sfValidatorI18nChoiceCountry`](#chapter_b_sub_sfvalidatori18nchoicecountry)
 * [`sfValidatorI18nChoiceLanguage`](#chapter_b_sub_sfvalidatori18nchoicelanguage)
 * [`sfValidatorPropelChoice`](#chapter_b_sub_sfvalidatorpropelchoice)
 * [`sfValidatorPropelChoiceMany`](#chapter_b_sub_sfvalidatorpropelchoicemany)
 * [`sfValidatorPropelUnique`](#chapter_b_sub_sfvalidatorpropelunique)
 * [`sfValidatorDoctrineChoice`](#chapter_b_sub_sfvalidatordoctrinechoice)
 * [`sfValidatorDoctrineChoiceMany`](#chapter_b_sub_sfvalidatordoctrinechoicemany)
 * [`sfValidatorDoctrineUnique`](#chapter_b_sub_sfvalidatordoctrineunique)

<div class="pagebreak"></div>

Validatori semplici
-----------------

### `sfValidatorString`

*Schema validator*: No

Il validatore `sfValidatorString` controlla una variabile grezza affinché
sia una stringa e la restituisce come tale.

| Opzione      | Errore       | Descrizione
| ------------ | ------------ | -----------
| `max_length` | `max_length` | La lunghezza massima della stringa
| `min_length` | `min_length` | La lunghezza minima della stringa

| Errore       | Segnaposti   | Valori predefiniti
| ------------ | ------------ | ------------------
| `max_length` | `max_length` | "%value%" is too long (%max_length% characters max).
| `min_length` | `min_length` | "%value%" is too short (%min_length% characters min).

>**ATTENZIONE**
>Questo validatore necessita che l'estensione di PHP `mb_string` sia
>installata per poter funzionare correttamente. Se installata, la
>lunghezza della stringa verrà calcolata usando la funzione
>`mb_strlen()`; altrimenti verrà utilizzata la funzione `strlen()`,
>che non restituisce la reale lunghezza se all'interno della stringa
>sono presenti caratteri non-ASCII.

### `sfValidatorRegex`

*Schema validator*: No

Il validatore `sfValidatorRegex` controlla che una stringa verifichi
una certa espressione regolare.

| Opzione   | Errore    | Descrizione
| --------- | --------- | -----------
| `pattern` | `invalid` | Un pattern di espressione regolare PCRE

### `sfValidatorEmail`

*Schema validator*: No

Il validatore `sfValidatorEmail` può controllare gli indirizzi email
ed eredita da `sfValidatorRegex`.

### `sfValidatorUrl`

*Schema validator*: No

Il validatore `sfValidatorEmail` può validare indirizzi, URL HTTP
ed URL FTP. Eredita da `sfValidatorRegex`.

### `sfValidatorInteger`

*Schema validator*: No

Il validatore `sfValidatorInteger` controlla che il valore immesso
sia di tipo integer e lo converte come tale.

| Opzione | Errore | Descrizione
| ------  | ------ | -----------
| `max`   | `max`  | Il massimo numero da accettabile
| `min`   | `min`  | Il minimo numero accettabile

| Errore | Segnaposti | Valori predefiniti
| ------ | ---------- | -------------
| `max`  | `max`      | "%value%" must be less than %max%.
| `min`  | `min`      | "%value%" must be greater than %min%.

Il messaggio di errore predefinito per `invalid` è `"%value%" is
not an integer.`.

### `sfValidatorNumber`

*Schema validator*: No

Il validatore `sfValidatorNumber` controlla un numero (o una stringa
che PHP possa tradurre tramite la funzione [`floatval()`](www.php.net/floatval))
e lo converte in un tipo float.

| Opzione | Errore | Descrizione
| ------- | ------ | -----------
| `max`   | `max`  | Il massimo numero da accettabile
| `min`   | `min`  | Il minimo numero accettabile

| Errore | Segnaposti | Valori predefiniti
| ----- | ----------- | -------------
| `max` | `max`       | "%value%" must be less than %max%.
| `min` | `min`       | "%value%" must be greater than %min%.

Il messaggio di errore predefinito per `invalid` è `"%value%" is not a number.`.

### `sfValidatorBoolean`

*Schema validator*: No

Il validatore `sfValidatorBoolean` controlla che il dato inserito sia
di tipo Boolean e restituisce i valori `true` o `false`.

| Opzione        | Errore | Descrizione
| -------------  | ------ | -----------
| `true_values`  | n/a    | La lista dei valori considerati veri (di default: `true`, `t`, `yes`, `y`, `on`, `1`)
| `false_values` | n/a    | La lista dei valori considerati falsi (di default: `false`, `f`, `no`, `n`, `off`, `0`)

### `sfValidatorChoice`

*Schema validator*: No

Il validatore `sfValidatorChoice` controlla se i valori inseriti
appartengono ad una lista di valori definiti.

| Opzione     | Errore | Descrizione
| ----------  | ------ | -----------
| `choices`   | n/a    | L'array dei valori definiti (required)
| `multiple`  | n/a    | `true` se il tag select deve permettere la spunta di valori diversi contemporaneamente

>**NOTA**
>Il confronto è fatto dopo che i valori grezzi sono stati trasformati
>in stringhe.

### `sfValidatorPass`

*Schema validator*: No

Il validatore `sfValidatorPass` è un validatore fittizio che restituisce
i valori di input così come sono.

### `sfValidatorCallback`

*Schema validator*: No

Il validatore `sfValidatorCallback` delega il controllo usando un callback
di PHP.

Al callback sono passati come argomenti l'istanza del validatore, i valori
grezzi e un array di argomenti (dall'opzione `arguments`):

    [php]
    function constant_validator_callback($validator, $value, $arguments)
    {
      if ($value != $arguments['constant'])
      {
        throw new sfValidatorError($validator, 'invalid');
      }

      return $value;
    }

    $v = new sfValidatorCallback(array(
      'callback'  => 'constant_validator_callback',
      'arguments' => array('constant' => 'foo'),
    ));

| Opzione     | Errore | Descrizione
| ----------- | ------ | -----------
| `callback`  | n/a    | Un callback valido di PHP callback (obbligatorio)
| `arguments` | n/a    | Un array di argomenti da passare al callback

Validatori di date
------------------

### `sfValidatorDate`

*Schema validator*: No

Il validatore `sfValidatorDate` controlla date semplici e con orari (le
date con orari sono abilitate con l'opzione `with_time`). 
Oltre che controllare la validità del formato della data può forzare un
intervallo di date su cui controllare.

Il validatore accetta diversi tipi di parametri:

 * un array composto dalle seguenti chiavi: `year`, `month`, `day`, `hour`,
   `minute` e `second`
 * una stringa che combacia con l'estpressione regolare `date_format`, se passata
 * una stringa che può essere utilizzata dalla funzione `strtotime()` di PHP
 * un intero che rappresenta un timestamp

I valori grezzi sono convertiti in una data utilizzando il formato
specificato nei parametri `date_output` o `datetime_output`.

| Opzione                   | Errore       | Descrizione
| ------------------------- | ------------ | -----------
| `date_format`             | `bad_format` | Un'espressione regolare con cui le date inserite devono combaciare
| `with_time`               | n/a          | `true` se il validatore deve restituire un orario, altrimenti `false`
| `date_output`             | n/a          | Il formato da usare quando l'output deve essere una data (il valore predefinito è `Y-m-d`)
| `datetime_output`         | n/a          | Il formato da usare quando l'output deve essere una data con orario (il valore predefinito è `Y-m-d H:i:s`)
| `date_format_error`       | n/a          | Il formato data da utilizzare quando viene mostrato il messaggio d'errore `bad_format` (usa `date_format` se non specificato)
| `max`                     | `max`        | La massima data permessa (come timestamp)
| `min`                     | `min`        | La minima data permessa (come timestamp)
| `date_format_range_error` | n/a          | Il formato data da utilizzare quando viene mostrato il messaggio d'errore per min/max (il valore predefinito è `d/m/Y H:i:s`)

>**NOTA**
>Le opzioni di `date_output` e `datetime_output` possono usare qualsiasi
>formato riconosciuto dalla funzione `date()` di PHP.

| Errore       | Segnaposti    | Valori predefiniti
| ------------ | ------------- | -------------
| `bad_format` | `date_format` | "%value%" does not match the date format (%date_format%).
| `min`        | `min`         | The date must be after %min%.
| `max`        | `max`         | The date must be before %max%.

### `sfValidatorTime`

*Schema validator*: No

Il validatore `sfValidatorTime` controlla i formati orario.

Il validatore accetta diverse tipologie di input:

 * un array composto dalle seguenti chiavi: `hour`, `minute` e `second`
 * una stringa che combacia con l'estpressione regolare `time_format`, se passata
 * una stringa che può essere utilizzata dalla funzione `strtotime()` di PHP
 * un intero che rappresenta un timestamp

I valori grezzi sono convertiti in una data utilizzando il formato specificato
nei parametri `date_output` o `datetime_output`.

| Opzione             | Errore       | Descrizione
| ------------------- | ------------ | -----------
| `time_format`       | `bad_format` | Un'espressione regolare con cui le date inserite devono combaciare
| `time_output`       | n/a          | Il formato da usare quando l'output deve essere una data (il valore predefinito è `Y-m-d`)
| `time_format_error` | n/a          | Il formato data da utilizzare quando viene mostrato il messaggio d'errore `bad_format` (usa `date_format` se non specificato)

>**NOTA**
>Le opzioni di `time_output` può usare qualsiasi
>formato riconosciuto dalla funzione `date()` di PHP.

| Errore       | Segnaposti    | Valori predefiniti
| ------------ | ------------- | -------------
| `bad_format` | `date_format` | "%value%" does not match the time format (%time_format%).

### `sfValidatorDateTime`

*Schema validator*: No

Il validatore `sfValidatorDateTime` controlla le date con gli orari.

E' una scorciatoia per:

    [php]
    $v = new sfValidatorDate(array('with_time' => true));

### `sfValidatorDateRange`

*Schema validator*: No

Il validatore `sfValidatorDateTime` controlla intervalli di date.

| Opzione     | Errore    | Descrizione
| ----------- | --------- | -----------
| `from_date` | `invalid` | Il validatore dalla data (obbligatorio)
| `to_date`   | `invalid` | Il validatore alla data (obbligatorio)

I validatori `from_date` e `to_date` devono essere istanze della classe
`sfValidatorDate`.

Il messaggio di errore `invalid` è `"%value%" does not match the time format
(%time_format%).`.

Validatore di file
------------------

### `sfValidatorFile`

*Schema validator*: No

Il validatore `sfValidatorFile` controlla i file caricati.

Il validatore converte i file caricati in un'istanza della classe
`sfValidatedFile`, o dell'opzione `validated_file_class` se è impostata.

| Opzione                | Errore       | Descrizione
| ---------------------- | ------------ | -----------
| `max_size`             | `max_size`   | La dimensione massima del file
| `mime_types`           | `mime_types` | Array di mime types permessi o categoria (categorie disponibili: `web_images`)
| `mime_type_guessers`   | n/a          | Un array di mime type guesser PHP callables (deve restituire un mime type o `null`)
| `mime_categories`      | n/a          | Un array di categorie mime type (`web_images` è definita di default)
| `path`                 | n/a          | Il path dove salvere il file - come utilizzato dalla classe `sfValidatedFile` (opzionale)
| `validated_file_class` | n/a          | Nome della classe che gestisce il file caricato (opzionale)

La categoria mime-type `web_images`  contiene i seguenti mime-types:

 * `image/jpeg`
 * `image/pjpeg`
 * `image/png`
 * `image/x-png`
 * `image/gif`

Se l'opzione `mime_types` è impostata, il validatore ha bisogno di un sistema per testare il
mime-type del file caricato. Il validatore offre tre modi per fare questo:

 * `guessFromFileinfo`:        Usa la funzione `finfo_open()` (dall'estansione PECL `Fileinfo`)
 * `guessFromMimeContentType`: Usa la funzione `mime_content_type()` (deprecata)
 * `guessFromFileBinary`:      Usa il file binary (funziona solo sui sitemi *nix)

| Errore       | Segnaposti                    | Valori predefiniti
| ------------ | ----------------------------- | -------------
| `max_size`   | `%size%`, `%max_size%`        | Il file è troppo grande (il massimo è %max_size% bytes).
| `mime_types` | `%mime_types%`, `%mime_type%` | Mime type non valido (%mime_type%).
| `partial`    |                               | Il file è stato caricato solo parzialmente.
| `no_tmp_dir` |                               | Manca una directory temporanea.
| `cant_write` |                               | Errore nella scrittura su disco.
| `extension`  |                               | Caricamento del file interrotto dall'estensione.

Il validatore mappa gli errori PHP nel modo seguente:

  * `UPLOAD_ERR_INI_SIZE`:   `max_size`
  * `UPLOAD_ERR_FORM_SIZE`:  `max_size`
  * `UPLOAD_ERR_PARTIAL`:    `partial`
  * `UPLOAD_ERR_NO_TMP_DIR`: `no_tmp_dir`
  * `UPLOAD_ERR_CANT_WRITE`: `cant_write`
  * `UPLOAD_ERR_EXTENSION`:  `extension`

Validatori logici
------------------

### `sfValidatorAnd`

*Schema validator*: No

Il validatore `sfValidatorAnd` controlla un valore gresso se passa una lista di validatori.

Il costruttore di `sfValidatorAnd` accetta una lista di validatori come prima argomento:

    [php]
    $v = new sfValidatorAnd(
      array(
        new sfValidatorString(array('max' => 255)),
        new sfValidatorEmail(),
      ),
      array('halt_on_error' => true),
      array('invalid' => 'The input value must be an email with less than 255 characters.')
    );

Di default, il validatore lancia un array di messaggi d'errore lanciati da tutti
i validatori inclusi. Può inoltre lanciare un singolo messaggio d'errore se il messaggio
d'errore `invalid` è impostato ad una stringa non vuota, come mostrato nell'esempio
precedente.

| Opzione         | Errore | Descrizione
| --------------- | ------ | -----------
| `halt_on_error` | `n/a`  | Indica se fermarsi al primo errore o meno (`false` di default)

L'ordine dei validatori è importante se l'opzione `halt_on_error` è impostata a 
`true`.

La lista di validatori inclusi può essere inoltre gestita usando i metodi
`getValidators()` e `addValidator()`.

### `sfValidatorOr`

*Schema validator*: No

Il validatore `sfValidatorOr` controlla un valore grezzo se passa almeno un validatore
in una lista.

Il costruttore `sfValidatorOr` accetta una lista di validatori come primo argomento:

    [php]
    $v = new sfValidatorOr(
      array(
        new sfValidatorRegex(array('pattern' => '/\.com$/')),
        new sfValidatorEmail(),
      ),
      array(),
      array('invalid' => 'The input value a .com domain or a valid email address.')
    );

Di default il validatore lancia un array di messaggi d'errore lanciati da tutti i
validatori inclusi. Può inoltre lanciare un singolo messaggio d'errore se il messaggio
d'errore `invalid` è impostato ad una stringa non vuota, come mostrato nell'esempio
precedente.

La lista di validatori inclusi può essere inoltre gestita usando i metodi
`getValidators()` e `addValidator()`.

### `sfValidatorSchema`

*Schema validator*: Yes

Il validatore `sfValidatorSchema` rappresenta un validatore composto da diversi campi.
Un campo è semplicemente un validatore a cui è assegnato un come:

    [php]
    $v = new sfValidatorSchema(array(
      'name'    => new sfValidatorString(),
      'country' => new sfValidatorI18nChoiceCountry(),
    ));

>**NOTE**
>Una form è definita dallo schema del validatore della classe `sfValidatorSchema`.

Questo validatore accetta solamente un array come valore di input e lancia una 
`InvalidArgumentException` se questo non si verifica.

Il validatore può avere un pre-validatore, che viene eseguito prima di tutti gli 
altri validatori, e un post-validatore, che viene eseguito sui valori puliti dopo 
tutti gli altri validatori.

I validatori pre-validatore e post-validatore sono validatori schema a loro volta
che ricevono tutti i valori. Essi possono essere impostati con i metodi 
`setPreValidator()` e `setPostValidator()`:

    [php]
    $v->setPostValidator(
      new sfValidatorCompare('password', '==', 'password_again')
    );

| Opzione               | Errore         | Descrizione
| --------------------- | -------------- | -----------
| `allow_extra_fields`  | `extra_fields` | se `false`, il validatore aggiunge un errore se campi extra vengono inseriti nell'array dei valori di input (default impostato a `false`)
| `filter_extra_fields` | n/a            | se `true`, il validatore filtra i campi extra dall'array resituito con i valori puliti (default impostato a `true`)

| Errore         | Segnaposti   | Valori predefiniti
| -------------- | ------------ | -------------
| `extra_fields` | `%field%`    | Campo extra inaspettato di nome "%field%".

Il `sfValidatorSchema` può essere usato come un array per accedere ai validatori
inclusi:

    [php]
    $vs = new sfValidatorSchema(array('name' => new sfValidatorString()));

    $nameValidator = $vs['name'];

    unset($vs['name']);

Si può accedere allo schema dei validatori contenuti usanto la notazione degli 
array:

    [php]
    $vs['author']['first_name']->setMessage('invalid', 'The first name is invalid.');

### `sfValidatorSchemaCompare`

*Schema validator*: Yes

Il validatore `sfValidatorSchemaCompare` compara diversi valori dell'array di dati grezzi
passato:

    [php]
    $v = new sfValidatorCompare('password', '==', 'password_again');

| Opzione              | Errore | Descrizione
| -------------------- | ------ | -----------
| `left_field`         | n/a    | Il nome del campo a sinistra
| `operator`           | n/a    | L'operatore di comparazione
| `right_field`        | n/a    | Il nome del campo a destra
| `throw_global_error` | n/a    | Se lanciare un errore globale (`false` di default) o un errore legao al campo a sinistra

**DA COMPLETARE**

The available operators are the followings:

 * `sfValidatorSchemaCompare::EQUAL` or `==`
 * `sfValidatorSchemaCompare::NOT_EQUAL` or `!=`
 * `sfValidatorSchemaCompare::LESS_THAN` or `<`
 * `sfValidatorSchemaCompare::LESS_THAN_EQUAL` or `<=`
 * `sfValidatorSchemaCompare::GREATER_THAN` or `>`
 * `sfValidatorSchemaCompare::GREATER_THAN_EQUAL` or `>=`

By default, the validator throws a global error. If the `throw_global_error`
is set to `true`, an error for the left field is thrown.

The `invalid` error messages accepts the following values: `%left_field%`,
`right_field`, and `operator`.

### `sfValidatorSchemaFilter`

*Schema validator*: Yes

The `sfValidatorSchemaFilter` validator convert a non-schema validator to a
schema validator. It is sometimes useful in a post validator context:

    [php]
    $v = new sfValidatorSchema();
    $v->setPostValidator(
      new sfValidatorSchemaFilter('email', new sfValidatorEmail())
    );

I18n Validators
---------------

### `sfValidatorI18nChoiceCountry`

*Schema validator*: No

The `sfValidatorI18nChoiceCountry` validates that the tainted value is a valid
country ISO 3166 code.

| Option      | Error     | Description
| ----------- | --------- | -----------
| `countries` | `invalid` | An array of country codes to use (ISO 3166)

### `sfValidatorI18nChoiceLanguage`

*Schema validator*: No

The `sfValidatorI18nChoiceLanguage` validates that the tainted value is a
valid country ISO 639-1 code.

| Option      | Error     | Description
| ----------- | --------- | -----------
| `languages` | `invalid` | An array of language codes to use (ISO 639-1)

Propel Validators
-----------------

### `sfValidatorPropelChoice`

*Schema validator*: No

The `sfValidatorPropelChoice` validator validates that the tainted value is
among the list of records of a given Propel model.

The list of records can be restricted by using the `criteria` option.

The tainted value must be the primary key of records. This can be changed by
passing the `column` option.

| Option       | Error | Description
| ------------ | ----- | -----------
| `model`      | n/a   | The model class (required)
| `criteria`   | n/a   | A criteria to use when retrieving objects
| `column`     | n/a   | The column name (null by default which means the primary key is used) - must be in field name format
| `connection` | n/a   | The Propel connection to use (`null` by default)
| `multiple`   | n/a   | `true` if the select tag must allow multiple selections

>**NOTE**
>This validator does not work for model with a composite primary key.

### `sfValidatorPropelChoiceMany`

*Schema validator*: No

The `sfValidatorPropelChoiceMany` validator validates that the tainted values
is among the list of records of a given Propel model.

>**NOTE**
>This validator expects an array as an input value. If a string is
>passed, it is converted to an array automatically.

This validator is a shortcut for:

    [php]
    $v = new sfValidatorPropelChoice(array('multiple' => true));

### `sfValidatorPropelUnique`

*Schema validator*: Yes

The `sfValidatorPropelUnique` validator validates that the uniqueness of a
column or a group of columns (`column` option) for a Propel model.

If the uniqueness is on several columns, the error can be thrown globally by
setting the `throw_global_error` option.

| Option               | Error | Description
| -------------------- | ----- | -----------
| `model`              | n/a   | The model class (required)
| `column`             | n/a   | The unique column name in Propel field name format (required). If the uniquess is for several columns, you can pass an array of field names
| `field`              | n/a   | Field name used by the form, other than the column name
| `primary_key`        | n/a   | The primary key column name in Propel field name format (optional, will be introspected if not provided). You can also pass an array if the table has several primary keys
| `connection`         | n/a   | The Propel connection to use (`null` by default)
| `throw_global_error` | n/a   | Whether to throw a global error (`false` by default) or an error tied to the first field related to the column option array

Doctrine Validators
-------------------

### `sfValidatorDoctrineChoice`

*Schema validator*: No

The `sfValidatorDoctrineChoice` validator validates that the tainted value is
among the list of records of a given Doctrine model.

The list of records can be restricted by using the `query` option.

The tainted value must be the primary key of records. This can be changed by
passing the `column` option.

| Option       | Error | Description
| ------------ | ----- | -----------
| `model`      | n/a   | The model class (required)
| `alias`      | n/a   | The alias of the root component used in the query
| `query`      | n/a   | A query to use when retrieving objects
| `column`     | n/a   | The column name (`null` by default which means the primary key is used) - must be in field name format
| `connection` | n/a   | The Doctrine connection to use (`null` by default)

>**NOTE**
>This validator does not work for model with a composite primary key.

### `sfValidatorDoctrineChoiceMany`

*Schema validator*: No

The `sfValidatorDoctrineChoiceMany` validator validates that the tainted
values is among the list of records of a given Doctrine model.

>**NOTE**
>This validator expects an array as an input value. If a string is
>passed, it is converted to an array automatically.

This validator inherits all the options from the `sfValidatorDoctrineChoice`
validator.

### `sfValidatorDoctrineUnique`

*Schema validator*: Yes

The `sfValidatorDoctrineUnique` validator validates that the uniqueness of a
column or a group of columns (`column` option) for a Doctrine model.

If the uniqueness is on several columns, the error can be thrown globally by
setting the `throw_global_error` option.

| Option               | Error | Description
| -------------------- | ----- | -----------
| `model`              | n/a   | The model class (required)
| `column`             | n/a   | The unique column name in Doctrine field name format (required). If the uniquess is for several columns, you can pass an array of field names
| `primary_key`        | n/a   | The primary key column name in Doctrine field name format (optional, will be introspected if not provided). You can also pass an array if the table has several primary keys
| `connection`         | n/a   | The Doctrine connection to use (`null` by default)
| `throw_global_error` | n/a   | Whether to throw a global error (`false` by default) or an error tied to the first field related to the column option array

