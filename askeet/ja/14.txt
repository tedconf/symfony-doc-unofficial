symfony アドベントカレンダー 14日目: タグ、パートⅡ
===================================================

復習
----

昨日のチュートリアルにおいて、symfonyのフォークソノミー機能の一部を構築しました。 `QuestionTag`クラスとモデルへの他のエクステンションは質問リストと詳細な質問内容において質問のタグを表示することを手助けしてくれました。 加えて、与えられたタグのための人気のある質問のリストもまた開発されました。

'web2.0'と関心のあるタグを行うために残された二つのことがあります: またそれらはweb2.0と聞こえるでしょう。 AJAXフォームととグローバルなaskeetタグバブルで新しいタグを追加する能力。 symfonyのアジャイル開発のメソッドを経験する準備はいいですか？

タグを質問に追加する
----------------------

### フォーム

質問のためにタグを追加することができる機能を登録ユーザに与えることがしたいだけでなく、彼または彼女が入力する最初の文字列と一致する前に、他の質問で与えられたタグの一つをサジェストもしたいです。これはオートコンプリートと呼ばれています。 [google suggest][2]で遊んだことがあるのでしたら、おわかり頂けるでしょう。

昨日、私達は質問の詳細が表示されたときにサイドバーに挿入されたフラグメントを作成しました。最後にこのフォームを追加するために`askeet/apps/frontend/modules/sidebar/templates/_question.php`ファイルを編集して下さい:

    [php]
    ...
    <?php if ($sf_user->isAuthenticated()): ?>
      <div>Add your own:
        <?php echo form_remote_tag(array(
          'url'    => '@tag_add',
          'update' => 'question_tags',
        )) ?>
          <?php echo input_hidden_tag('question_id', $question->getId()) ?>
          <?php echo input_auto_complete_tag('tag', '', 'tag/autocomplete', 'autocomplete=off', 'use_style=true') ?>
          <?php echo submit_tag('Tag') ?>
        </form>
      </div>
    <?php endif; ?>

もちろん、タグがユーザにリンクされていなければならないので、新しいタグの追加は認証されたユーザに制限されます。`form_remote_tag()`ヘルパについて一分ほど話すことにします。しかし、最初は、オートコンプリートの`input`タグを見て下さい。これはオプションをマッチする配列を取得するアクション(ここでは、`tag/autocomplete`)を指定します。

### オートコンプリート

アクションが返すリストは、複製されることなく。アルファベット順に並べられ、`tag`フォールドにおいてエントリーとマッチするユーザによって入力されたタグリストです。SQLクエリは下記のように返されます:

    [sql]
    SELECT DISTINCT tag AS tag
    FROM question_tag
    WHERE user_id = $id AND tag LIKE $entry
    ORDER BY tag

このアクションを`mpdules/tag/acitons/action.class.php`ファイルに追加をして下さい:

    [php]
    public function executeAutocomplete()
    {
      $this->tags = QuestionTagPeer::getTagsForUserLike($this->getUser()->getSubscriberId(), $this->getRequestParameter('tag'), 10);
    }

通常は、データベースのクエリの中心はモデルにあります、次のメソッドを`QuestionTagPeer`クラスに追加して下さい:

    [php]
    public static function getTagsForUserLike($user_id, $tag, $max = 10)
    {
      $tags = array();

      $con = Propel::getConnection();
      $query = '
        SELECT DISTINCT %s AS tag
        FROM %s
        WHERE %s = ? AND %s LIKE ?
        ORDER BY %s
      ';

      $query = sprintf($query,
        QuestionTagPeer::TAG,
        QuestionTagPeer::TABLE_NAME,
        QuestionTagPeer::USER_ID,
        QuestionTagPeer::TAG,
        QuestionTagPeer::TAG
      );

      $stmt = $con->prepareStatement($query);
      $stmt->setInt(1, $user_id);
      $stmt->setString(2, $tag.'%');
      $stmt->setLimit($max);
      $rs = $stmt->executeQuery();
      while ($rs->next())
      {
        $tags[] = $rs->getString('tag');
      }

      return $tags;
    }

アクションはタグリストを決定するので、私達は`autocompleteSuccess.php`テンプレートにそれらを形成する必要があるだけです:

    [php]
    <ul>
    <?php foreach ($tags as $tag): ?>
      <li><?php echo $tag ?></li>
    <?php endforeach; ?>
    </ul>

新しい`routing.yml`ルートを追加します(`_question.php`パーシャルの`input_auto_complet_tag()`コールにおける`module/action`の代わりに使って下さい):

    tag_autocomplete:
      url:   /tag_autocomplete
      param: { module: tag, action: autocomplete }

そして`view.yml`を設定します:

    autocompleteSuccess:
      has_layout:   off
      components:   []

進んで、試すことが出来ます。既存のアカウントで登録した後に(例えばfabpot/symofny)、質問を表示し、サイドバーに新しいフィールドを通知して下さい。このユーザによって既に与えられたタグの最初の文字列を入力して下さい(例えば、relatives)そして、適切なエントリーをサジェストするフィールドの下に現れるdivを見て下さい。

![オートコンプリート](/images/askeet/autocomplete.gif)

### リモートフォーム

フォームが投稿されたとき、全ページをリフレッシュする必要はありません。タグのリストとタグを追加するフォームはリフレッシュされる必要があるだけです。それが`form_remote_tag()`ヘルパの目的です。フォームが投稿されたとき(`tag/add`)にコールされるアクションおよびこのアクション('question_tags'によって特定される要素)の結果によってアップデートされるページのゾーンを特定します。これは質問を追加するAJAXフォームによって既に[8日目](8.txt)に説明されています。

`tag`アクションに`executeAdd()`メソッドを作成しましょう:

    [php]
    public function executeAdd()
    {
      $this->question = QuestionPeer::retrieveByPk($this->getRequestParameter('question_id'));
      $this->forward404Unless($this->question);

      $userId = $this->getUser()->getSubscriberId();
      $phrase = $this->getRequestParameter('tag');
      $this->question->addTagsForUser($phrase, $userId);

      $this->tags = $this->question->getTags();
    }

そして`Question`クラスに`addTagsForUser`です:

    [php]
    public function addTagsForUser($phrase, $userId)
    {
      // フレーズを個別のタグに分割する
      $tags = Tag::splitPhrase($phrase);

      // タグを追加する
      foreach ($tags as $tag)
      {
        $questionTag = new QuestionTag();
        $questionTag->setQuestionId($this->getId());
        $questionTag->setUserId($userId);
        $questionTag->setTag($tag);
        $questionTag->save();
      }
    }

`addSuccess.php`テンプレートは`update`ゾーンを置き換えるコードを決定します。通常はAJAXアクションを伴い、シンプルな`include_partial()`を含みます:

    [php]
    <?php include_partial('tag/question_tags', array('question' => $question, 'tags' => $tags)) ?> 

新しい`routing.yml`ルートを追加して下さい:

    tag_add:
      url:   /tag_add
      param: { module: tag, action: add }

`view.yml`を設定します:

    addSuccess:
      has_layout:    off
      components:    []

### テストする

試して下さい: サイトへのログイン、質問の詳細を表示する、新しいタグを入力し投稿する。全体のリストをアップデートし、新しいタグの挿入はアルファベット順にされることを。

タグバブルを表示する
--------------------

フォークソノミーは人気によってタグを評価します。しかしたくさんのタグはタグのリストを読むことを難しくします。もっとも満足する解決方法は、視覚的に言えば、人気に応じて、タグの言葉のサイズを増やすことです。もっとも人気のあるタグ　-多くのユーザによって与えられた- を即座に現れるようにします。タグバブルとは何かということを理解するために[del.icio.usの人気タグページ][3]をチェックして下さい。

ウェブサイトへの80％の訪問者は20％以下の内容にしか興味を示しません。それは毎日多くのウェブサイトが確認するルールで、askeetはおそらく違いはないでしょう。そこでaskeetはタグのリストを提案したとしたら、同様に人気によって並び替えられる必要があります。もっと不人気なタグ('grandma' 'chocolate')の摂動を制限するため、およびもっとも人気のあるタグ('php' 'real life' 'usefule')の視認性を増加させるためです。

### QuestionTagPeerクラスを拡張する

人気のあるタグのリストの提供者は'QuesitonTagPeer'とは別のクラスはありえないです。新しいメソッドで拡張すると、SQLクエリを書くことの代替方法を経験することになります:

    [php]
    public static function getPopularTags($max = 5)
    {
      $tags = array();
  
      $con = Propel::getConnection();
      $query = '
        SELECT '.QuestionTagPeer::NORMALIZED_TAG.' AS tag,
        COUNT('.QuestionTagPeer::NORMALIZED_TAG.') AS count
        FROM '.QuestionTagPeer::TABLE_NAME.'
        GROUP BY '.QuestionTagPeer::NORMALIZED_TAG.'
        ORDER BY count DESC';
        
      $stmt = $con->prepareStatement($query);
      $stmt->setLimit($max);
      $rs = $stmt->executeQuery();
      $max_popularity = 0;
      while ($rs->next())
      {
        if (!$max_popularity)
        {
          $max_popularity = $rs->getInt('count');
        }
  
        $tags[$rs->getString('tag')] = floor(($rs->getInt('count') / $max_popularity * 3) + 1);
      }
  
      ksort($tags);
  
      return $tags;
    }

人気度の数字を4の度合いまで制限します。なぜなら、さもなければタグクラウドが読めなくなるからです。メソッドの結果はタグ名と人気度の連想配列です。表示する準備ができました。

### タグバブルを表示する

`tag`モジュールにシンプルで`popular`アクションを作成して下さい:

    [php]
    public function executePopular()
    {
      $this->tags = QuestionTagPeer::getPopularTags(sfConfig::get('app_tag_cloud_max'));
    }

アクションと同じぐらいシンプルなのは`popularSuccess.php`テンプレートです:

    [php]
    <h1>popular tags</h1>
    
    <ul id="tag_cloud">
      <?php foreach($tags as $tag => $count): ?>
      <li class="tag_popularity_<?php echo $count ?>"><?php echo link_to($tag, '@tag?tag='.$tag, 'rel=tag') ?></li>
      <?php endforeach; ?>
    </ul>

`routing.yml`設定ファイルにある新しいアクションのためにルーティングルールを追加することを忘れないで下さい:

    popular_tags:
      url:   /popular_tags
      param: { module: tag, action: popular }

`app_tag_cloud_max`パラメータをアプリケーション`app.yml`に追加して下さい:

    all:
      tag:
        cloud_max:   40

すべて準備が整いました: リクエストによってタグクラウドを表示して下さい。

    http://askeet/popular_tags

### タグリスト項目を表す

しかし、クラウドはどこにあるのでしょうか？本当のシェイピングは、ウェブスタンダードによって推奨されるように、スタイルシートによって行われます。次の宣言を`main.css`スタイルシート(`askeet/web/css`に設置されています)に追加して下さい。

    [css]
    ul#tag_cloud
    {
      list-style: none;
    }
    
    ul#tag_cloud li
    {
      list-style: none;
      display: inline;
    }
    
    ul#tag_cloud li.tag_popularity_1
    {
      font-size: 60%;
    }
    
    ul#tag_cloud li.tag_popularity_2
    {
      font-size: 100%;
    }
    
    ul#tag_cloud li.tag_popularity_3
    {
      font-size: 130%;
    }
    
    ul#tag_cloud li.tag_popularity_4
    {
      font-size: 160%;
    }
    
人気タグのページをリフレッシュして、ほら!

![タグクラウド](/images/askeet/tag_cloud.gif)

それではまた明日
----------------

symfonyでタクソノミーをあなたのサイトに追加することはたいしたことではありません。複雑なリクエスト、自動入力補完フォームとフォームへの投稿をしたあとに、ローカルなページのリフレッシュはわずかな行のコードさえ追加すればできます。

しかし、アプリケーションを開発することの容易さは開発のよい原則を忘れさせてしまうことはありませんし、あなたが変更した変更は常にテストすべきです。 速く開発し、しょっちゅうリファクタするためのベストツールはユニットテストです。 [ユニットテスト][4]はコンピュータプログラミングにおいて最近のもっとも偉大な進歩です。 それらは明日取り扱います。

それまでは、[askeetのメーリングリスト](mailto:askeet-subscribe@symfony-project.com)に21日のための提案を投稿することができます。 これまでのアプリケーションのソースコード全体をダウンロードしたいのであれば、 `/tags/release_day_14`とタグ付けされた[askeetのSVNリポジトリ](http://svn.askeet.com/tags/release_day_14/)に行って下さい。

[1]: http://en.wikipedia.org/wiki/Folksonomy       "Folksonomy definition at Wikipedia"
[2]: http://www.google.com/webhp?complete=1&hl=en  "Google suggest"
[3]: http://del.icio.us/tag/                       "de.icio.us Popular tags"
[4]: http://en.wikipedia.org/wiki/Unit_test        "Unit test definition at Wikipedia"