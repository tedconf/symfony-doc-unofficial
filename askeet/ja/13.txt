symfony アドベントカレンダー 13日目: タグ
=========================================

復習
----

askeetアプリケーションはWebページ、RSSフィードもしくは、Eメールを通して、データを提供することができます。 問題を質問することと回答することが可能です。しかし、問題の構成はまだ開発されています。 問題の組織はカテゴリとサブカテゴリは何千ものブランチを伴った切り分けられない木構造に達しており、サブブランチにおいてあなたが探しているであろう問題を知るのは簡単なことではありません。

しかしながら、Web2.0アプリケーションは項目の組織の新しい方法を伴って世に出ます。:タグです。 タグと言葉、カテゴリーとして。しかし、従来と異なるのは、タグの階層がないこと、項目がいくつかのタグを持つことです。 カテゴリで猫を見つけることがやっかいであることが判明した一方で、 タグを伴うのはとてもシンプルです。(pet+cute) すべてのユーザが与えられた問題へタグを追加できる機能を追加することで、有名な[フォークソノミー][1]のコンセプトを得ることができます。

何だと思いますか？それがまさにaskeetの質問を必要していることです。 時間が必要ですが(今日と明日)、しかし、結果は労力に見合う価値があります。 Creoleのコネクションを使って複雑なSQLのリクエストをどのように行うのか示す機会があります。それでは行ってみましょう。

QuestionTagクラス
-------------------

タグを埋め込む方法がいくつかあります。次の構造を持った`QuestionTag`テーブルを追加することを選択します:

![ERD](/images/askeet/mcd3.gif)

ユーザが質問をタグ付けしたとき、`user`テーブルと`question`テーブルの両方にリンクされた`question_tag`テーブルに新しいレコードを作成します。記録されたタグの二つのバージョンがあります: ユーザによって拡張されたものとインデックスのために使用される通常のバージョンです(特別な文字が無いときの下位のケースです)。

### スキーマの更新

通常、テーブルをsymfonyのプロジェクトに追加する作業はPropelの定義を`schema.yml`ファイルに追加することで行われます:

    [xml]
    ...
    <table name="ask_question_tag" phpName="QuestionTag">
      <column name="question_id" type="integer" primaryKey="true" />
      <foreign-key foreignTable="ask_question">
        <reference local="question_id" foreign="id" />
      </foreign-key>
      <column name="user_id" type="integer" primaryKey="true" />
      <foreign-key foreignTable="ask_user">
        <reference local="user_id" foreign="id" />
      </foreign-key>
      <column name="created_at" type="timestamp" />
      <column name="tag" type="varchar" size="100" />
      <column name="normalized_tag" type="varchar" size="100" primaryKey="true" />
      <index name="normalized_tag_index">
        <index-column name="normalized_tag" />
      </index>
    </table>

オブジェクトモデルをリビルドします:

    $ symfony propel-build-model
    
### カスタムクラス

次のメソッドとともに新しい`Tag.class.php`を`askeet/lib/`ディレクトリに追加して下さい:

    [php]
    <?php
    
    class Tag
    {
      public static function normalize($tag)
      {
        $n_tag = strtolower($tag);
    
        // 望まないすべての文字列を取り除く
        $n_tag = preg_replace('/[^a-zA-Z0-9]/', '', $n_tag);
    
        return trim($n_tag);
      }
    
      public static function splitPhrase($phrase)
      {
        $tags = array();
        $phrase = trim($phrase);
    
        $words = preg_split('/(")/', $phrase, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);
        $delim = 0;
        foreach ($words as $key => $word)
        {
          if ($word == '"')
          {
            $delim++;
            continue;
          }
          if (($delim % 2 == 1) && $words[$key - 1] == '"')
          {
            $tags[] = trim($word);
          }
          else
          {
            $tags = array_merge($tags, preg_split('/\s+/', trim($word), -1, PREG_SPLIT_NO_EMPTY));
          }
        }
    
        return $tags;
      }
    }
    
    ?>    

最初のメソッドは通常のタグを返し、次のメソッドは引数としてフレーズを取得しタグの配列を返します。これら2つのメソッドはタグを操作するときにとても役立ちます。

`lib/`ディレクトリにクラスを追加する利益は自動的にかつ、要求される必要ことなく、必要なときだけロードされるからです。オートローディングと呼んでいます。

### モデルを拡張する

新しい`askeet/lib/model/QuestionTag.php`に、tagが設定されたときに`normalized_tag`を設定する次のメソッドを追加して下さい:

    [php]
    public function setTag($v)
    {
      parent::setTag($v);
  
      $this->setNormalizedTag(Tag::normalize($v));
    }

先ほど作成されたヘルパクラスはすでに大いに役立ちます。このメソッドのコードを二行だけに減らします。

### テストデータを追加する

いくつのタグのテストデートとともに`askeet/data/fixtures/`ディレクトリにファイルを追加して下さい:

    QuestionTag:
      t1: { question_id: q1, user_id: fabien, tag: relatives }
      t2: { question_id: q1, user_id: fabien, tag: girl }
      t4: { question_id: q1, user_id: francois, tag: activities }
      t6: { question_id: q2, user_id: francois, tag: 'real life' }
      t5: { question_id: q2, user_id: fabien, tag: relatives }
      t5: { question_id: q2, user_id: fabien, tag: present }
      t6: { question_id: q2, user_id: francois, tag: 'real life' }
      t7: { question_id: q3, user_id: francois, tag: blog }
      t8: { question_id: q3, user_id: francois, tag: activities }
      
このファイルはアルファベットの順序でディレクトリの他のファイルの追跡をすることで`sfPropelDate`オブジェクトが`Question`と`User`テーブルのレコードに関連したこれらの新しいレコードにリンクすることを確認してください。コーリングによってデータベースをリポピュレイトすることができます:

    $ php batch/load_data.php

アクションにタグを動作させる準備ができています。しかし、最初は`Question`クラスのための拡張をさせて下さい。

質問のタグを表示する
--------------------

何かをコントロールレイヤに追加する前に、内容の構造を維持するために新しい`tag`モジュールを追加してみましょう:

    $ symfony init-module frontend tag

### モデルを拡張する

与えられた質問のためにすべてのユーザによってタグ付けされたすべての言葉のリストを表示する必要があります。関連したタグを取り出す機能が`Question`クラスのメソッドであるべきなので、私達は拡張します。(`askeet/lib/model/Question.php`)ここでのトリックは二重タグを避けるための二重エントリーをグループ化することです。(二つの同一タグは結果に対して一回のみ出現すべきです。)新しいメソッドはタグの配列を返さなければなりません:

    [php]
    public function getTags()
    {
      $c = new Criteria();
      $c->clearSelectColumns();
      $c->addSelectColumn(QuestionTagPeer::NORMALIZED_TAG);
      $c->add(QuestionTagPeer::QUESTION_ID, $this->getId());
      $c->setDistinct();
      $c->addAscendingOrderByColumn(QuestionTagPeer::NORMALIZED_TAG);
      
      $tags = array();
      $rs = QuestionTagPeer::doSelectRS($c);
      while ($rs->next())
      {
        $tags[] = $rs->getString(1);
      }
      
      return $tags;
    }

今回、一つのコラムだけひつようなので(`normalized_tag`)、Propelデータベースから投入された`Tag`オブジェクトの配列を返すようにProperlに求める意味はないです。(ちなみにこのプロセスは*hydrating*と呼ばれます。)そこで、ずっと速く、配列を構文解析するシンプルなクエリを行います。

### ビューを修正する

詳細な質問ページは与えられた質問のためのタグのりストを表示しなければなりません。そのためのサイドバーを使用します。[7日目](7.txt)にコンポーネントスロットとして構築したので、questionモジュールだけにおいてこのバーのための特別なコンポーネントを設定します。

そこで`askeet/apps/frontend/modules/question/config/view.yml`において、次の設定を追加して下さい:

    showSuccess:
      components:
        sidebar: [sidebar, question]

この`sidebar`モジュールのコンポーネントはまだ作成されていませんが、とてもシンプルです(`modules/sidebar/actions/components.class.php`):

    [php]
    public function executeQuestion()
    {
      $this->question = QuestionPeer::getQuestionFromTitle($this->getRequestParameter('stripped_title'));
    }

書くのにもっと長い部分はフラグメントです。(`modules/sidebar/templates/_question.php`):

    [php]
    <?php include_partial('sidebar/default') ?>

    <h2>question tags</h2>

    <ul id="question_tags">
      <?php include_partial('tag/question_tags', array('question' => $question, 'tags' => $question->getTags())) ?> 
    </ul>

タグのリストをフラグメントとして挿入することを選びます。少し後のAJAXリクエストによってリフレッシュされるからです。

この`sidebar`モジュールのコンポーネントはまだ作成されていませんが、とてもシンプルです(`modules/sidebar/actions/components.class.php`):

    [php]
    <?php foreach($tags as $tag): ?>
      <li><?php echo link_to($tag, '@tag?tag='.$tag, 'rel=tag') ?></li>
    <?php endforeach; ?>

`rel=tag`属性は[マイクロフォーマット](http://microformats.org/wiki/rel-tag)です。決して強制的なものではありませんが、ここに追加しても何も得ないので、停止することにします。

`@tag`ルーティングルールを`routing.yml`に追加して下さい:

    tag:
      url:   /tag/:tag
      param: { module: tag, action: show }

### テストする

最初の質問の詳細を表示し、サイドバーにあるタグのリストを探して下さい:

    http://askeet/question/what-can-i-offer-to-my-step-mother
    
![質問のためのタグリスト](/images/askeet/tag_list_question.gif)

質問のための人気のあるタグのショートリストを表示する
----------------------------------------------------

サイドバーは質問のための全体のタグリストを表示するためのよい場所です。しかし、質問リストに表示されたタグについてはどうでしょうか？各質問ごとに、タグのサブセットを表示するだけです。しかしながらどちらでしょうか？私達は最もポピュラーな方を選択します。すなわち、最も頻繁にずっとこの質問が与えられるよりもタグです。おそらく私達はこの質問のための関連したタグの人気を増加させるために存在しているタグによって質問をタグ付けすることを継続することをユーザに推奨することが必要です。すべてのユーザがそれをしないのであれば、"moderators"が行います。

### モデルを拡張する

ともかく、このことは私達の`Question`オブジェクトを`->getPopularTags()`メソッドに追加することが必要であることを意味します。しかし、今回、データベースへのリクエストはシンプルではありません。それをするためにPropelを使うことはリクエスト数を増やし、多くの時間を費やします。symfonyはベストソリューションであるとき、SQLのパワーを使うことを許可します。そこで、データベースへのCreole接続を必要とし通常のSQLクエリを実行します。

このクエリは次のようになります:

    [sql]
    SELECT normalized_tag AS tag, COUNT(normalized_tag) AS count
    FROM question_tag
    WHERE question_id = $id
    GROUP BY normalized_tag
    ORDER BY count DESC
    LIMIT $max
     
しかしながら、現実のコラムとテーブル名はデータベースへの依存を作成し、データ抽象レイヤを回避します。将来、コラムまたはテーブルをリネームすることを決めたとしたら、この生のSQLクエリはもはや動きません。リクエストのsymfonyバージョンは現在のネームを使わずに、抽象化されたものを代わりに使うのはそういうわけです。読むのが少し難しくなりますが、メンテナンスをより簡単にします。

    [php]
    public function getPopularTags($max = 5)
    {
      $tags = array();
  
      $con = Propel::getConnection();
      $query = '
        SELECT %s AS tag, COUNT(%s) AS count
        FROM %s
        WHERE %s = ?
        GROUP BY %s
        ORDER BY count DESC
      ';
  
      $query = sprintf($query,
        QuestionTagPeer::NORMALIZED_TAG,
        QuestionTagPeer::NORMALIZED_TAG,
        QuestionTagPeer::TABLE_NAME,
        QuestionTagPeer::QUESTION_ID,
        QuestionTagPeer::NORMALIZED_TAG
      );
  
      $stmt = $con->prepareStatement($query);
      $stmt->setInt(1, $this->getId());
      $stmt->setLimit($max);
      $rs = $stmt->executeQuery();
      while ($rs->next())
      {
        $tags[$rs->getString('tag')] = $rs->getInt('count');
      }
  
      return $tags;
    }

最初に、`$con`においてデータベースへの接続がオープンされます。SQLクエリは抽象化レイヤから由来するコラムとテーブル名による文字列において、`%s`トークンを置き換えることによってビルドされます。クエリを含む`Statement`オブジェクトとクエリの結果を含む`ResultSet`オブジェクトが作成されます。これらはCreoleのオブジェクトで、それらの使い方は[Creoleのドキュメント][2]に詳しく書かれています。質問idによるSQLクエリにおいて`Statement`オブジェクトの`->setInt()`メソッドは最初の?を置き換えます。`$max`引数は-`>setLimit()`メソッドによってリターンされた結果の数を制限するために使用されます。

データベースへの一つのリクエストによって降順のポピュラリティで並び替えられたノーマライズされたタグとポピュラリティの連想配列をメソッドはリターンします。

### ビューを修正する

今や、私達は`modules/question/templates/`ディレクトリにある`_list.php`フラグメントにフォーマットされた質問のためのタグリストを追加することができます:

    [php]
    <?php use_helper('Text', 'Date', 'Global', 'Question') ?>
    
    <?php foreach($question_pager->getResults() as $question): ?>
      <div class="question">
        <div class="interested_block" id="block_<?php echo $question->getId() ?>">
          <?php include_partial('question/interested_user', array('question' => $question)) ?>
        </div>
    
        <h2><?php echo link_to($question->getTitle(), '@question?stripped_title='.$question->getStrippedTitle()) ?></h2>
    
        <div class="question_body">
          <div>asked by <?php echo link_to($question->getUser(), '@user_profile?nickname='.$question->getUser()->getNickname()) ?> on <?php echo format_date($question->getCreatedAt(), 'f') ?></div>
          <?php echo truncate_text(strip_tags($question->getHtmlBody()), 200) ?>
        </div>
        
        tags: <?php echo tags_for_question($question) ?>
    
      </div>
    <?php endforeach; ?>
    
    <div id="question_pager">
      <?php echo pager_navigation($question_pager, $rule) ?>
    </div>

私達は`+`記号によってタグを分離および、制限を取り扱うためのテンプレートにおいて多すぎるコードを避けたいので、`lib/helper/QuestionHelper.php`ヘルパライブラリに`tags_for_quesiton()`ヘルパ関数を書きます:

    [php]
    function tags_for_question($question, $max = 5)
    {
      $tags = array();
    
      foreach ($question->getPopularTags($max) as $tag => $count)
      {
        $tags[] = link_to($tag, '@tag?tag='.$tag);
      }
    
      return implode(' + ', $tags);
    } 

### テストする

質問のリストは質問ごとに人気のあるタグを表示します:

    http://askeet/

![質問リストのための人気タグ](/images/askeet/popular_tags_question_list.gif)

単語でタグ付けされた質問のりストを表示する
------------------------------------------

タグを表示するたびに、`@tag`ルーティングルールへのリンクを追加します。与えられたタグによってタグ付けされた人気のある質問を表示するページへのリンクをすることになります。

### `tag/show`アクション

`tag`モジュールにおいて`show`アクションを作成して下さい:

    [php]
    public function executeShow()
    {
      $this->question_pager = QuestionPeer::getPopularByTag($this->getRequestParameter('tag'), $this->getRequestParameter('page'));
    }

### モデルを拡張する

通常は、モデルを処理するコードはモデルの中に設置されます。今回の場合は`Question`オブジェクトのセットをリターンするので、`QuestionPeer`クラスにします。私達は興味を示したユーザによる人気のある質問が欲しいので、今回は、複雑なリクエストが必要ないです。Propelは`->doSelect()`コールで行うことが出来ます:

    [php]
    public static function getPopularByTag($tag, $page)
    {
      $c = new Criteria();
      $c->add(QuestionTagPeer::NORMALIZED_TAG, $tag);
      $c->addDescendingOrderByColumn(QuestionPeer::INTERESTED_USERS);
      $c->addJoin(QuestionTagPeer::QUESTION_ID, QuestionPeer::ID, Criteria::LEFT_JOIN);
      
      $pager = new sfPropelPager('Question', sfConfig::get('app_pager_homepage_max'));
      $pager->setCriteria($c);
      $pager->setPage($page);
      $pager->init();

      return $pager;
    }
  
メソッドは人気順に並んだ、質問のページャをリターンします。

### テンプレートを作成する

`modules/tag/templates/showSuccess.php`テンプレートはあなたが期待したものと同じぐらいシンプルです:

    [php]
    <h1>popular questions for tag "<?php echo $sf_params->get('tag') ?>"</h1>
    
    <?php include_partial('question/list', array('question_pager' => $question_pager, 'rule' => '@tag?tag='.$sf_params->get('tag'))) ?>

### `page`パラメータをルーティングルールに追加する

`routing.yml`に`@tag`のルーティングルールにデフォルトの値で`:page`パラメータを追加して下さい:

    tag:
      url:   /tag/:tag/:page
      param: { module: tag, action: show, page: 1 }


### テストする

この言葉によってタグ付けされたすべての質問を見るための`activities` タグページにナビゲートして下さい:

    http://askeet/tag/activities
    
![活発度がタグ付けされた質問のリスト](/images/askeet/tagged_question_list.gif)

それではまた明日
----------------

Creoleデータベースの抽象レイヤはsymfonyは複雑なSQLリクエストを行うことを可能にします。その上、オブジェクト指向のマッピングでもあるPropelはオブジェクト指向の世界において動作するツールとデータベースから悩まずに済む有用なメソッドを提供します。 そしてリクエストをシンプルなセンテンスに翻訳します。

データベースへの上記のリクエストが重要な負荷をかけるかもしれないことを心配する方も中にはいらっしゃるかもしれません。最適化も可能です。例えば、質問テーブルにpopular_tagsコラムを作成することもありえました。 質問リストはそれで軽くなります。しかし、キャッシュシステム　- 残りの日に討論しますが - がこの最適化を無用にします。

明日は、askeetのサイトのタグ機能を終わらせます。ユーザは質問にタグを追加できるようになり、グローバルタグバブルが利用可能になります。そのことについて読むことを思い出して下さい。

`/tags/relase_day_13`とタグ付けされた[askeetのSVNリポジトリ](http://svn.askeet.com/tags/release_day_13/)から今日の分のaskeetアプリケーションの全コードを入手できます。何か今日のチュートリアルに質問がありましたら、[askeetフォーラム](http://www.symfony-project.com/forum/index.php/f/8/)に気軽に質問して下さい。

[1]: http://en.wikipedia.org/wiki/Folksonomy       "Folksonomy definition at Wikipedia"
[2]: http://creole.phpdb.org/trac/wiki/Documentation/CreoleGuide  "Creole Guide"