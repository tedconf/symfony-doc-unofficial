symfony アドベントカレンダー 19日目: パフォーマンスとキャッシュ
===============================================================

復習
----

アドベントカレンダーの日々は過ぎ、あなたはsymfonyフレームワークとそのコンセプトに快適になりつつあります。 アジャイル開発のグッドプラクティスに従っていれば、askeetのようにアプリケーションを開発することは難しいことではありません。しかしながら、あなたのサイトのprototypeが準備が整い次第、すぐにやるべきことは、テストとパフォーマンスの最適化です。

フレームワークが原因のオーバーヘッドは、とりわけ共有サーバであなたのサイトがホストされているとしたら、一般的な関心事です。 symfonyはサーバの応答を遅くすることはないですが、自分自身で見て、ページ配信速度を上げるためにコードを微調整したいと思っているかもしれません。 そこで今日のチュートリアルはパフォーマンスの測定と改善に焦点を当てます。

テスティングツールをロードする
------------------------------

[15日目](15.txt)に説明したユニットテストは*一人のユーザが接続したときに*アプリケーションが期待通りに動作するかバリデートすることができます。 インターネット上のアプリケーションのリリースしたら、- 私達があなたに対して最小限望むことですが -興奮したファンの大群が一斉にサイトへラッシュして、パフォーマンス問題が発生します。ウェブサーバは落ち、手動で再起動する必要が出てきます。何が何でも避けるべき、本当に苦痛な経験です。アプリケーションの初期においてとりわけ重要なことです。初期のユーザが推論をして、うわさを広めることを決める前に。

パフォーマンス問題を避けるためには、リリースする前に、あなたのウェブサイトがどのように反応するのかを見るために、数多くの同時アクセスをシミュレートすることが必要です。[ロードテスティング](http://en.wikipedia.org/wiki/Load_testing)と呼ばれます。基本的には、同時リクエストをあなたのウェブサーバに投稿することを自動化するプログラムをし、リターンする時間を測定します。

>**Note**: ロードテスティングツールが何であれ、ウェブサイトを運営しているものよりも異なったサーバで実行した方が望ましいです。テスティングツールは一般的にCPUを消費し、それら自身の動作がサーバのパフォーマンスの結果を不安定にします。加えて、ローカルネットワークでテストをしてください。外部のネットワークのコンポーネント(プロキシ、ファイアーウォール、ルーター、ISPなど)による不安定性を避けるためです。

### JMeter

もっと一般的なロードテスティングツールは**[JMeter](http://jakarta.apache.org/jmeter/)**で、Apache財団によってメンテナンスされているオープンソースのJavaアプリケーションです。使い始めるために手助けをしてくれる見応えのある[オンラインドキュメント](http://jakarta.apache.org/jmeter/usermanual/index.html)があり、[ロードテスティング](http://jakarta.apache.org/jmeter/usermanual/boss.html)のイントロダクションも含んでいます。

インストールするためには、最新の安定版(2.1.1以降)を[Jmeterのダウンロードページ](http://jakarta.apache.org/site/downloads/index.html#jmeter_binaries)から入手して下さい。[Sunのサイト](http://java.com/en/download/index.jsp)で入手できる最新のJRE([Java Runtime Environment](http://en.wikipedia.org/wiki/Java_programming_language#Java_Runtime_Environment))も必要です。JMeterをスタートさせるためには、ディレクトリに移動してjmeter.batファイル(Windowsプラットフォームの場合)をランさせるか、`java jmeter.jar`をタイプしてください。(Linuxプラットフォーム)

'ウェブテストプラン 'と呼ばれるロードテスティングのプランを始める方法は、JMeterのドキュメンテーションの[関連ページ](http://jakarta.apache.org/jmeter/usermanual/build-web-test-plan.html)に詳細が説明されています。ですので、私達はここでは説明いたしません。

![JMeter web test plan results](/images/askeet/jmeter.gif)

>**Note**:  JMeterは与えられたリクエストもしくはリクエストのセットへの平均レスポンスタイムをリポートするだけでなく、受信するページのコンテンツについてアサーションをします。ですので、ロードテスティングツールとしてJMeterを使うことに加え、リグレッションテストとユニットテストをするためのシナリオを構築することができます。

### Apacheのab

symfonyにお勧めの第二のツールはApache Bench(ab)で、他の素晴らしいユーティリティをあなたにもたらしてくれます。Apache財団が開発しています。[オンラインマニュアル](http://httpd.apache.org/docs/2.2/programs/ab.html)はJMeterの物より少ないですが、abはコマンドラインツールなので、使うのは簡単です。

LinuxではApacheパッケージに標準で付属していますので、Apacheサーバをインストールしたのであれば、`/usr/local/apache/bin/ab`で見つけることができます。Windowsプラットフォームにおいては、探すのは難しいので、[symfony](http://www.symfony-project.com/downloads/ab.zip)から直接ダウンロードした方がよいでしょう。

このベンチマークツールの使用はとてもシンプルです:

    $ /usr/local/bin/apache2/bin/ab -c 1 -n 1 http://www.askeet.com/
    This is ApacheBench, Version 2.0.41-dev <$Revision: 1.121.2.12 $> apache-2.0
    Copyright   1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
    Copyright   1998-2002 The Apache Software Foundation, http://www.apache.org/
   
    Benchmarking www.askeet.com (be patient).....done
   
   
    Server Software:        Apache
    Server Hostname:        www.askeet.com
    Server Port:            80
   
    Document Path:          /
    Document Length:        15525 bytes
   
    Concurrency Level:      1
    Time taken for tests:   0.596104 seconds
    Complete requests:      1
    Failed requests:        0
    Write errors:           0
    Total transferred:      15874 bytes
    HTML transferred:       15525 bytes
    Requests per second:    1.68 [#/sec] (mean)
    Time per request:       596.104 [ms] (mean)
    Time per request:       596.104 [ms] (mean, across all concurrent requests)
    Transfer rate:          25.16 [Kbytes/sec] received
   
    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:       61   61   0.0     61      61
    Processing:   532  532   0.0    532     532
    Waiting:      359  359   0.0    359     359
    Total:        593  593   0.0    593     593

>**Note**: ページネーム(少なくとも上の例では`/`)を提供する必要があります。なぜなら、一つのホストだけをターゲットにするのは不正にフォーマットされたURLエラーを与えます。

`-c`と`-n`パラメータは同時スレッドのナンバーと実行するためのリクエストのトータルナンバーを定義します。もっとも興味深い結果データは最後の行です。平均のトータルコネクションタイム(左から2番目のナンバー)この例の場合、、一つのコネクションのみで、コネクションタイムはあまり正確ではありません。ページの実際のパフォーマンスのビューをよくするためには、平均のいくつかのリクエストが必要で、平行で立ち上げる必要があります:

    $ /usr/local/bin/apache2/bin/ab -c 10 -n 20 http://www.askeet.com/
    ...
   
    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:       59   88  19.9     89     130
    Processing:   831 1431 510.9   1446    3030
    Waiting:      632 1178 465.1   1212    2781
    Total:        906 1519 508.4   1556    3089
   
    Percentage of the requests served within a certain time (ms)
      50%   1556
      66%   1569
      75%   1761
      80%   1827
      90%   2285
      95%   3089
      98%   3089
      99%   3089
     100%   3089 (longest request)

リクエストのラージナンバーで実行する前にテスト自身によって取得された時間のアイディアを持つために、`ab -c 1 -n 1`によって始めることになります。 妥当な小さい標準偏差を得るまで、トータルリクエストナンバー(`ab -c 1 -n 30`のように)を増やして下さい。 重要な平均コネクションタイム測定を手に入れたときのみ、実際のロードテストの準備ができます。少しずつスレッドを追加し(`ab -c 10 -n 300`のように)リクエストのトータルナンバーを増加させることを忘れないで下さい。数秒を超えて、平均ローディングタイムがパスをしたとき、あなたのサーバは対処できる数を超え、コンカレントスレッドをサポートすることがおそらくできないです。あなたのサービスの最大チャージを決定しました。ストレステストと呼ばれます。

>**Note**: インターネット上で動作しているあなた自身のサイト以外にストレステストをしないようお願いします。外部のサイトでストレステストを行うことはDoS攻撃([Denial of Service](http://en.wikipedia.org/wiki/Denial-of-service_attack))と見なされます。[askeetウェブサイト](http://www.askeet.com/)に違いはありませんが、もう一度繰り返します、ストレステストをしないでください。

ロードテストは二つの重要な情報のピースを提供します: 特別ページの平均ローディングタイムと、あなたのサーバの最大キャパシティです。最初のはパフォーマンス改善をモニターするのにとても有用です。

キャッシュでパフォーマンスを改善する
-----------------------------------

与えられたページのパフォーマンスを増加させるための多くの方法があります。コードプロファイリング、データベースリクエスト最適化、インデックスの追加、ウェブサイトのメディア専用の代替的な軽量ウェブサーバの作成などがあります。クロスランゲージ、PHP特有の、ウェブをブラウジングする、良本を購入するなどでどのようにしてパフォーマンスの導師になるのかというテクニックを学ぶことができます。

symfonyはウェブリクエストへのある種のオーバロードを追加します。コンフィギュレーションとフレームワーククラスはそれぞれのリクエストのためにロードされ、MVC分離とORM抽象化は実行コードをより多く増やすことで終わるからです。このオーバーヘッドは相対的に低いですが(他のフレームワークや言語と比べて)、symfonyはキャッシングのレスポンスタイムをバランスを保つ方法も提供します。 アクションの結果、もしくは全ページで、ウェブサーバのハードディスク上に書かれます。そしてこのファイルは同じリクエストが再び要求されたときに再利用されます。これはかなりパフォーマンスを押し上げます。すべてのデータベース、デコラーションとアクションの実行が完全にバイパスされるからです。symfonyブックの[キャッシュの章](http://www.symfony-project.com/book/1_0/12-Caching)でsymfonyのキャッシュについて情報を得ることが出来ます。

ポピュラーなタグページの配信をスピードアップするためにHTMLキャッシュを試します。複雑なSQLクエリを含むので、キャッシングのためのよい候補です。最初に、どのようにして現在のコードをロードするために時間がかかるのか見てみます:

    $ ab -c 1 -n 30 http://askeet/popular_tags
    ...
    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:        0    0   0.0      0       0
    Processing:   147  148   2.4    148     154
    Waiting:      138  139   2.3    139     145
    Total:        147  148   2.4    148     154
    ...

### アクションの結果をキャッシュに保存する

>**Caution**: 次のコードはsymfony0.6では動作しません。このチュートリアルがアップデートされるまで、次のセクションに飛んで下さい。

ポピュラータグのリストを表示するために実行されたアクションは`tag/popular`です。このアクションの結果をキャッシュするために、私達がすべきことは`cache.yml`ファイルを`askeet/apps/frotnend/modules/tag/config/ `ディレクトリに作成することです:

    popular:
      activate:   on
      type:       slot
   
    all:
      lifeTime:   600

これはこのアクションのための`slot`タイプキャッシュをアクティベイトします。アクションの結果(ビュー)は`cache/frontend/prod/template/askeet/popular_tags/slot.cache`ファイルに蓄積され、作成された後で次の600秒(10分)のためのアクションのコーリングの代わりに、このファイルは使用されます。このことが意味するのはポピュラータグページは10分ごとに続行され、その間、キャッシュのバージョンは同じ場所で使われます。

キャッシングは最初のリクエストで行われるので、ブラウザで見る必要があります:

    http://askeet/popular_tags
   
...テンプレートのキャッシュバージョンを作成するためです。次の10分間このページへのすべてのコールは速くなり、Apacheベンチマーキングツールを再び動かすことですぐにチェックすることができます:

    $ ab -c 1 -n 30 http://askeet/popular_tags   
    ...
    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:        0    0   0.0      0       0
    Processing:   137  138   2.0    138     144
    Waiting:      128  129   2.0    129     135
    Total:        137  138   2.0    138     144
    ...

148msから138msまでの平均をパスしました。パフォーマンスの7％増加です。キャッシュシステムはパフォーマンスを改善する重要な方法です。

>**Note**: `slot`タイプはページのデコレーションをバイパスしません。(例えばレイアウトのテンプレートの挿入など)この場合、全体のページをキャッシュすることができません。なぜならレイアウトは内容に依存して要素を含むからです。(例えばトップページのユーザネーム)しかし、ノンダイナミックなレイアウトには、symfonyはもっと効果的なページタイプも提供します。

### ステージング環境を構築する

デフォルトでは、キャッシュシステムは開発環境では動作が停止しており、プロダクション環境では動作します。十分にコンフィギャされなかった場合、キャッシュページが新しいエラーを作成する可能性があるからです。ウェブアプリケーションのテストに関するグッドプラクティスはプロダクション環境と同じような新しいテスト環境を構築することです。しかし、テスト環境ではすべてのデバッグとトレースツールが利用可能にしておきます。私達はしばし 'ステージング '環境と呼んでいます。開発環境ではなく、ステージング環境において、エラーが発生した場合、このエラーがキャッシュによって引き起こされた可能性が大いにあります。

機能を開発するとき、まず開発環境で適切に動作するようにして下さい。それから、パフォーマンスを改善するために関連したアクションのキャッシュパラメータを変更します。そして、キャッシングシステムが機能的な不安定さを作成しないか見るために、再びステージング環境でテストをして下さい。すべてがうまくいったとき、改善を図るためにプロダクション環境でロードテストを実行する必要があります。アプリケーションの動作が開発環境よりも異なった場合、キャッシュの設定方法を再度確認する必要があります。[ユニットテスト](15.txt)はこの手順をシステマティックする大いなる手助けになります。

ステージング環境を作成するために、新しいフロントコントローラを追加し、環境設定を定義する必要があります。

プロダクションフロントコントローラ(`askeet/web/index.php`)を`askeet/web/frontend_staging.php`ファイルにコピーし、次のように定義を変更する必要があります:

    [php]
    <?php
    
    define('SF_ROOT_DIR',    realpath(dirname(__FILE__).'/..'));
    define('SF_APP',         'frontend');
    define('SF_ENVIRONMENT', 'staging');
    define('SF_DEBUG',       false);
    
    require_once(SF_ROOT_DIR.DIRECTORY_SEPARATOR.'apps'.DIRECTORY_SEPARATOR.SF_APP.DIRECTORY_SEPARATOR.'config'.DIRECTORY_SEPARATOR.'config.php');
    
    sfContext::getInstance()->getController()->dispatch();
    
    ?>

`askeet/apps/frontend/confg/settings.yml`を開き、次の行を追加して下さい:

    staging:
      .settings:
        web_debug:              on
        cache:                  on
        no_script_name:         off

これでお終いです。デバッグとアクティベイトされたキャッシュを伴ったステージング環境がリクエストによって使用される準備が整いました:

    http://askeet/frontend_staging.php/

### テンプレートフラグメントをキャッシュに保存する

askeetページの多くはダイナミックな要素から構成されているので、(例えば、質問の記述はもしユーザが表示しているものがすでにクリックされた場合、シンプルなテキストに変わるであろう'interested?'リンクを含みます。)私達のアクションにおいて`slot`タイプのキャッシュの候補がありません。しかし、例えば、特定の質問のタグリストのように、テンプレートのチャンクをキャッシュすることができます。これはポピュラータグクラウドよりもトリッキーです。ユーザがタグをこの質問に追加するたびにこのチャンクのキャッシュをクリアしなければならないからです。しかし心配しないで下さい。symfonyは取り扱いを簡単にします。

改善を測定するために、`question/show`ページの現在の平均的なローディングタイムを知っておく必要があります。

    $ ab -c 1 -n 30 http://askeet/question/what-can-i-offer-to-my-step-mother

最初に、質問のためのタグリストは二つのバージョンを持ちます: 一つは未登録なユーザ(タグクラウド)のため、もう一つは登録ユーザのためです。(ユーザ自身によって入力されたデリートリンクを伴いタグリストです。)未登録ユーザのためのタグクラウドだけをキャッシュすることができます。(他はダイナミックです。)`tag_quesiton_tags`テンプレート部分に設置されます。`askeet/frontend/modules/tag/templates/_quesiton_tags.php`を開き、特別な`if(!cache())`ステートメントをキャッシュしなければならないフラグメントを含みます:

    [php]
    ...
    <?php if ($sf_user->isAuthenticated()): ?>
    ...
    <?php else: ?>
      <?php if (!cache('question_tags', 3600)): ?>
        <?php include_partial('tag/tag_cloud', array('tags' => QuestionTagPeer::getPopularTagsFor($question))) ?>
        <?php cache_save() ?>
      <?php endif ?>
    <?php endif ?>

`if(!cache())`ステートメントはエンクローズされたフラグメントのバージョン(`fragment_question_tags.cache`を呼びます)が既にキャッシュに存在しているか、一時間(3600秒)以上古くなっていないかをチェックします。この場合、キャッシュバージョンは使用され、`if(!cache())`と`endif`の間のコードは実行されません。そうでなければ、コードが実行され、`cache_save()`によってその結果がフラグメントファイルに保存されます:

フラグメントキャッシュによりパフォーマンスの改善を見せて下さい:

    $ ab -c 1 -n 30 http://askeet/question/what-can-i-offer-to-my-step-mother
   
もちろん、改善は`slot`タイプと同じぐらい重要ではありませんが、たくさんの小さな最適を行うことはあなたのアプリケーションに目に見えるほどの強化をもたらします。

>**Caution**:  当初は`sidebar/question`アクションによって呼び出されたとしても、キャッシュフラグメントファイルは`cache/frontend/template/askeet/question/what-can-i-offer-to-my-step-mother/fragment_question_tags.cache`に設置されます。コードのスロットが呼び出されたメインアクションに依存するからです。

### キャッシュの選択的な部分をクリアする

質問のタグリストはフラグメントのライフタイムの範囲以内で変わることがあります。ユーザが質問へのタグを追加もしくは削除をするたびに、タグリストは変わります。このことは関連アクションがフラグメントのためにキャッシュをクリアすることができるということを意味します。`viewCacheManager`オブジェクトの`->remove()`メソッドによって可能です。

それぞれの最終行に`tag`モジュールのアクションの`add`と`delete`を修正して下さい:

    [php]
    // キャッシュ内の質問のタグリストのフラグメントをクリアする
    $this->getContext()->getViewCacheManager()->remove('@question?stripped_title='.$this->question->getStrippedTitle(), 'fragment_question_tags');

タグリストフラグメントキャッシュが質問からタグを追加もしくは削除すること、すぐに適切にアップデートされたリストのタグをみることで表示されたページに非コーヒレンスを作成しないかどうかをチェックすることができます。

どちらのページ部分がキャッシュにあるのか見るために、開発環境のキャッシュを有効にすることができます。`settings.yml`設定ファイルを変更して下さい:

    dev:
      .settings:
        cache:                  on

これで、ページ、フラグメント、もしくはスロットが既にキャッシュされているか見ることが出来ます:

![キャッシュ内のフラグメント](/images/askeet/fragment_cache.gif)

もしくはフレッシュなコピーの時です:

![キャッシュ内のフラグメント](/images/askeet/fragment_no_cache.gif)

それではまた明日
----------------

symfonyは高いレベルのオーバーヘッドを作りませんし、Webアプリケーションのパフォーマンスを適切に調節する簡単な方法を提供します。 キャッシュシステムはパワフルで順応性が高いです。 もう一度、このチュートリアルのいくつかの部分がまだはっきりしていなかったら、symfony bookの[キャッシュの章](http://www.symfony-project.com/book/1_0/12-Caching)を躊躇せずに参照して下さい。 とても詳細で新しい例題がたくさんあります。

明日は、Webサイトのアクティビティのマネジメントについて考えることを始めます。 半匿名の書き込みを開いたときにスパムからの防衛、誤った記入項目の訂正はWebサイトに必要な機能です。 そのためにaskeetのバックオフィスを作るか、ある特定のプロファイルのユーザに新しいオプションセットへのアクセス件を与えて下さい。 ともかく、symfonyで開発するのであれば一時間もかからないです。

[フォーラム](http://www.symfony-project.com/forum/index.php/f/8/)に訪問するか、バグレポート、バージョンの詳細、wikiの変更などを見ることが出来る[askeetのタイムライン](http://trac.askeet.com/trac/timeline)を見るかで最新の[askeet](http://www.askeet.com/)のニュースを確かめておいて下さい。