symfony アドベントカレンダー 20日目: アドミニストレーションとモデレーション
===========================================================================

復習
----

初期のリリース以前よりも我々がパフォーマンスに関心があったおかげで、 askeetのサービスは悪いことが起きることなく、期待どおりに動いています。 しかし、より大きな問題があります: だれからも投稿できるアプリケーションを公開しておくと、スパム、過剰、もしくはエラーに晒されています。askeetのようなすべてのサービスはパブリケーション、手動によるデータベースへのアクセスを必要とすることは確実にバッドソリューションです。バックエンドアプリケーションをaskeetに追加した方がいいのでしょうか？

アドベント　カレンダー　チュートリアルはアジャイルメソッドを利用したWebアプリケーションの開発についてお話をします。 しかしながら、今まで、コーディングのことを多く説明したが、アプリケーションの開発とクライアントのリクエストの関係、埋め込まれた機能についてはあまり話しませんでした。 アジャイル開発のコーディングの前にバックエンドの必要性を説明するよい機会です。

期待された結果:クライアントが言っていること
-------------------------------------------

今日の仕事はいくつかの新しいアクションで構成されます。新しいテンプレートと新しいモデルメソッドと私達は既にどのようにするのかを知っています。最も難しい部分はおそらく、何が必要で、どこに設置すればよいのかを定義することです。機能とユーザビリティの両方に関連します。たまには開発者がコードよりも何かに集中した方がよいことです。

[エクストリームプログラミング(XP)の方法論](http://www.extremeprogramming.org/what.html)のタスクの一つを説明する機会があります: ストーリーを書くことと開発者がストーリーを機能に変換しなければならない仕事です。XPはアジャイル開発アプローチのベストの一つで、askeetのようにWeb2.0プロジェクトに対していつも当てはまります。

### ストーリー

XPにおいて、ストーリーはユーザがアプリケーションの反応を引き起こす方法の身近い説明です。ストーリーはウェブサイトのクライアントによって書かれます。(ウェブはすべてオープンソースではないので、結局のところ、割に合います。ストーリーはまれに一つか二つのセンテンスを越えます。それらはテーマで再グループ化されます。

一般的にストーリーはユーザケースよりもより説明が少なく、より基礎的です。UMLに慣れ親しんでいらっしゃるのでしたら、簡潔ではないストーリーを見つけるかもしれませんが、大きなチャンスであることをすぐにわかるでしょう。

ストーリーはインプレメテーションディーテルではなくアクションの結果に焦点をあてます。もちろん、クライアントはインタフェースに関する選択を持つでしょうし、この場合、ストーリーとヒューマンコンピューターインターアクションのルック&ィールについての要求と推奨を含まなければなりません。

開発期間において開発者によって簡単に評価されるためにストーリーは小さくなければなりません。通常は、エクストリームプログラマーのチームはストーリーをユニットで測定します。ユニットの値はプロジェクトのコースを通して、洗練されます。

どのようにaskeetのバックエンドでクライアントが要求を再定義するのか見てみましょう。

### ストーリー #1: プロファイルマネジメント

すべてのユーザはモデレータになることを求めることができます。 ユーザプロファイルページにおいて、この特権を求めるためにリンクは利用可能になります。モデレータになることを求めた人は回答を受け取るまで、再びモデレータになることを求めることはできません。

モデレータ候補者を受諾する、もしくは拒否した権限を与えられた人は管理者です。彼は候補者リストをブラウザしなければなりません。各人のモデレータのグレードを与える、拒否するボタンがなければなりません。彼らの貢献が正しいか管理者は候補者のプロファイルへのリンクを持つことが必要です。

モデレータに権限を与えることは可逆可能なアクションでなければなりません。管理者はモデレータのリストをブラウズできるようにしなければなりません。お互いに、モデレータの資格を削除するためです。

管理者は他のユーザにも管理者権限を与えることが可能です。彼らは管理者リストにアクセスする権限を持ちます。

### ストーリー #2: 問題のある質問もしくは回答のレポート

すべてのユーザは問題のある質問や回答をモデレータに報告することが出来なければなりません。すべての質問もしくは回答のボタンのシンプルな 'report spam 'ボタンへのリンクはよい解決方法です。

リポートのスパムを避けるために、特定の質問もしくは回答へのユーザからのリポートは一回だけカウントされるようにします。ユーザのリポートが考慮に入れられるという事実についてユーザが視覚的なフィードバックをできるということは素晴らしいことです。

### ストーリー #3: 問題のある質問・回答の取り扱い

モデレータは2つ以上のリストが利用可能です: 問題のある質問リストと回答リストです。それぞれのリストはリポート数の多い順に並び替えられます。なので多くの報告された質問は報告された質問リストのトップに現れます。

モデレータは質問を削除する、回答を削除する、どちらのリポートの数をリセットするという能力を持ちます。質問の削除はこの質問へのすべての回答の削除を起こします。

### ストーリー #4: 問題のあるタグの取り扱い

モデレータは彼ら、もしくはそうではない人によってタグが与えられたであろうと、質問へのタグを削除する能力を持ちます。

問題のあるタグ、例えば意味をなさないもの、を検知するためにモデレータは人気の逆順で並べられたタグリストにアクセスする権限をもちます。このタグによってタグ付けされた質問リストをリンクすることでリストはタグを隠す能力があります。

### ストーリー #4: 問題のあるユーザの取り扱い

モデレータがユーザの寄稿を削除するとき、このユーザによって投稿された問題のある寄稿のナンバーが増加します。

削除された問題のある投稿の数によって並べれられた問題ユーザのリストを持ちます。管理者はユーザとそのユーザのすべての寄稿を削除する能力がなければなりません。

### すべてですか？

はいそうです。askeetのサイトマネジメントのためにクライアントが必要な要求定義はこれで全部です。機能の仕様のすべてのケースをカバーしないですし、ユーズケースの完全なセットとして完全ではありませんし、望まない結果を導くかもしれないたくさんのオープンエンドを残しています。

しかし、今始めたアジャイルな開発の仕事はストーリーがもっと正確でなければならないことが判明したとき、ありうる曖昧さとデータの欠落を検知すること、クライアントのアシストを要求することです。XPスタイルの開発フェーズにおいてクライアントは開発チームの質問へ回答することが常に可能です。

ですので、開発者はペアを組み、それぞれのペアで取り組むストーリーを選択します。ストーリーが何を意図するのかを語り、ユニットテストケースは機能を検証します。ユニットテストを書きます。それから、テストをパスするコードを書きます。終わったら、全体のアプリケーションに追加するコードをリリースし、以前書いたすべてのユニットテストを動作させることで、統合を検証します。動作したとき、休憩をし、解散します。それから他の人と新しいペアを形成し、新しいストーリーに焦点を当てます。

最後の結果がクライアントの要望を満たさないのであればどうします？少しの仕事のユニット(数時間もしくは数日)を代表しているだけで、 忘れて新しいアプローチを試すのは簡単です。少なくも、クライアントは彼または彼女が望んでいないことがわかるので、決定論への大きなステップです。しかし、大抵の時間、開発者がクライアントと直接話す機会が与えられ、書かれたストーリーの行間を読むときに、クライアントが期待した以上のベターな方法で機能を生み出すことに取りかかります。加えて、AJAXの可能性とWeb2.0について知っている開発者は成功することが出来ます。素晴らしいアプリケーションで終わるためにイニシアティブを与えることはよいチャンスです。

XPとアジャイル開発の恩恵について興味を持ちましたら、[エクストリームプログラミングウェブサイト](http://www.extremeprogramming.org/)かエクストリーム・プログラミングの説明を読んで下さい: 「Embrace Change」(ケント・ベック)

バックエンド VS 強化されたフロントエンド
----------------------------------------

クライアントへの要求についての開発者のフィードバックはアプリケーションの質のために重大です。開発者が、アプリケーションがどのようにして構築され、どれだけsymfonyがパワフルなのかをどのようにクライアントへ説明できるのか見てみましょう。

askeetにバックエンドのアプリケーションを追加するアイディアはいくつかの理由からよいものではありません。

最初に、多くの機能を必要とするバックエンドを使用するモデレータはすでにフロントエンドで利用可能です。(最新の質問、ログインモジュールなど)バックエンドアプリケーションはフロントエンドの部分をリピートすることはリスクです。私達自身を繰り返すことは好まないので、そのことはクロスアプリケーションリファクタリングを示します。また、長い時間がかかりすぎます。第二に、新しいアプリケーションはおそらく、カスタムレイアウトとスタイルシートを用いてサイトへの新しいデザインを意味します。アプリケーション開発において、もっとも時間がかかることです。最後に、一時間でバックエンドのアプリケーションを作成するためにはおそらく私達はCRUDジェネレータをたくさん使わなければなりません。結果として多くの不必要なアクションと適応するのに時間がかかるテンプレートが作成されてしまいます。

近い将来に(0.6のために計画されました)、symfonyはフル機能のバックオフィスジェネレータを提供します。ウェブサイトの活動を管理するために共通で必要とされたすべての機能を簡単に取り扱われ、ほとんど一行のコードも必要がありません。この見事な追加はaskeetのバックエンドを構築するための方法について、私達のマインドを変えるでしょう。しかし、フレームワークの現在の状態を考慮すると、マネジメント機能のためのベストソリューションはフロントエンドアプリケーションに追加することです。

askeetフロントエンドのベースはリストのセットで、質問とユーザのための詳細ページで、ある種のアクションが利用可能です。まさにこれはサイトマネジメントの機能を補強するために必要なスケルトンです。

しかしながら、プロジェクトがどのようにして一つ以上のアプリケーション、このデモンストレーションによって印象を受けたクライアントを含むのかについて役立つのですが、フロントエンドのアプリケーションにおいてサイトマネジメント機能の統合を目指して下さい。

>**Caution**: symfonyプロジェクトが動作している複数のアプリケーションについて興味がまだおありでしたら、[マイファーストプロジェクト](http://www.symfony-project.com/tutorial/my_first_project.html) チュートリアルを見て下さい。

機能性: 開発者が理解すること
----------------------------

開発者が会い、ストーリーについてクライアントと話したあとで、askeetアプリケーションに対して行われ修正を推定します。開発者はストーリーをタスクに変化させます。タスクは通常ストーリーより小さいです。タスクは通常1もしくは2タイムユニット範囲内に開発されます一方でストーリーを実行するには1日もしくは2日以上の期間が必要だからです。

1. モデルは効果的なリクエストを可能するために修正されなければなりません:
    * `question_id`、`user_id`、`created_at`カラムによって新しい`ReportQuestion`テーブルを作成します
    * `question_id`と`user_id`と`created_at`カラムによって新しい`ReportAnswer`テーブルを作成します
    * 新しい`reports`カラムは`Question`と`Answer`カラムに追加します
    * 新しい`is_administrator`、`is_moderator`と`deletions`カラムを`User`テーブルに追加します

2.  すべてのページで、サイドバーはユーザの認証に従って新しいリストへのアクセスを提供しなければなりません:
    * すべてのユーザ: 人気の質問、最新の質問、最新の回答
    * モデレータ: レポートされた質問、レポートされた回答、不人気なタグ 
    * 管理者: 管理者、モデレータ、モデレータ候補、問題のあるユーザ
    
3.   詳細な質問ページ(`question/show`)はユーザの資格に従って、新しいアクションを提供しなければなりません:
    * サブスクライバ: 質問をリポートする、回答をリポートする
    * モデレータ: 質問と回答を削除する、回答を削除する、質問リポートをリセットする、回答をリポートする、タグを削除する

    質問はユーザの資格に従って、追加的な情報を与えられなければなりません: 
    * サブスクライバ: サブスクライバによって既に報告された質問がある場合
    * モデレータ: 質問と回答についてのレポート数
    
4.  ユーザプロファイルページ(`user/show`)はユーザの資格に応じてアクセスを提供する必要がある:
    * サブスクライバ自身のページ: モデレータ候補者として名乗り出る
    * 管理者: ユーザとすべての寄稿を削除する、モデレータの資格を与える、モデレータの資格を拒否する、モデレータの資格を削除する、管理者の資格を与える
    
    ユーザプロファイルページはユーザの資格に応じて、追加情報を与えることが必要です:
    * すべてのユーザ: ユーザの資格、適応された資格
    * 管理者: 削除した投稿数

5.  制限されたアクセスによる新しいリストが作成されなければなりません:
    * モデレータへの制限:
        * `quesition/reports`: リポートされた質問リスト、リポート数の降順で、それぞれがquesition detailにリンクしている。
        * `answer/reports`: リポートされた回答リスト、リポート数の降順で、それぞれがquesiton detailにリンクされている
        * `tag/unpopular`: タグのリスト、人気順で、それぞれが、このタグによってタグ付けされた質問リストへリンクしている
    * 管理者への制限
        * `user/administrators`: 管理者のリスト、アルファベット順で、それぞれがユーザプロファイルにリンクしている
        * `user/moderators`: モデレータのリスト、アルファベット順で、それぞれがユーザプロファイルにリンクしている
        * `user/candidates`: モデレータ候補のリスト、アルファベット順で、それぞれがユーザプロファイルにリンクしている
        * `user/problematic`: 問題のあるユーザのリスト、削除された寄稿の降順で、それぞれがユーザプロファイルにリンクしている

6.  ２つの新しい資格が作成されなければなりません: 管理者とモデレータ。
    
7.  少なくとも、一つの管理者がアプリーションが動くように、手動でデータベースをセットアップしなければなりません。

実装
----

タスクリストが書かれたら、symfonyでaskeetにバックエンド機能を埋め込むための方法は仕事の問題です。XP方法論をこのタスクに適応すること、ユニットテストを書くことを含む、少なくとも、仕事のよい日を必要とします。アドベントカレンダーチュートリアルの必要のために、私達は少し速く、そして、以前説明されなかった新しいテクニックもしくはクラシカルなsymfonyのテクニックを再検討することを手助けするテクニックについてについて焦点を当てることにします。

### 新しいテーブル

質問と回答レポートのために、私達はaskeetに2つのテーブルを追加します:

    [xml]
    <table name="ask_report_question" phpName="ReportQuestion">
      <column name="question_id" type="integer" primaryKey="true" />
      <foreign-key foreignTable="ask_question">
        <reference local="question_id" foreign="id" />
      </foreign-key>
      <column name="user_id" type="integer" primaryKey="true" />
      <foreign-key foreignTable="ask_user">
        <reference local="user_id" foreign="id" />
      </foreign-key>
      <column name="created_at" type="timestamp" />
    </table>
    
    <table name="ask_report_answer" phpName="ReportAnswer">
      <column name="answer_id" type="integer" primaryKey="true" />
      <foreign-key foreignTable="ask_answer">
        <reference local="answer_id" foreign="id" />
      </foreign-key>
      <column name="user_id" type="integer" primaryKey="true" />
      <foreign-key foreignTable="ask_user">
        <reference local="user_id" foreign="id" />
      </foreign-key>
      <column name="created_at" type="timestamp" />
    </table>

`question_id/answer_ind`と`user id`の組み合わせはユニークな主キーを作成するのに十分で、これらのテーブルのためのオートインクリメントの`id`を追加する必要はありません。

私達は新しい`reports`カラムを`Quesiton`と`Answer`テーブルに追加します。`reports`の数と`Question`テーブルに`ReportQuestion`にレコード数を同期するために私達が[4日目](4.txt)に行ったように、トランザクションを追加する`ReportQuestion`オブジェクトの`save()`メソッドをオーバーライドします:

    [php]
    public function save($con = null)
    {
      $con = sfContext::getInstance()->getDatabaseConnection('propel');
      try
      {
        $con->begin();
    
        $ret = parent::save();
    
        // answerテーブルのspam_countを更新する
        $answer = $this->getAnswer();
        $answer->setReports($answer->getReports() + 1);
        $answer->save();
    
        $con->commit();
    
        return $ret;
      }
      catch (Exception $e)
      {
        $con->rollback();
        throw $e;
      }
    }

`ReportAnswer`テーブルについても同じです。

### カスケード削除

質問が削除されたとき、この質問へのすべての回答も削除されます。質問に関する興味、、質問に追加されたタグ、すべての回答についての関連レーティングも同様です。私達のためのすべてのことを管理するためにカスケード削除のメカニズムが必要です。

[2日目](2.txt)において、askeetのデータベース用にInnoDBを使うアイディアがありました。これはカスケード削除を円滑にします。しかし、カスケード削除が考慮されなければならないことをスキーマで示していれば、PropelのレイヤはInnoDBが有効でないデータベース上でもカスケード削除を何とか行うことができます。これは外部キーを宣言するときに行われなければなりません: テーブルの定義内で`onDelete="cascade"`属性を`<foreign-key>`タグに追加します。例えば、`Answer`テーブルに対しての場合:

    [xml]
    ...
    <table name="ask_answer" phpName="Answer">
      <column name="id" type="integer" required="true" primaryKey="true" autoIncrement="true" />
      <column name="question_id" type="integer" />
      <foreign-key foreignTable="ask_question" onDelete="cascade">
        <reference local="question_id" foreign="id"/>
      </foreign-key>
      <column name="user_id" type="integer" />
      <foreign-key foreignTable="ask_user">
        <reference local="user_id" foreign="id"/>
      </foreign-key>
      <column name="body" type="longvarchar" />
      <column name="html_body" type="longvarchar" />
      <column name="relevancy_up" type="integer" default="0" />
      <column name="relevancy_down" type="integer" default="0" />
      <column name="reports" type="integer" default="0" />
      <column name="created_at" type="timestamp" />
    </table>
    ...

ひとたび、モデルが再構築されると、カスケード削除は`onDelete`属性に関連したリレーションに対して有効になります。Questionテーブルでレコードを削除したときです:

* もしデータベースがInnoDBエンジンを使う場合、関連した回答は自動的に削除されます
* そうではない場合、Propelレイヤーは自動的に関連した回答を取得して、それらを削除し、そして質問を削除します。

すべてのリレーションはカスケード削除を含まないかもしれません。例えば、ユーザを削除することは彼もしくは彼女の興味と回答の関連へのレーティングを消すことになりますが、投稿(質問と回答)は削除しません。これらの投稿は削除の後で匿名ユーザに関連付けされます。

`onDelete`属性は次のリレーションのために`cascade`が設定されなければなりません:

  * `Answer/QuestionId`
  * `Interest/QuestionId`
  * `Relevancy/QuestionId`
  * `QuestionTag/QuestionId`
  * `ReportQuestion/QuestionId`
  * `ReportAnswer/AnswerId`

### クレデンシャルを持つユーザのためにリンクをサイドバーに追加する

すべてのモデレータアクションを処理する新しい`moderator`モジュール、および管理者のアクションを処理する`administrator`モジュールを作成します。

[7日目](7.txt)において、`sidebar`モジュールにおいてサイドバーのコードを貯蔵するコンポーネントスロットテクニックを使いました。新しいリストへのリンクはそこに現れますが、それらは資格によって調整されます。[6日目](6.txt)で見たように`$sf_user->hasCredential()`メソッドを使用することでシンプルに行われます:

    [php]
    // in askeet/apps/frontend/modules/sidebar/templates/_default.php and _question.php:
    ...
    <?php include_partial('sidebar/moderation') ?>

    <?php include_partial('sidebar/administration') ?>
    
    // in askeet/apps/frontend/modules/sidebar/templates/_moderation.php:
    <?php if ($sf_user->hasCredential('moderator')): ?>
      <h2>moderation</h2>
    
      <ul>
        <li><?php echo link_to('reported questions', 'moderator/reportedQuestions') ?> (<?php echo QuestionPeer::getReportCount() ?>)</li>
        <li><?php echo link_to('reported answers', 'moderator/reportedAnswers') ?> (<?php echo AnswerPeer::getReportCount() ?>)</li>
        <li><?php echo link_to('unpopular tags', 'moderator/unpopularTags') ?></li>
      </ul>
    <?php endif ?>
    
    // in askeet/apps/frontend/modules/sidebar/templates/_administration.php:
    ...
    <?php if ($sf_user->hasCredential('administrator')): ?>
      <h2>administration</h2>
    
      <ul>
        <li><?php echo link_to('moderator candidates', 'administrator/moderatorCandidates') ?> (<?php echo UserPeer::getModeratorCandidatesCount() ?>)</li>
        <li><?php echo link_to('moderator list', 'administrator/moderators') ?></li>
        <li><?php echo link_to('administrator list', 'administrator/administrators') ?></li>
        <li><?php echo link_to('problematic users', 'administrator/problematicUsers') ?> (<?php echo UserPeer::getProblematicUsersCount() ?>)</li>
      </ul>
    <?php endif ?>    

![新しいリンク](/images/askeet/moderation_links.gif)

クラスメソッドの`QuestionPeer::getReportCount()`、`AnswerPeer::getReportCount()`、`UserPeer::getModeratorCandidatesCournt()`と`UserPeer::getProblematicUsersCount()`はモデルに追加されます。これらはすべて同じ原則に基づいています:

    [php]
    public static function getReportCount()
    {
      $c = new Criteria();
      $c->add(self::REPORTS, 0, Criteria::GREATER_THAN);
      $c = self::addPermanentTagToCriteria($c);
  
      return self::doCount($c);
    }

### AJAXレポート

質問が表示されたすべての場所に質問を報告するための質問'[モデレータへのレポート]'リンクを提供します。(質問リスト、質問の詳細ページ)[8日目](8.txt)のチュートリアルのように、このリンクがAJAXであるなら素敵でしょう。ですので、新しいヘルパに`askeet/apps/frontend/lib/helper/`ディレクトリの`QuestionHelper.php`ファイルに追加します:

    [php]
    function link_to_report_question($question, $user)
    {
      use_helper('Javascript');
    
      $text = '[report to moderator]';
      if ($user->isAuthenticated())
      {
        $has_already_reported_question = ReportQuestionPeer::retrieveByPk($question->getId(), $user->getSubscriberId());
        if ($has_already_reported_question)
        {
          // このユーザに対して既に報告された場合
          return '[reported]';
        }
        else
        {
          return link_to_remote($text, array(
            'url'      => '@user_report_question?id='.$question->getId(),
            'update'   => array('success' => 'report_question_'.$question->getId()),
            'loading'  => "Element.show('indicator')",
            'complete' => "Element.hide('indicator');".visual_effect('highlight', 'report_question_'.$question->getId()),
          ));
        }
      }
      else
      {
        return link_to_login($text);
      }
    }
    
リンクが現れなければならないテンプレート(`question/templates/showSuccess.php`と`question/templates/_list.php`)はこのヘルパを使うことができます:

    [php]
    <div class="options" id="report_question_<?php echo $question->getId() ?>">
      <?php echo link_to_report_question($question, $sf_user) ?>
    </div>

`@user_report_question`ルールは`user/reportQuestion`アクションにロードするものとして`routing.yml`に書かれなければなりません:

    [php]
    public function executeReportQuestion()
    {
      $this->question = QuestionPeer::retrieveByPk($this->getRequestParameter('id'));
      $this->forward404Unless($this->question);
    
      $spam = new ReportQuestion();
      $spam->setQuestionId($this->question->getId());
      $spam->setUserId($this->getUser()->getSubscriberId());
      $spam->save();
    }
    
このアクションの結果である`user/templates/reportQuestionSuccess.php`テンプレートはシンプルです:

    [php]
    <?php use_helper('Question') ?>
    <?php echo link_to_report_question($question, $sf_user) ?>

![質問レポート](/images/askeet/report_question.gif)

報告された回答についても同じです。
    
### クレデンシャルを持つユーザのための新しいアクションリンク

`askeet/apps/frontend/modukes/quesiton/templates/showSuccess.php`の divタグの`question_body`において、AJAXリポート対応にするために、モデレータだけのために質問管理のアクションを追加します。これらをフラグメントに追加します:

    [php]
    ...
    <div class="options" id="report_question_<?php echo $question->getId() ?>">
      <?php echo link_to_report_question($question, $sf_user) ?>
      <?php include_partial('moderator/question_options', array('question' => $question)) ?>
    </div>

`askeet/apps/frontend/modules/moderator/templates/_question_options.php`フラグメントは次のコードを含みます:

    <?php if ($sf_user->hasCredential('moderator')): ?>
      <?php if ($question->getReports()): ?>
        &nbsp;[<strong><?php echo $question->getReports() ?></strong> reports]
        &nbsp;<?php echo link_to('[reset reports]', 'moderator/resetQuestionReports?stripped_title='.$question->getStrippedTitle()) ?>
      <?php endif ?>
      &nbsp;<?php echo link_to('[delete question]', 'moderator/deleteQuestion?stripped_title='.$question->getStrippedTitle()) ?>
    <?php endif ?>
    ...

![モデレータのアクション](/images/askeet/question_moderator_options.gif)

同じオプションが`askett/apps/frontend/modules/answer/templates/_answer.php`に追加されます。`moderator/templates/_answer/templates/_answer_options.php`フラグメントへのリンクです。

ユーザプロファイルの管理アクションリンクに同じ種類のことが適用されます。

>**Note**: アクションへのリンクについてのグッドプラクティスはアクションがモデルを修正しなかったときは、通常のリンクとして、('GET'リクエストを行いながら)アクションがデータを変えるときはボタンとして埋め込むことです。( 'POST'をしながら)サーチエンジンのロボットのように自動化したウェブクローラーを避ける方法です、修正できるデータベースをリンクをクリックして下さい。JavaScriptに埋め込まれていないAJAXリンクであることで、ロボットによってクリックされることはありません。いましがた追加した 'reset'と 'report'リンクは、しかしながらロボットによってクリック可能です。幸運にも、ユーザがモデレータにアクセスにしない限り、表示されません。意図せずにクリックされるというリスクはありません。
>
>'POST'リンクとして宣言することでこれらのリンクへの付加的なプロテクションを追加できます。symfonyブックの[リンクの章](http://www.symfony-project.com/book/1_0/09-Links-and-the-Routing-System)に記述されています:
>
>      [php]
>      <?php echo link_to('[delete answer]', 'moderator/deleteAnswer?id='.$answer->getId(), 'post=true') ?>
>

### アクセス制限

ユーザが特別な権限を持ってログインしたとき、`sfUser`オブジェクトは適切な資格が与えられなければなりません。[6日目](6.txt)において作成した`askeet/apps/frontend/lib/myUser.class.php`で`myUser`クラスの`signIn`メソッドで行われます:

    [php]
    public function signIn($user)
    {
      $this->setAttribute('subscriber_id', $user->getId(), 'subscriber');
      $this->setAuthenticated(true);
    
      $this->addCredential('subscriber');
    
      if ($user->getIsModerator())
      {
        $this->addCredential('moderator');
      }
    
      if ($user->getIsAdministrator())
      {
        $this->addCredential('administrator');
      }
    
      $this->setAttribute('nickname', $user->getNickname(), 'subscriber');
    }

もちろん、すべてのモデレータアクションは`askeet/apps/frontend/modules/moderator/config/security.yml`にある適切な設定によって制限されなければなりません:

    all:
      is_secure:   on
      credentials: moderator

同じ種類の制限は管理者アクションについても当てはまります。

### 新しいmoderatorとadministratorアクション

`moderator`と`administrator`アクションに新しく追加されるものはありません。リストを知って頂くためにここに示します:

    // administratorのアクション
    executeProblematicUsers()     ->  usersSuccess.php
    executeModerators()           ->  usersSuccess.php
    executeAdministrators()       ->  usersSuccess.php
    executeModeratorCandidates()  ->  usersSuccess.php
    
    executePromoteModerator()     ->  request referrer
    executeRemoveModerator()      ->  request referrer
    executePromoteAdministrator() ->  request referrer
    executeRemoveAdministrator()  ->  request referrer
    
    // moderatorのアクション
    executeUnpopularTags()        ->  unpopularTagsSuccess.php
    executeReportedQuestions()    ->  reportedQuestions.php
    executeReportedAnswers()      ->  reportedAnswers.php
    
    executeDeleteTag()            ->  request referrer
    executeDeleteQuestion()       ->  @homepage
    executeDeleteAnswer()         ->  request referrer
    
>**Note**: アクションのためのカスタムテンプレートを指定するために、`view.yml`設定ファイルをモジュールに追加します。例えば、半分の`administrator`アクションが`usersSuccess.php`テンプレートを使えるようにするために、次の`askeet/apps/frontend/modules/administrator/config/view.yml`ファイルを作成します:
>
>     moderatorsSuccess:
>       template: users
>     
>     administratorsSuccess:
>       template: users
>     
>     moderatorCandidatesSuccess:
>       template: users
>     
>     problematicUsersSuccess:
>       template: users
> 

### ログ削除

モデレータが質問を削除したとき、警告メッセージとログファイルで削除のトレースをしたいです本番環境において警告メッセージのロギングを許可するために、私達は`logging.yml`設定ファイルを修正する必要があります:

    prod:
      level: warning    
    
それから、すべての削除アクションにおいて、`moderator/deleteQuestion`アクションとして削除を記録するコードを追加します:

    [php]
    public function executeDeleteQuestion()
    {
      $question = QuestionPeer::getQuestionFromTitle($this->getRequestParameter('stripped_title'));
      $this->forward404Unless($question);
  
      $con = sfContext::getInstance()->getDatabaseConnection('propel');
      try
      {
        $con->begin();
  
        $user = $question->getUser();
        $user->setDeletions($user->getDeletions() + 1);
        $user->save();
  
        $question->delete();
  
        $con->commit();
  
        // 削除を記録する
        $log = 'moderator "%s" deleted question "%s"';
        $log = sprintf($log, $this->getUser()->getNickname(), $question->getTitle());
        $this->getContext()->getLogger()->warning($log);
      }
      catch (PropelException $e)
      {
        $con->rollback();
        throw $e;
      }
  
      $this->redirect('@homepage');
    }

ロギングについて、もっと知りたいのであれば、symfonyブックの[デバッグの章](http://www.symfony-project.com/book/1_0/16-Application-Management-Tools)を見て下さい。

すべての`Exceptions`の代わりに、`PropelExceptions`のみに反応する`try/catch`ステートメントを変更します。これは削除のロギングに問題があるというだけでトランザクションが失敗して欲しくないからです。

>**Note**: 上の例の場合、削除されたあとでも`$question`オブジェクトを使用します。これは`->delete()`メソッドへのコールはレコードもしくは削除のためのレコードリストをマークするからで、実際の削除は一旦アクションが終了したとき、Propelによってのみ続行されます。

それではまた明日
----------------

バックエンド機能を埋め込む方法がたくさんあるので、考えることに幾分か時間を取りました。今日のチュートリアルはおそらくは一時間だけでなく2時間ぐらいかかったでしょう。しかし、多くのことは新しいことではなく、埋め込みはsymfonyテクニックの復習になったでしょう。 [askeetのタイムライン](http://trac.askeet.com/trac/changeset/55)で変更の全体のリストをよく見ることが出来ます。

明日は謎の機能の日です。多くの提案がフォーラムやaskeetのベータサイトにまで送られていきました。 私達が埋め込むことを決めたものを見、symfonyが多いに助けになるのかということを理解します。

今日のソースについて何か問題がありましたら、お気軽に[フォーラム](http://www.symfony-project.com/forum/index.php/f/8/)に行って下さい。 ソースコードは[trac](http://trac.askeet.com/trac/browser/tags/release_day_20)内か[SVNリポジトリ](http://svn.askeet.com/tags/release_day_14/)からダウンロードすることができます。