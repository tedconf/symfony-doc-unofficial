17日目: API
===========

復習
----

[昨日](16.txt)、askeetアプリケーションは[オンライン](http://www.askeet.com) に公開され、機能調節と追加についてたくさんのフィードバックを既に得ました。ユーザインプットはWeb2.0のアプリケーションのデザインのための基礎で、アプリケーションのコンセプトが新しいとしたら、可能な限り、実験的でなければなりません。

しかし、21日に計画されていない機能を追加します。 その前に、askeetを通して、進んだWebアプリケーション開発の一握りのテクニックをお見せします。今日お知らせするまず最初のことはHTTP認証を要求する外部APIのプログラミングです。

昨日、小さな変更をたくさん行ったので、askeetリポジトリから[17日](http://svn.askeet.com/tags/release_day_17/)とタグ付けされたバージョンのaskeetを新しくダウンロードして今日のチュートリアルを始めることをお勧めします。

API
---

アプリケーションプログラミングインタフェース([Application Programming Interface](http://en.wikipedia.org/wiki/Application_programming_interface))、または**API**はあなたのアプリケーション上の外部ウェブサイトを含むことが出来る特別なサービスのための開発者インタフェースです。 [Google Maps](http://www.google.com/apis/maps/)または[Flickr](http://www.flickr.com/services/api/response.rest.html)などはAPIのおかげでインターネット上での多くのウェブサイトを拡張するために使用されています。

askeetは例外を認めませんが、サービスの人気を高めるために、他のサイトで利用可能であるべきだということを信じます。[11日目](11.txt)に開発されたRSSフィードはその要求への最初のアプローチでしたが、私達はもっとよくすることができます。

askeetはユーザによる質問への回答のAPIを提供する予定です。このAPIのアクセスはHTTP認証を通したaskeetの登録ユーザに限定されます。選択されたAPIのレスポンスフォーマットは[Representational State Transfer](http://en.wikipedia.org/wiki/REST)もしくはRESTで、ウェブにおいてメインAPIの大抵の出力と類似したレスポンスはシンプルなXMLブロックです:

    [xml]
    <?xml version="1.0" encoding="utf-8" ?>
    <rsp stat="ok" version="1.0">
      <question href="http://www.askeet.com/question/what-shall-i-do-tonight-with-my-girlfriend" time="2005-11-21T21:19:18Z" >
        <title>What shall I do tonight with my girlfriend?</title>
        <tags>
          <tag>activities</tag>
          <tag>relatives</tag>
          <tag>girl</tag>
        <tags>
        <answers>
          <answer relevancy="50" time="2005-11-22T12:21:53Z">You can try to read her poetry. Chicks love that kind of things.</answer>
          <answer relevancy="0" time="2005-11-22T15:45:03Z">Don't bring her to a doughnuts shop. Ever. Girls don't like to be seen eating with their fingers - although it's nice.</answer>
        </answers>
      </question>
    </rsp>

`frontend`アプリケーションの新しいモジュールにAPIを埋め込みます。そこで、モジュールのスケルトンを構築するためにコマンドラインを使用します:

    $ symfony init-module frontend api

HTTPの認証
----------

APIの使用をaskeetの登録ユーザに制限することを選択しました。そのためには、HTTP認証プロセス、ビルトインのHTTPプロトコールの認証メカニズムを使用します。以前見たウェブ認証とは違います。なぜなら、ウェブページさえ要求しないからです。すべてのやりとりはHTTPヘッダに取って代わります。

[6日目](6.txt)においてカスタムバリデータを含む認証メソッドを必要としています。そこで最初に私達はリファクタリングとUserPeerモデルクラスのログインコードを再配置します:

    [php]
    public static function getAuthenticatedUser($login, $password)
    {
      $c = new Criteria();
      $c->add(UserPeer::NICKNAME, $login);
      $user = UserPeer::doSelectOne($c);

      // ニックネームが存在するか？
      if ($user)
      {
        // パスワードはOKか？
        if (sha1($user->getSalt().$password) == $user->getSha1Password())
        {
          return $user;
        }
      }

      return null;
    }

新しいクラスのメソッドである`UserPeer::getAutenticatedUser()`は`myLoginValidator.class.php`(お任せします)と新しい`api/index`ウェブサービスで使用されます:

    [php]
    <?php
    
    class apiActions extends sfActions
    {
      public function preExecute()
      {
        sfConfig::set('sf_web_debug', false);
      }

      public function executeIndex()
      {
        $user = $this->authenticateUser();
        if (!$user)
        {
          $this->error_code    = 1;
          $this->error_message = 'login failed';

          $this->forward('api', 'error');
        }
        // 何かを行います
      }

      private function authenticateUser()
      {
        if (isset($_SERVER['PHP_AUTH_USER']))
        {
          if ($user = UserPeer::getAuthenticatedUser($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW']))
          {
            $this->getContext()->getUser()->signIn($user);

            return $user;
          }
        }

        header('WWW-Authenticate: Basic realm="askeet API"');
        header('HTTP/1.0 401 Unauthorized');
      }

      public function executeError()
      {
      }
    }
    
    ?>

最初に、APIモジュール(`preExecute()`メソッド)のアクションの実行をする前に、ウェブデバッグツールバーをオフにします。XMLであるこのアクションのビュー、ツールバーコードの挿入は有効ではないレスポンスを発生させます。

`index`アクションが行う最初のことはログインとパスワードが提供されているかチェックし、askeetのアカウントと一致するかチェックをします。一致しない場合、`authenticateUser()`メソッドは '401 'のHTTPヘッダレスポンスを設定します。ユーザのブラウザにおいてポップアップするHTTP認証ウィンドウを呼び起こします; ユーザはログインとパスワードのリクエストを再投稿しなければなりません。

    // 認証無しで、最初のAPIへのリクエスト
    GET /api/index HTTP/1.1
    Host: mysite.example.com
    User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8) Gecko/20051111 Firefox/1.5
    Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
    ...  
    
    // APIは内容を伴わない401ヘッダを返す
    HTTP/1.x 401 Authorization Required
    Date: Thu, 15 Dec 2005 10:32:44 GMT
    Server: Apache
    WWW-Authenticate: Basic realm="Order Answers Feed"
    Content-Length: 401
    Keep-Alive: timeout=15, max=100
    Connection: Keep-Alive
    Content-Type: text/html; charset=iso-8859-1
    
    // ログインボックスがユーザのウィンドウ上に表示される
    // ユーザがログイン名/パスワードを入力すると、新しいGETがサーバに送られる
    GET /api/index HTTP/1.1
    Host: mysite.example.com
    User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; fr; rv:1.8) Gecko/20051111 Firefox/1.5
    Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5
    ...
    Authorization: Basic ZmFicG90OnN5bWZvbnk=

`Autorization`属性は再び送られたHTTPリクエストに追加されます。[base64](http://en.wikipedia.org/wiki/Base64)でエンコードされた 'login:password'の文字列を含みます。それが`authenticateUser()`メソッドにおいて`$_SERVER['PHP_AUTH_USER']`と`$_SERVER['PHP_AUTH_PW']`が探すものです。

>**Note**: base64はインプットの暗号化されたバージョンを出力しません。base64でエンコードされた文字列をデコードするのは[とても簡単](http://makcoder.sourceforge.net/demo/base64.php)で、パスワードを平文で漏らします。例えば `ZmFicG90OnN5bWZvbnk=`をデコードすると `fabpot:symfony`です。インターネット上での平文でのパスワードの転送(ウェブフォームに入力されたときなど)は傍受されることを考慮しなければなりません。この理由からHTTP認証は重要ではない内容とサービスに制限されなければなりません。追加されたプロテクションはAPIのコールと同様に、HTTPSプロトコルを要求することによってゲインされることができます。

ログオンとパスワードが提供され、ユーザのデータベースに存在するのであれば、`index`アクションが実行されます。さもなければ、`error`アクション(空)を転送し、`errorSuccess.php`テンプレートを表示します:

    [php]
    <?php echo '<?' ?>xml version="1.0" encoding="utf-8" ?>
    <rsp stat="fail" version="1.0">
      <err code="<?php echo $error_code ?>" msg="<?php echo $error_message ?>" />
    </rsp>

もちろん、`api`モジュールのすべてのビューををXMLcontent-typeに設定し、デコレータの動作を停止することが必要です。`askeet/apps/frontend/modules/api/config/`ディレクトリの`view.yml`によって行うことができます:

    all:
      has_layout: off
    
      http_metas:
        content-type: text/xml

>**Note**: `index`アクションがエラーの場合、`sfView::ERROR`の代わりに`forward('api', 'error')`を返すのはすべての`api`モジュールのアクションが同じビューを使用しているからです。`index`アクションの他のもの、例えば`popular`が`sfView::ERROR`で終わるのを想像して下さい。同じ内容で二つの同一のエラービュー(`indexError.php`と`popularError.php`)を提供しなければなりません。`forward()`の選択はコードの反復を制限します。しかしながら、他のアクションの実行を強制します。

APIレスポンス
-------------

XMLレスポンスのビルディングはまさにXHTMLページをビルディングすることに似ています。16日目のsymfonyのチュートリアルを体験したあなたには次のコードで驚くことはないでしょう。

### api/indexアクション

    [php]
    public function executeQuestion()
    {
      $user = $this->authenticateUser();
      if (!$user)
      {
        $this->error_code    = 1;
        $this->error_message = 'login failed';
  
        $this->forward('api', 'error');
      }
      
      if (!$this->getRequestParameter('stripped_title'))
      {
        $this->error_code    = 2;
        $this->error_message = 'The API returns answers to a specific question. Please provide a stripped_title parameter';

        $this->forward('api', 'error');
      }
      else
      {
        // 質問を取得する
        $question = QuestionPeer::getQuestionFromTitle($this->getRequestParameter('stripped_title'));

        if ($question->getUserId() != $user->getId())
        {
          $this->error_code    = 3;
          $this->error_message = 'You can only use the API for the questions you asked';

          $this->forward('api', 'error');
        }
        else
        {
          // 回答を取得する
          $this->answers  = $question->getAnswers();
          $this->question = $question;
        }
      }
    }

### questionSuccess.phpテンプレート

    [php]
    <?php echo '<?' ?>xml version="1.0" encoding="utf-8" ?>
    <rsp stat="ok" version="1.0">
      <question href="<?php echo url_for('@question?stripped_title='.$question->getStrippedTitle(), true) ?>" time="<?php echo strftime('%Y-%m-%dT%H:%M:%SZ', $question->getCreatedAt('U')) ?>">
        <title><?php echo $question->getTitle() ?></title>
        <tags>
          <?php foreach ($sf_user->getSubscriber()->getTagsFor($question) as $tag): ?>
          <tag><?php echo $tag ?></tag>
          <?php endforeach ?>
        </tags>
        <answers>
          <?php foreach ($answers as $answer): ?>
          <answer relevancy="<?php echo $answer->getRelevancyUpPercent() ?>" time="<?php echo strftime('%Y-%m-%dT%H:%M:%SZ', $answer->getCreatedAt('U')) ?>"><?php echo $answer->getBody() ?></answer>
          <?php endforeach ?>
        </answers>
      </question>
    </rsp>

このAPIコールのために新しいルーティングルールを追加して下さい:

    api_question:
      url:   /api/question/:stripped_title
      param: { module: api, action: question }

### テストする

REST APIのレスポンスはシンプルなXMLなので、ブラウザによって簡単にテストすることができます:

    http://askeet/api/question/what-shall-i-do-tonight-with-my-girlfriend

外部APIを統合する
-----------------

外部APIの統合はPHPにおいてXMLの読み込みよりも難しいことではありません。askeetにおいて存在する外部APIを統合してもすぐに利益はありません。askeet APIを外部のウェブサイト　-symfonyで構築されているか、いないかに関わらず、をどのようにして統合するのか、少し説明をいたします。

PHP5には[SimpleXML](http://www.zend.com/php5/articles/php5-simplexml.php)がバンドルされています。SimpleXMLはXMLドキュメントを読み込みループするツールのセットで、とても簡単で使いやすいです。SimpleXMLによって要素名は自動的にオブジェクトのプロパティにマップされ、これは再起的に起きます。属性はイテレータアクセスにマップされます。

APIによって質問への回答リストをシンプルなページに再構築するために、必要なことは少しのPHPコードです:

    [php]
    <?php $xml = simplexml_load_file(dirname(__FILE__).'/question.xml') ?>

    <h1><?php echo $xml->question->title ?></h1>
    <p>Published on <?php echo $xml->question['time'] ?></p>

    <h2>Tags</h2>
    <ul>
      <?php foreach ($xml->question->tags->tag as $tag): ?>
      <li><?php echo $tag ?></li>
      <?php endforeach ?>
    </ul>

    <h2>Answers to this question from askeet users</h2>
    <ul>
    <?php foreach ($xml->question->answers->answer as $answer): ?>
      <li>
        <?php echo $answer ?>
        <br />
        Relevancy: <?php echo $answer['relevancy'] ?>% - Pulished on <?php echo $answer['time'] ?>
      </li>
    <?php endforeach ?>
    </ul>

Paypalの寄付
------------

外部のAPIについて話している一方で、それらのいくつかは統合するのにとてもシンプルで、あなたのサイトに多くのものをもたらすことができます。[Paypal](http://www.paypal.com)のdonation APIは口座のEメールが必ず含まれなければならないHTMLコードのシンプルなチャンクです。

回答が役に立ったと判断したすべてのハッピーなユーザから回答ユーザ少額の寄付を受け取ることができるのはaskeetユーザのためにとってよいモチベーションではないでしょうか？ 'Donate'ボタンはユーザプロファイルページに現れ、彼または彼女のPaypal donationページにリンクをします。

最初に、`has_paypal`カラムを`schema.xml`の`User`テーブルに追加します:

    [xml]
    <column name="has_paypal" type="boolean" default="0" />

Rebuild the model, and add to the `user/show` template the following code:

    [php]
    <?php if ($subscriber->getHasPaypal()): ?>
    <p>If you appreciated this user's contributions, you can grant him a small donation.</p>
    <form action="https://www.paypal.com/cgi-bin/webscr" method="post">
      <input type="hidden" name="cmd" value="_xclick">
      <input type="hidden" name="business" value="<?php echo $subscriber->getEmail() ?>">
      <input type="hidden" name="item_name" value="askeet">
      <input type="hidden" name="return" value="http://www.askeet.com">
      <input type="hidden" name="no_shipping" value="1">
      <input type="hidden" name="no_note" value="1">
      <input type="hidden" name="tax" value="0">
      <input type="hidden" name="bn" value="PP-DonationsBF">
      <input type="image" src="http://images.paypal.com/images/x-click-but04.gif" border="0" name="submit" alt="Donate to this user">
    </form>
    <?php endif ?>

現在、ユーザはEメールアドレスにリンクされたPaypalアカウントを宣言する機会が与えられなければなりません。ユーザが自分のプロファイルを修正することができるようにするよい機会です。ログインしたユーザは自分自身のページを表示した場合、 'edit profile 'が出現しなければなりません。フォームの表示と投稿を処理することに使用される`user/edit`アクションをリンクします。 'edit profile 'フォームはパスワードの修正とEメールアドレスを可能にします。キーとして使用されるニックネームは修正されることはありません。いまやあなたはsymfonyに慣れているので、コードはここでは表示しませんが、SVNリポジトリに含まれます。

それではまた明日
----------------

Webサービスを開発すること、外部のサービスを統合することをsymfonyで行うのはそれほど難しくないでしょう。

明日は、フィルタについてお話をする機会があります。またわずかなコードの追加だけでaskeet.comを例えばphp.askeet.comtとsymfony.askeet.comとサブプロジェクトに分割にすることを行います。まだsymfonyで開発するスピードとパワーに納得していなかったら、考えを変えるかもしれません。

いつもの通り、今日のコードを`/tags/release_day_17`とタグ付けされた[askeet SVNリポジトリ](http://svn.askeet.com/tags/release_day_17/)にコミットしておきました。askeetとadvent calendarチュートリアルに関する質問と提案は[askeetフォーラム](http://www.symfony-project.com/forum/index.php/f/8/)で歓迎します。それではまた明日!

