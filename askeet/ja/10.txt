symfony アドベントカレンダー 10日目: Ajaxフォームの変更
=======================================================

復習
----

昨日の既知のテクニックのレビューの後で、インターラクションが欲しくてたまらない方がいらっしゃったと思います。 リッチでページ番号付きのフォーマット済みの質問とリストを表示することはアプリケーションを生かすには不十分です。 askeetのコンセプトの中心はどんな登録ユーザにも質問をし、どんなユーザにも存在する質問に対して回答することができるようにすることです。 そろそろ取りかかる時期ではありませんか？

新しい質問を追加する
--------------------

[7日目](7.txt)に構築されたサイドバーはすでに新しい質問を追加するリンクを含みます。開発が待たれている `question/add` アクションにリンクします。

### 登録ユーザへのアクセスを制限する

最初に、登録されたユーザだけが新しい質問を追加することができます。`question/add` アクションにアクセスするのを制限するために`askeet/apps/frontend/modules/question/cofig/`ディレクトリに`security.yml`を作成して下さい:

    add:
      is_secure:   on
      credentials: subscriber
    
    all:
      is_secure:   off

未登録なユーザが制限されたアクションにアクセスしようとしたとき、symfonyは彼または彼女をログインアクションにリダイレクトします。このアクションは`login_module`と`login_action keys`の下の、アプリケーションの`settings.yml`によって定義されなければなりません:

    all:
      .actions:
        login_module:           user
        login_action:           login

アクション、アクセス、制限に関する情報はsymfonyブックの[セキュリティの章](http://www.symfony-project.com/book/1_0/06-Inside-the-Controller-Layer)で見ることが出来ます。

### addSuccess.phpテンプレート

`question/add`アクションはフォーム表示とフォーム処理の両方に使用されます。これは現時点で、フォームの表示を意味し、空のアクションだけが必要です。加えて、フォームはデータバリデーションにおいてエラーの場合、フォームが再表示されます:

    [php]
    public function executeAdd()
    {
    }

    public function handleErrorAdd()
    {
      return sfView::SUCCESS;
    }

両方のアクションは`addSuccess.php`テンプレートを出力します:

    [php]
    <?php use_helper('Validation') ?>

    <?php echo form_tag('@add_question') ?>
    
      <fieldset>
    
      <div class="form-row">
        <?php echo form_error('title') ?>
        <label for="title">Question title:</label>
        <?php echo input_tag('title', $sf_params->get('title')) ?>
      </div>
    
      <div class="form-row">
        <?php echo form_error('body') ?>
        <label for="label">Your question in details:</label>
        <?php echo textarea_tag('body', $sf_params->get('body')) ?>
      </div>
    
      </fieldset>
    
      <div class="submit-row">
        <?php echo submit_tag('ask it') ?>
      </div>
    </form>

`title`と`body`コントロールの両方は同名のリクエストパラメータから定義されたデフォルトの値(フォームヘルパの二番目の引数)を持ちます。なぜでしょうか？私達はフォームにバリデーションファイルを追加しようとしているからです。バリデーションが失敗した場合、フォームは再表示され、リクエストパラメータにまだあるユーザの以前のエントリーがあります。フォーム要素のデフォルト値として、それらは使用されます。

![保存された以前のエントリ内でのエラー](/images/askeet/add_question_error.gif)

以前のエントリーは失敗したフォームバリデーションの場合に失われるわけではありません。ユーザフレンドリなアプリケーションに期待されることではありません。

しかし、アーカイブするために、フォームバリデーションファイルが必要です。

### フォームのバリデーション

`question`モジュールに`validate/`ディレクトリを作成し、`add.yml`バリデーションファイルを追加して下さい:

    methods:
      post:            [title, body]
    
    names:
      title:
        required:      Yes
        required_msg:  You must give a title to your question
    
      body:
        required:      Yes
        required_msg:  You must provide a brief context for your question
        validators:    bodyValidator
    
    bodyValidator:
        class:         sfStringValidator
        param:
          min:         10
          min_error:   Please, give some more details

フォームバリデーションについてもっと情報が必要なら、[6日目](6.txt)もしくはsymfony bookの[フォームのバリデーションの章](http://www.symfony-project.com/book/1_0/10-Forms)に戻って下さい。

## フォーム投稿を扱う

フォーム投稿を扱うために`quesiton/add`アクションをまた編集して下さい:

    [php]
    public function executeAdd()
    {
      if ($this->getRequest()->getMethod() == sfRequest::POST)
      {
        // 質問を作る
        $user = $this->getUser()->getSubscriber();
    
        $question = new Question();
        $question->setTitle($this->getRequestParameter('title'));
        $question->setBody($this->getRequestParameter('body'));
        $question->setUser($user);
        $question->save();
    
        $user->isInterestedIn($question);
    
        return $this->redirect('@question?stripped_title='.$question->getStrippedTitle());
      }
    }

`->setTitle()`メソッドは`stripped_title`も設定し、`->setBody()`メソッドは`html_body`フィールドも設定することを覚えておいて下さい。`Question.php`モデルクラスにおいてこれらのメソッドをオーバーライドするからです。質問への関心が0というとても悲しい状況が表示されるのを防ぐためです。

アクションの最後は作成された質問の詳細への`->redirect()`を含みます。`->forward()`を上回るメリットは後でユーザが質問の詳細ページをリフレッシュしたとき、フォームが再び投稿されないことにあります。加えて、「back」ボタンは期待通り動作します。一般的なルールです。-`>forward()`でアクションを取り扱うフォーム投稿で終える必要はありません。

ベストなことはアクションがフォームを表示するためにまだ動作していることです。つまり、もしリクエストがPOSTモードではないのであるならです。以前書かれた空のアクションのようにきっちり振る舞います。`addSuccess.php`テンプレートを立ち上げるデフォルトの`sfView::SUCCESS`をリターンします。

`User`モデルに`isInterestedIn()`メソッドを作成することを忘れないで下さい:

    public function isInterestedIn($question)
    {
      $interest = new Interest();
      $interest->setQuestion($question);
      $interest->setUserId($this->getId());
      $interest->save();
    }
    
マイナーなリファクタリングとして、同じことをするコードスニペットを置き換える`user/interested`アクションでこのメソッドを使用することができます。

行って、テストして下さい。テストユーザの一つを使うことで、質問を追加できます。

新しい回答を追加する
--------------------

回答の追加は微妙に異なった方法で埋め込まれます。フォームを伴った新しいページにユーザをリダイレクトする必要はありませんし、表示された質問のための他のページへもリダイレクトする必要もありません。新しいフォームはAJAXにあり、新しい質問は質問の詳細ページに即座に現れます。

### AJAXフォームを追加する

`modules/question/templates/showSuccess.php`テンプレートの終わりを変更して下さい:

    [php]
    ...    
    <div id="answers">
    <?php foreach ($question->getAnswers() as $answer): ?>
      <div class="answer">
      <?php include_partial('answer/answer', array('answer' => $answer)) ?>
      </div>
    <?php endforeach; ?>
    
    <?php echo use_helper('User') ?>
    
    <div class="answer" id="add_answer">
      <?php echo form_remote_tag(array(
        'url'      => '@add_answer',
        'update'   => array('success' => 'add_answer'),
        'loading'  => "Element.show('indicator')",
        'complete' => "Element.hide('indicator');".visual_effect('highlight', 'add_answer'),
      )) ?>
    
        <div class="form-row">
          <?php if ($sf_user->isAuthenticated()): ?>
            <?php echo $sf_user->getNickname() ?>
          <?php else: ?>
            <?php echo 'Anonymous Coward' ?>
            <?php echo link_to_login('login') ?>
          <?php endif; ?>
        </div>
    
        <div class="form-row">
          <label for="label">Your answer:</label>
          <?php echo textarea_tag('body', $sf_params->get('body')) ?>
        </div>
    
        <div class="submit-row">
          <?php echo input_hidden_tag('question_id', $question->getId()) ?>
          <?php echo submit_tag('answer it') ?>
        </div>
      </form>
    </div>
    
    </div>
    
### 少しのリファクタリング

`link_to_login()`関数は`UserHelper.php`ヘルパに追加されなければなりません:

    [php]
    function link_to_login($name, $uri = null)
    { 
      if ($uri && sfContext::getInstance()->getUser()->isAuthenticated())
      {
        return link_to($name, $uri);
      }
      else
      {
        return link_to_function($name, visual_effect('blind_down', 'login', array('duration' => 0.5)));
      }
    }
    
この関数は私達が既に他の`User`ヘルパで見たことをします: このリンクはAJAXログインフォームを指し示します。`link_to_function()`コールを`link_to_login()`へのコールによって`link_to_user_interested()`と`link_to_user_relevancy()`関数に置き換えて下さい。`modules/sidbar/templates/defaultSuccess.php`の`@add_quesiton`へのリンクを忘れないで下さい。もちろん、リファクタリングです。

### フォーム投稿を取り扱う

フラグメントをまだ含むとしても、AJAXリクエストを処理するためにここで選ばれたメソッドは[8日](8.txt)の間に記述されたものとは微妙に異なります。 実際にフォームを置き換えるためにフォーム投稿の結果が欲しいからです。`form_remote_tag()`ヘルパの`update`パラメータがアウターゾーンよりもそれ自身からのコンテナを示すのはそういうわけです。`_answer.php`フラグメントは質問追加アクションの結果を含むので、最後の結果は次のようになります:

    [php]
    ...
    <div id="answers">
      <!-- Answer 1 -->
      <!-- Answer 2 -->
      <!-- Answer 3 -->
      ...
    </div>
    
    <div class="answer" id="add_answer">
      <!-- The new answer -->
    </div>
    
おそらくあなたは`form_remote_tag()`javascriptヘルパがどのように動作するのは推測をしたと思います: XMLHttpRequestオブジェクトを通した`url`引数によって特定されたアクションへのフォーム投稿を取り扱います。アクションの結果は`update`引数で指定された要素を置き換えます。そして、8日目の`link_to_remote()`ヘルパのように、リクエスト投稿に従ってアクティビティインディケータのビジビリティを切り替え、AJAXトランザクションの終了時点でのアップデートされた部分をハイライトします。

新しい質問に関連したユーザについて言葉を追加させてください。以前、回答はユーザにリンクされる必要があることを言及しました。ユーザが認証された場合、彼または彼女の`user_id`は新しい回答のために使用されます。他の場合では、`anonymous`ユーザはログインを選ばない限り、場所に使われます。`GlobalHelper.php`ヘルパ設定にロケートされた`link_to_login()`ヘルパはレイアウトの隠しログインフォームのビジビリティを切り替えます。コードを見るためにaskeetのソースをブラウズしてください。

### answer/addアクション

`@add_answer`ルールは`answer/add`アクションを指し示すAJAXフォームの`url`引数として与えられます:

    add_answer:
      url:   /add_anwser
      param: { module: answer, action: add }

(困ったら、この構成は`routing.yml`アプリケーションの構成ファイルに追加されます。)

アクションの内容はこのとおりです:

    [php]
    public function executeAdd()
    {
      if ($this->getRequest()->getMethod() == sfRequest::POST)
      {
        if (!$this->getRequestParameter('body'))
        {
          return sfView::NONE;
        }

        $question = QuestionPeer::retrieveByPk($this->getRequestParameter('question_id'));
        $this->forward404Unless($question);
    
        // 通常のユーザもしくは匿名ユーザ
        $user = $this->getUser()->isAuthenticated() ? $this->getUser()->getSubscriber() : UserPeer::retriveByNickname('anonymous');
    
        // 回答を作る
        $this->answer = new Answer();
        $this->answer->setQuestion($question);
        $this->answer->setBody($this->getRequestParameter('body'));
        $this->answer->setUser($user);
        $this->answer->save();
    
        return sfView::SUCCESS;
      }
    
      $this->forward404();
    }

最初に、このアクションがPOSTモードでコールされなかったら、ブラウザのアドレスバーに誰かがURIを入力されたことを意味します。アクションは(ハッカーの)リクエストのタイプのためにデザインされてはいないので、その場合は404エラーを返します。

回答の著者として設定するユーザを決めるために、アクションは現在のユーザが認証されたかどうかをチェックします。この場合ではないとしたら、アクションは`UserPeer`クラスの`::retrieveByNickname()`メソッドのおかげで'Anoymous Coward'ユーザを使用します。あなたがこのメソッドが何をするのかどうかを疑問にもつかどうかコードをチェックするおかげです。

これで、新しい質問を作成し、リクエストを`addSuccess.php`テンプレートに渡すすべての準備ができています。期待されるとおり、このテンプレートは`include_partial`、の1行だけを含みます:

    [php]
    <?php include_partial('answer', array('answer' => $answer)) ?>

`frontend/modules/answer/config/view.yml`にあるこのアクションのためのレイアウトを無効化することも必要です:

    addSuccess:
      has_layout: off
 
最後に、ユーザは空の回答を投稿したときは、私達は保存を望みません。そこで、部分を扱うデータをバイパスし、アクションは何もリターンしません - これはシンプルにページのフォームを削除します。このAJAXフォームを処理しているときにエラーを対処することができます。しかし、フォーム自身を他のフラグメントに設置することも含まれます。今の時点で、努力する価値はありません。
 
### テストする

これですべてですか？はい、そうです。AJAXフォームはクリーンで安全に使用される準備はできています。質問への回答リストを表示することや、新しい回答を追加することでテストをして下さい。ページはリフレッシュをする必要が無く、回答は以前のものリストの一番下に現れます。シンプルでしたね？

それではまた明日
----------------

古典的なフォームとAJAXフォームはsymfonyのアプリケーションに埋め込むことはたやすいです。そしてそれら二つの追加に加えて、askeetアプリケーションは動作するように要求された中心的な機能を持ちます。

一つのこと: 私達は新しいユーザを登録する方法を述べていません。今日行ったことととても似ているので、この機能はとにかく現在の[askeetのSVNリポジトリ](http://svn.askeet.com/tags/release_day_10/)に追加されました。

10日目の内容はsymfonyでAJAXによって強化されたFAQのベータバージョンを構築することで終わりました。しかしながら、私達はaskeetの機能をそれよりももっと高めたいです。 askeetコミュニティを構築するのを手助けするために、フィードアグリゲータに配信された回答を受け取るために質問をした人が登録することができるように私達はサイトでシンディケーションフィードを配信することが必要です。 

21日目のためにいくつかのアイディアを提案して下さった方々がいらっしゃいます。リストを展開するか、[askeetフォーラム](http://www.symfony-project.com/forum/index.php/f/8/)に訪問して彼らの提案をサポートして下さい