6日目: セキュリティとフォームのバリデーション
===========================================

復習
----

[5日目](5.txt) において、テンプレートとアクションを操作することに慣れました; フォームとページャはもはやあなたにとって秘密では無くなりました。ログインフォームを構築したあとに、特定の機能のセットのために認証されていないユーザがアクセスすることをどのようにして制限するのか、もしかしたらあなたは私達に期待をしたかもしれません。それはまさに今日私達が行おうとしていることです。フォームバリデーションと一緒に行います。私達がカスタムクラスによってアプリケーションを拡張するにつれて、あなたもsymfonyブックの[カスタムの拡張の章](http://www.symfony-project.com/book/1_0/07-Inside-the-View-Layer) で公開されているコンセプトに満足するでしょう。

ログインフォームバリデーション
------------------------------

### バリデーションファイル

ログインフォームは`nickname`と`password`フィールドを持ちます。しかし、ユーザが不正なデータを投稿したら、何が起きるでしょうか？このケースを対処することができるように、`/frontend/modules/user/validate`ディレクトリに`login.yml`ファイルを作成します(`login`はバリデートをするアクション名)。次のコードを追加します:

    methods:
      post: [nickname, password]
    
    names:
      nickname:
        required:     true
        required_msg: your nickname is required
        validators:   nicknameValidator
    
      password:
        required:     true
        required_msg: your password is required
    
    nicknameValidator:
        class:        sfStringValidator
        param:
          min:        5
          min_error:  nickname must be 5 or more characters

最初に、`method`ヘッダの元で、バリデートされるフィールドのリストがフォームのメソッドのために定義されます(私達はPOSTメソッドだけを定義します。なぜならGETメソッドはログインフォームを表示することになって、バリデーションを必要としないからです)。それから`names`ヘッダの下で、チェックされるべきそれぞれのフィールドのための要求がエラーメッセージに対応して、リストとして表示されます。結局は、'nickname'フィールドは特別のバリデーションのセットを持つように宣言されているので、それらはヘッダ対応の下で詳細に記述されます。この例では、`sfStringValidator`はsymfonyに組み込まれているバリデータで文字列のフォーマットをチェックします。(デフォルトのsymfonyバリデータはsymfonyブックの[フォームを検証する方法](http://www.symfony-project.com/book/1_0/10-Forms)で説明されています)

### エラーの処理

ではユーザが間違ったデータを入力したら何が起きるでしょうか？`login.yml`ファイルに書かれた設定が見つからず、symfonyコントローラは`form_tag` 引数で予定された`executeLogin()`メソッドの代わりに`userActions`クラスの`handleErrorLogin()`メソッドへリクエストを渡します。このメソッドが存在しないのであれば、デフォルトの振る舞いは`loginError.php`テンプレートを表示します。`HandleError()`メソッドがリターンするのはそういうわけです:

    [php]
    public function handleError()
    {
      return sfView::ERROR;
    }

これはまったく新しい書くテンプレートです。しかし、私達はむしろ問題のあるフォールドに近いメッセージでログインフォームを再び表示したいです。ではログインエラー表示の振る舞いを修正しましょう。この場合、`loginSuccess.php`テンプレートです:

    [php]
    public function handleErrorLogin()
    {
      return sfView::SUCCESS;
    }

>**Note**: アクションネームにリンクする命名規則、`return`の値とテンプレートファイルはsymfonyブックの[ビューの章](http://www.symfony-project.com/book/1_0/07-Inside-the-View-Layer)に公開されています。

### テンプレートエラーヘルパ

`loginSuccess.php`テンプレートが再び呼び出されたとき、エラーを表示します。その目的のために`Validation`ヘルパグループの`form_error()`ヘルパを使用します。テンプレートの２つの`form-row`のdivを次のように変更して下さい:

    [php]
    <?php use_helper('Validation') ?>

    <div class="form-row">
      <?php echo form_error('nickname') ?>
      <label for="nickname">nickname:</label>
      <?php echo input_tag('nickname', $sf_params->get('nickname')) ?>
    </div>
    
    <div class="form-row">
      <?php echo form_error('password') ?>
      <label for="password">password:</label>
      <?php echo input_password_tag('password') ?>
    </div>
 
フィールドでパラメータとして与えられたフィールドでエラーが宣言された場合`form_error()`ヘルパは`login.yml`で定義されたエラーメッセージを出力します。

5文字以下のニックネームが入力を試すか、2つのフィールドの1つを省略することでフォームバリデーションをテストしましょう。エラーメッセージは上述のconcernedフィールドを表示します:

![ログインフォームのエラー](/images/askeet/login_form_error.gif)

現在パスワードは強制です。しかし、データーベースにはパスワードがありません! どんなパスワードでも入力した途端にログインが成功するのであれば、問題ではありません。それはセキュアなプロセスでありませんよね？

### スタイルエラー

フォームをテストしてエラーを得たのであれば、おそらくはあなたのエラーが上記のキャプチャーのものと同じ方法で表されていないことに気づいているでしょう。それは `.form_error`クラス(`web/main.css`)のスタイルを定義したからです。`.form_error`クラスは`form_error()`ヘルパによって生成されたフォームエラーのデフォルトクラスです:

    [css]
    .form_error
    {
      padding-left: 85px;
      color: #d8732f;
    }
    
ユーザを認証する
----------------

### カスタムバリデータ

`login`アクションに入力されたニックネームの存在について昨日のチェックを覚えているでしょうか？フォームバリデーションのように聞こえるでしょう。 このコードはアクションから持ち出され、カスタムバリデータに含まれています。 複雑だと思いますか？実際にはそうではないです。次のように`login.yml`のバリデーションファイルを編集して下さい:

    ...
    names:
      nickname:
        required:      true
        required_msg:  your nickname is required
        validators:    [nicknameValidator, userValidator]
    ...
    userValidator:
        class:         myLoginValidator
        param:
          password:    password
          login_error: this account does not exist or you entered a wrong password

`myLoginValidator`クラスの`nickname`フィールドのための新しいバリデータを追加しました。このバリデータはまだ存在していません。しかし、十分にユーザを認証するためのパスワードが必要になることは私達は知っています。なので、ラベル `password`でパラメータとして渡されます。

### パスワードの保存

しかし、少しお待ち下さい。データモデルにおいて、テストデータと同様、パスワードの設定がありません。定義しましょう。しかし、クリアなテキスト、データベースにパスワードをストアすることはセキュリティ的な理由からバッドアイディアであることを知っています。ハッシュ化されたランダムキーと同じようにパスワードの[sha1ハッシュ](http://en.wikipedia.org/wiki/SHA_hash_functions)を保存します。'salt'プロセスに慣れていませんでしたら、[パスワードクラッキングの練習](http://en.wikipedia.org/wiki/Password_cracking)をチェックアウトして下さい。

`schema.xml`を開き、次のコラムを`User`テーブルに追加して下さい:

    [xml]
    <column name="email" type="varchar" size="100" />
    <column name="sha1_password" type="varchar" size="40" />
    <column name="salt" type="varchar" size="32" />

`symfony propel-build-model`でPropelモデルをリビルドして下さい。手動か `symfony prpel-build-sql`のあとに生成された`lib.model.schema.sql`を使うかでデータベースへ二つのカラムも追加します。`askeet/lib/mode/User.php`を開き、`setPassword()`メソッドを追加して下さい:

    [php]
    public function setPassword($password)
    {
      $salt = md5(rand(100000, 999999).$this->getNickname().$this->getEmail());
      $this->setSalt($salt);
      $this->setSha1Password(sha1($salt.$password));
    }

この関数は直接的なパスワード保存をシミュレートします。しかし、代わりに `salt`ランダムキー(ハッシュ化されたランダムな文字列による32文字)を保存し、パスワードをハッシュ化(40文字)します。

### テストデータにパスワードを追加する

3日目のテストデータファイルを覚えていますか？ パスワードとEメールをテストユーザに追加しましょう。`askeet/fixtures/test_data.yml`を開き次のように修正します:

    User:
      ...
      fabien:
        nickname:   fabpot
        first_name: Fabien
        last_name:  Potencier
        password:   symfony
        email:      fp@example.com
    
      francois:
        nickname:   francoisz
        first_name: François
        last_name:  Zaninotto
        password:   adventcal
        email:      fz@example.com

`setPassword()`メソッドは`User`クラスのために定義されたと同じように、`sfPropelData`オブジェクトは`sha1_password`と私達が呼び出したときのスキーマで定義された`salt`カラムを投入します:

    $ php batch/load_data.php

>**Note**: `sfPropelData` オブジェクトが 'real' データベースカラムとバインドしていないメソッドを取り扱うことができることを注目して下さい。(そして私達はあなたの伝統的なSQLダンプを上回ります!)
>
>どのようにして可能であるのか悩んでいましたら、symfonyブックの[データベース投入の章](http://www.symfony-project.com/book/1_0/08-Inside-the-Model-Layer)をご覧下さい。

>**Note**: 'Anonymous Coward'のログインを禁止するので、パスワードを定義する必要はありません。あなたがここで与えられた二つのパスワードを私達の銀行のアカウントに試さないことを本当に評価したいと思います。それらは機密情報なので!

### カスタムバリデータ

ではこのカスタムの`myLoginValidator`を書きましょう。モジュールがアクセス可能な`lib/`ディレクトリに作成することができます。(つまり、`askeet/lib/`、または`askeet/apps/frontend/lib/`または `askeet/apps/frontend/modules/user/lib/`)今やアプリケーション-ワイドなバリデータと考えられています。ですので `myLoginValidator.class.php`は `askeet/apps/frontend/lib/`ディレクトリに作成されます:

    [php]
    <?php
    
    class myLoginValidator extends sfValidator
    {    
      public function initialize($context, $parameters = null)
      {
        // 親クラスを初期化する
        parent::initialize($context);
    
        // デフォルトを設定する
        $this->setParameter('login_error', 'Invalid input');
    
        $this->getParameterHolder()->add($parameters);
    
        return true;
      }

      public function execute(&$value, &$error)
      {
        $password_param = $this->getParameter('password');
        $password = $this->getContext()->getRequest()->getParameter($password_param);
    
        $login = $value;

        // anonymousは実際のユーザではない
        if ($login == 'anonymous')
        {
          $error = $this->getParameter('login_error');
          return false;
        }
    
        $c = new Criteria();
        $c->add(UserPeer::NICKNAME, $login);
        $user = UserPeer::doSelectOne($c);
    
        // nicknameが存在するか？
        if ($user)
        {
          // passwordはOKか？
          if (sha1($user->getSalt().$password) == $user->getSha1Password())
          {
            $this->getContext()->getUser()->setAuthenticated(true);
            $this->getContext()->getUser()->addCredential('subscriber');
  
            $this->getContext()->getUser()->setAttribute('subscriber_id', $user->getId(), 'subscriber');
            $this->getContext()->getUser()->setAttribute('nickname', $user->getNickname(), 'subscriber');
      
            return true;
          }
        }
    
        $error = $this->getParameter('login_error');
        return false;
      }
    }

バリデータが要求されたとき、- ログインフォームの投稿の後で - `initialize()`メソッドが最初に呼ばれます。デフォルトの`login_error`メッセージ('Invalid Input')を初期化し、パラメータ(`param:`の下にあるもの: `login.yml`ファイルへのヘッダ)をパラメータホルダオブジェクトに統合します。

それで`excecute()`メソッドは...実行されました。`$password_param`は `password`ヘッダの下にある`login.yml`に提供されたフィールドネームです。リクエストパラメータからの値を取り出すフィールドネームとして使用されます。`$password`はユーザによって入力されたパスワードを含みます。`$value`はカレントフィールドの値を取ります。そして`myLoginValidator`クラスは`nickname`フィールドのために呼び出されます。`$login`はユーザによって入力されたニックネームを含みます。最後です! これでバリデータはユーザを実際にバリデートするために必要なデータを持ちます。

次のコードは`login`アクションによって始まります。しかし、加えて、パスワードバリデートのテスト(前回は常に`true`)は埋め込まれています: ユーザによって入力されたパスワードのハッシュ(データベースに保存されたsalt)はユーザのハッシュ化されたパスワードと比較されます。

ログインとパスワードが正しい場合、バリデータは`true`を返し、フォームのターゲットアクション(`executeLogin()`)は実行されます。そうでなければ`false`を返し、`handleErrorLogin()`が実行されます。

### アクションからコードを除去する

バリデーションコードはバリデータの内側に設置されていますので、`login`アクションからそれを取り除く必要があります。実際に、POSTメソッドでアクションが呼び出されたときには、バリデータがリクエストをバリデートしたことを意味し、それはユーザが正しいということです。この場合においてアクションがすべき唯一のことは`referer`ページにリダイレクトすることを意味します:

    [php]
    public function executeLogin()
    {
      if ($this->getRequest()->getMethod() != sfRequest::POST)
      {
        // フォームを表示する
        $this->getRequest()->getParameterHolder()->set('referer', $this->getRequest()->getReferer());
        
        return sfView::SUCCESS;
      }
      else
      {
        // フォーム投稿を取り扱う
        // 最後のページにリダイレクトする
        return $this->redirect($this->getRequestParameter('referer', '@homepage'));
      }
    }

テストユーザの1つでログインを試して、修正をテストして下さい。(オートロードする必要のある新しいバリデータクラスを作成したので、キャッシュをクリアした後に)

アクセスを制限する
------------------

アクションへのアクセスを制限したいのであれば、モジュールの`config/`ディレクトリにある`security.yml`に次のようなコードを追加する必要があります(今はしないでください):

    all:
      is_secure:   on
      credentials: subscriber

このようなモジュールのアクションが実行されるのはユーザが認証され、`subscriver`の認証を持つときのみです。

askeetにおいて、ログインは新しい質問を投稿するため、質問に対する関心を表す、コメントを評価するときに求められます。すべての他のアクションはログインしていないユーザに対して開かれています。

`question/add`アクションのアクセス (まだ書かれていません) を制限するために、`askeet/apps/frontend/modules/question/config`ディレクトリに次の `security.yml`ファイルを追加して下さい:

    add:
      is_secure:   on
      credentials: subscriber

    all:
      is_secure:   off

ちょっとリファクタリングはいかがですか？
----------------------------------------

今日はほとんど終わりましたが、少しの間、私達の好きなゲームを遊んでみたいと思います。move-the-code-to-an-unlikely-placeゲームです。

パスワードがバリデートされるときに実行される4行のコードはユーザにアクセス権限を与え、将来のリクエストのために`id`を保存します。`myUser`クラスのメソッドとしてみることができます。(セッションクラスで、`User`カラムに対応している`User`クラスではありません。) するのは簡単です。次のメソッドを`askeet/apps/frontend/lib/myUser.php`クラスに追加して下さい:

    [php]
    public function signIn($user)
    {
      $this->setAttribute('subscriber_id', $user->getId(), 'subscriber');
      $this->setAuthenticated(true);

      $this->addCredential('subscriber');
      $this->setAttribute('nickname', $user->getNickname(), 'subscriber');
    }

    public function signOut()
    {
      $this->getAttributeHolder()->removeNamespace('subscriber');

      $this->setAuthenticated(false);
      $this->clearCredentials();
    }

では、`myLoginValidator`クラスで`$this->getContext()->getUser()`によって始まる4行を変更して下さい:

    [php]
    $this->getContext()->getUser()->signIn($user);

そして`user/logout`アクション(忘れましたか？)も変更して下さい:

    [php]
    public function executeLogout()
    {
      $this->getUser()->signOut();
    
      $this->redirect('@homepage');
    }

`subscriver_id`と`nickname`セッション属性もgetterメソッドを通して抽象化されます。`myUser`クラスにおいて次の3つのメソッドを追加して下さい:

    [php]
    public function getSubscriberId()
    {
      return $this->getAttribute('subscriber_id', '', 'subscriber');
    }
  
    public function getSubscriber()
    {
      return UserPeer::retrieveByPk($this->getSubscriberId());
    }

    public function getNickname()
    {
      return $this->getAttribute('nickname', '', 'subscriber');
    }

`layout.php`にこれらの新しいメソッドの1つを利用できます:

    [php]
    <li><?php echo link_to($sf_user->getAttribute('nickname', '', 'subscriber').' profile', 'user/profile') ?></li>
    
上記のコードを下記のコードに変更して下さい

    [php]
    <li><?php echo link_to($sf_user->getNickname().' profile', 'user/profile') ?></li>

修正をテストすることを忘れないで下さい。以前と同じログインプロセスはまだ動作します - しかし、現在はもっとよいコードで動きます。

それではまた明日
----------------

明日は、カスタマイズし、CSSと一貫したコンポーネントをカスタマイズし、ページヘッダに注意を払うためにビュー設定に少し取り組みます。

release_day_6とタグがついた[askeetのSVNリポジトリ](http://svn.askeet.com/tags/release_day_6/)から今日の分の全コードをまだダウンロードできることを忘れないで下さい。askeetに質問をしたり回答をしたくなりましたら、[askeetフォーラム](http://www.symfony-project.com/forum/index.php/f/8/)に気楽に行ってみて下さい。21日目のプログラムはまだみなさん次第であることを忘れないで下さい。
