4. fejezet - Propel integr�ci�
==============================

Egy webes projektben az �rlapok �ltal�ban a model objektumok manipul�l�s�ra szolg�lnak. A model objektumok adatai legt�bbsz�r adatb�zisba ker�lnek egy ORM seg�ts�g�vel. A symfony �rlap rendszere egy plusz r�teget biztos�t a Propellel, a symfony be�ptett ORM-j�vel, val� egy�ttm�k�d�shez, lehet�v� t�ve a modelen alapul� �rlapok k�nnyebb kezel�s�t.

Ebben a fejezetben az �rlapok Propel objektumokkal val� integr�ci�j�t n�zz�k �t r�szletesen. Aj�nlott a Propel �s a symfony integr�ci� alapos ismerete. Ehhez a "The Definitive Guide to symfony" [Inside the Model Layer](http://www.symfony-project.org/book/1_1/08-Inside-the-Model-Layer) fejezete ad seg�ts�get.

El�k�sz�t�s
-----------

Ebben a fejezetben egy cikkeket kezel� rendszert fogunk k�sz�teni. Kezdj�k az adatb�zis s�m�val. �t t�bl�t fogunk haszn�lni: `article`, `author`, `category`, `tag` �s `article_tag`, ahogy a 4-1 mell�kleten l�that�.

4-1 mell�klet - Adatb�zis s�ma

    [yml]
    // config/schema.yml
    propel:
      article:
        id:           ~
        title:        { type: varchar(255), required: true }
        slug:         { type: varchar(255), required: true }
        content:      longvarchar
        status:       varchar(255)
        author_id:    { type: integer, required: true, foreignTable: author, foreignReference: id, OnDelete: cascade }
        category_id:  { type: integer, required: false, foreignTable: category, foreignReference: id, onDelete: setnull }
        published_at: timestamp
        created_at:   ~
        updated_at:   ~
        _uniques:
          unique_slug: [slug]

      author:
        id:           ~
        first_name:   varchar(20)
        last_name:    varchar(20)
        email:        { type: varchar(255), required: true }
        active:       boolean

      category:
        id:           ~
        name:         { type: varchar(255), required: true }

      tag:
        id:           ~
        name:         { type: varchar(255), required: true }

      article_tag:
        article_id:   { type: integer, foreignTable: article, foreignReference: id, primaryKey: true, onDelete: cascade }
        tag_id:       { type: integer, foreignTable: tag, foreignReference: id, primaryKey: true, onDelete: cascade }

A t�bl�k k�z�tti kapcsolatok a k�vetkez�k:

  * 1-n kapcsolat az `article` �s az `author` t�bla k�z�tt: egy cikknek egy �s csak egy szerz�je lehet
  * 1-n kapcsolat az `article` �s a `category` t�bla k�z�tt: egy cikk maximum egy kateg�ri�ba tartozhat
  * n-n kapcsolat az `article` �s a `tag` t�bla k�z�tt

�rlap oszt�lyok gener�l�sa
--------------------------

Az `article`, `author`, `category` �s `tag` t�bl�k adatait szeretn�nk szerkeszteni. Ahhoz, hogy ezt megtehess�k �rlapokat kell k�sz�teni, amelyek a felsorolt t�bl�khoz kapcsol�dnak, valamint a widgeteket �s a validatorokat az adatb�zis s�m�hoz kell igaz�tani. Hab�r k�zzel is lehet �rlapot k�sz�teni, m�gis ez egy hossz� �s f�raszt� feladat, �sszess�g�ben hasonl� dolgokat kell ism�telni t�bb fileban is (oszlop- �s mez�nevek, oszlopok �s mez�k maxim�lis m�rete, ...). Tov�bb� minden esetben, amikor a model v�ltozik, a hozz� kapcsol�d� �rlapnak is v�ltoznia kell. Szerencs�re a Propel plugin rendelkezik egy be�p�tett taskkal, `propel:build-forms`, amely automatiz�lja az modelhez kapcsol�d� �rlapok l�trehoz�s�t:

    $ ./symfony propel:build-forms

Az �rlap gener�l�s alatt a task minden t�bl�hoz k�sz�t egy �rlap oszt�lyt a modelnek legink�bb megfelel� widgetek �s validatorok felhaszn�l�s�val, valamint figyelembe veszi a t�bl�k k�z�tti kapcsolatokat is.

>**Note**
>A `propel:build-all` �s `propel:build-all-load` taskok automatikusan megh�vj�k a `propel:build-forms` taskot.

A task futtat�sa ut�n egy file strukt�ra j�n l�tre a `lib/form/` k�nyvt�r alatt. A p�lda s�m�hoz tartoz� fileok a k�vetkez�k:

    lib/
      form/
        BaseFormPropel.class.php
        ArticleForm.class.php
        ArticleTagForm.class.php
        AuthorForm.class.php
        CategoryForm.class.php
        TagForm.class.php
        base/
          BaseArticleForm.class.php
          BaseArticleTagForm.class.php
          BaseAuthorForm.class.php
          BaseCategoryForm.class.php
          BaseTagForm.class.php

A `propel:build-forms` task minden t�bl�hoz k�t oszt�lyt k�sz�t, egy alaposzt�lyt a `lib/form/base` k�nyvt�rba �s egyet a `lib/form/` al�. P�ld�ul az `author` t�bl�hoz tartoz� �rlap egy `BaseAuthorForm` �s egy `AuthorForm` oszt�lyb�l �ll, amelyeket `lib/form/base/BaseAuthorForm.class.php` �s `lib/form/AuthorForm.class.php` fileok tartalmaznak.

>**SIDEBAR**
>Gener�lt �rlap k�nyvt�rak
>
>A `propel:build-forms` task �ltal gener�lt fileok strukt�r�ja hasonl� a Propel�hez. A Propel s�m�ban megadott `package` (csomag) attrib�tum a t�bl�k r�szhalmazokra t�rt�n� bont�s�t teszi lehet�v�. Az alap�rtemezett csomag a `lib.model`, teh�t a Propel a `lib/model/` k�nyvt�r al� hozza l�tre a modeleket �s a `lib/form/` al� az �rlapokat. A `lib.model.cms` csomag haszn�lat�val, ahogy a lenti p�ld�n is l�that�, a Propel oszt�lyok a `lib/model/cms/`, az �rlap oszt�lyok pedig a `lib/form/cms/` k�nyvt�r al� ker�lnek.
>
>     [php]
>     propel:
>       _attributes: { noXsd: false, defaultIdMethod: none, package: lib.model.cms }
>       # ...
>
>A csomagok haszn�lata nagyon hasznos, ha az adatb�zis s�m�t sz�t szeretn�nk v�lasztani, �s egy pluginba szeretn�nk csomagolni a hozz� tartoz� �rlapokat, ahogy azt az 5. fejezetben l�tni fogjuk.
>
>Propel csomagokkal kapcsolatos tov�bbi inform�ci� a "The Definitive Guide to symfony" k�nyv [Inside the Model Layer](http://www.symfony-project.org/book/1_1/08-Inside-the-Model-Layer) fejezet�ben tal�lhat�.

Foglaljuk �ssze egy t�bl�zatba az `AuthorForm` �rlap defin�ci�j�ban szerepl� oszt�lyok k�z�tti k�l�nbs�geket.

  | **Oszt�ly**    | **Csomag**    | **Kinek k�sz�lt** | **Le�r�s**
  | -------------- | ------------- | ----------------- | ---------------
  | AuthorForm     | project       | fejleszt�         | Fel�l�rja a gener�lt �rlapot
  | BaseAuthorForm | project       | symfony           | A s�m�n alapul, `propel:build-forms` task minden egyes futtat�sakor �jragener�l�dik
  | BaseFormPropel | project       | fejleszt�         | Propel alap� �rlapok glob�lis m�dos�t�s�ra szolg�l
  | sfFormPropel   | Propel plugin | symfony           | Propel �rlapok alapja
  | sfForm         | symfony       | symfony           | Symfony �rlapok alapja

Az `Author` oszt�lyb�l sz�rmaz� objektum l�trehoz�s�hoz �s szerkeszt�s�hez az `AuthorForm` oszt�lyt fogjuk haszn�lni (4-2 mell�klet). �szrevehetj�k, hogy ez az oszt�ly nem tartalmaz met�dusokat, mindent a `BaseAuthorForm` oszt�lyt�l �r�k�l, amely a konfigur�ci�n alapul. Az `AuthorForm` szolg�l az alap �rlap konfigur�ci� testreszab�s�ra.

4-2 mell�klet - `AuthorForm` oszt�ly

    [php]
    class AuthorForm extends BaseAuthorForm
    {
      public function configure()
      {
      }
    }

A 4-3 mell�kleten l�that� a `BaseAuthorForm` oszt�ly, a hozz� tartoz� validatorokkal �s widgetekkel, amely az `author` t�bla modelj�n alapul.

4-3 mell�klet - `BaseAuthorForm` oszt�ly, az `author` t�bla �rlap reprezent�ci�ja

    [php]
    class BaseAuthorForm extends BaseFormPropel
    {
      public function setup()
      {
        $this->setWidgets(array(
          'id'         => new sfWidgetFormInputHidden(),
          'first_name' => new sfWidgetFormInput(),
          'last_name'  => new sfWidgetFormInput(),
          'email'      => new sfWidgetFormInput(),
        ));

        $this->setValidators(array(
          'id'         => new sfValidatorPropelChoice(array('model' => 'Author', 'column' => 'id', 'required' => false)),
          'first_name' => new sfValidatorString(array('max_length' => 20, 'required' => false)),
          'last_name'  => new sfValidatorString(array('max_length' => 20, 'required' => false)),
          'email'      => new sfValidatorString(array('max_length' => 255)),
        ));

        $this->widgetSchema->setNameFormat('author[%s]');

        $this->errorSchema = new sfValidatorErrorSchema($this->validatorSchema);

        parent::setup();
      }

      public function getModelName()
      {
        return 'Author';
      }
    }

A l�trej�tt oszt�ly n�h�ny kiv�tellel nagyon hasonl�t az el�z� fejezetben k�sz�tett �rlapokhoz:

  * A sz�l� oszt�ly a `BaseFormPropel` az `sfForm` helyett
  * A validator �s widget konfigur�ci� a `setup()` met�dusban tal�hat�, nem pedig a `configure()`ban
  * A `getModelName()` met�dus a kapcsol�d� Propel oszt�ly nev�vel t�r vissza

>**SIDEBAR**
>Propel �rlapok glob�lis testreszab�sa
>
>A `propel:build-forms` a t�bl�khoz tartoz� �rlaposzt�lyokon fel�l l�trehoz m�g egy `BaseFormPropel` oszt�lyt is. Ez egy �res oszt�ly, amely �se az �sszes `lib/form/base/` alatt l�trehozott oszt�lynak, lehet�s�get biztos�tva minden Propel �rlap viselked�s�nek egys�ges megv�ltoztat�s�hoz. P�ld�nkn�l maradva, egyszer�en megv�ltoztathat� a Propel �rlapokhoz tartoz� alap�rtelmezett form�z� (formatter):
>
>     [php]
>     abstract class BaseFormPropel extends sfFormPropel
>     {
>       public function setup()
>       {
>         sfWidgetFormSchema::setDefaultFormFormatterName('div');
>       }
>     }
>
>L�tjuk, hogy a `BaseFormPropel` oszt�ly az `sfFormPropel` oszt�lyb�l sz�rmazik. Ez az oszt�ly tartalmazza a Propel specifikus funkci�kat, t�bbek k�z�tt az �rlapr�l elk�ld�tt adatokb�l k�sz�lt objektum adatb�zisba ment�s�t is.

>**TIP**
>A sz�l� oszt�lyok a `setup()` met�dust haszn�lj�k a konfigur�l�shoz a `configure()` helyett. Ez lehet�v� teszi a fejleszt� sz�m�ra, hogy fel�l�rja a be�ll�t�sokat a n�lk�l, hogy a `parent::configure()` h�v�ssal foglalkoznia kellene.

Az �rlap mez�k nevei megfelelnek a s�m�ban haszn�lt mez�nevekkel: `id`, `first_name`, `last_name` �s `email`.

A `propel:build-forms` task az `author` t�bla minden mez�j�hez l�trehoz egy widgetet �s egy validatort a s�ma defin�ci�nak megfelel�en. A task mindig a lehet� legbiztons�gosabb validator �ll�tja be. N�zz�k meg az `id` mez�t. Ellen�rizhetn�nk az �rt�k�t �gy is, hogy �rv�nyes eg�sz-e. Ehelyett a be�ll�tott validator lehet�v� teszi, hogy �rv�nyes�ts�k a mez�t, mint egy m�r l�tez�t (egy m�r megl�v� objektum szerkeszt�sekor) vagy hogy az azonos�t� �res-e (egy �j objektum l�trehoz�sakor). Ez egy er�sebb �rv�nyes�t�s.

A l�trehozott �rlapok azonnal haszn�lhat�k. Adjuk a templatehez a `<?php echo $form ?>`t �s egy m�k�d� �rlapot kapunk �rv�nyes�t�ssel egy�tt **an�lk�l, hogy ak�r egy sor k�dot kellett volna �rnunk**.

Azon t�l, hogy ebb�l gyors protot�pust k�sz�thet�nk, a l�trehozott oszt�lyok egyszer�en kiterjeszthet�k an�lk�l, hogy a gener�lt oszt�lyokat m�dos�tani kellene. Mindez a sz�l� �s �rlap oszt�lyok �r�kl�d�si mechanizmus�nak k�sz�nhet�.

V�g�l minden adatb�zis s�ma v�ltoztat�s eset�n a task �jra l�trehozza az �rlapokat a m�dos�t�soknak megfelel�en an�lk�l, hogy kor�bbi saj�t be�ll�t�saink elveszn�nek.

A CRUD gener�tor
----------------

Most, hogy elk�sz�ltek az �rlap oszt�lyok, l�ssuk milyen egyszer� l�trehozni egy symfony modult az objektumok kezel�s�hez. Szeretn�nk l�trehozni, szerkeszteni �s t�r�lni az `Article`, `Author`, `Category` �s `Tag` oszt�lyokhoz tartoz� objektumokat.
Kezdj�k egy, az `Author` oszt�ly kezel�s�t v�gz� modul k�sz�t�s�vel. B�r k�zzel is l�trehozhat�, a Propel plugin biztos�t egy `propel:generate-crud` taskot, ami egy Propel objektumhoz tartoz� CRUD modult �ll�t el�. A kor�bban l�trehozott �rlapot haszn�ljuk mindehhez:

    $ ./symfony propel:generate-crud frontend author Author

A `propel:generate-crud` h�rom param�tert v�r:

  * `frontend` : az alkalmaz�s neve, amelyben a modult l�trehozzuk
  * `author`   : a modul neve
  * `Author`   : a model oszt�ly neve, amelyhez modult hozunk l�tre

>**Note**
>A CRUD a Creation / Retrieval / Update / Deletion (l�trehoz�s, visszat�lt�s, friss�t�s, t�rl�s) r�vid�t�se, �sszefoglalja azt a n�gy alapm�veletet, amelyet model adatokon v�gre szoktunk hajtani.

A 4-4 mell�kleten l�that�, hogy a task 5 actiont hozott l�tre, melyek lehet�v� teszik az `Author` oszt�ly objektumainak list�z�s�t (`index`), l�trehoz�s�t (`create`), m�dos�t�s�t (`edit`), ment�s�t (`save`) �s t�rl�s�t (`delete`).

4-4 mell�klet - A task �ltal gener�lt `authorActions` oszt�ly

    [php]
    // apps/frontend/modules/author/actions/actions.class.php
    class authorActions extends sfActions
    {
      public function executeIndex()
      {
        $this->authorList = AuthorPeer::doSelect(new Criteria());
      }

      public function executeCreate()
      {
        $this->form = new AuthorForm();

        $this->setTemplate('edit');
      }

      public function executeEdit($request)
      {
        $this->form = new AuthorForm(AuthorPeer::retrieveByPk($request->getParameter('id')));
      }

      public function executeUpdate($request)
      {
        $this->forward404Unless($request->isMethod('post'));

        $this->form = new AuthorForm(AuthorPeer::retrieveByPk($request->getParameter('id')));

        $this->form->bind($request->getParameter('author'));
        if ($this->form->isValid())
        {
          $author = $this->form->save();

          $this->redirect('author/edit?id='.$author->getId());
        }

        $this->setTemplate('edit');
      }

      public function executeDelete($request)
      {
        $this->forward404Unless($author = AuthorPeer::retrieveByPk($request->getParameter('id')));

        $author->delete();

        $this->redirect('author/index');
      }
    }

Ebben a modulban az �rlap kezel�s�vel h�rom met�dus foglalkozik: `create`, `edit` �s `update`. A `propel:generate-crud` task a `--non-atomic-actions` opci�val be�ll�that�, hogy egyetlen met�dussal oldja meg ennek a h�romnak a funkcionalit�s�t.

    $ ./symfony propel:generate-crud frontend author Author --non-atomic-actions

A `--non-atomic-actions` �ltal gener�lt k�d (4-5 mell�klet) t�m�rebb, de kev�sb� �tl�that�.

4-5 mell�klet - A `--non-atomic-actions` opci�val gener�lt `authorActions` oszt�ly

    [php]
    class authorActions extends sfActions
    {
      public function executeIndex()
      {
        $this->authorList = AuthorPeer::doSelect(new Criteria());
      }

      public function executeEdit($request)
      {
        $this->form = new AuthorForm(AuthorPeer::retrieveByPk($request->getParameter('id')));

        if ($request->isMethod('post'))
        {
          $this->form->bind($request->getParameter('author'));
          if ($this->form->isValid())
          {
            $author = $this->form->save();

            $this->redirect('author/edit?id='.$author->getId());
          }
        }
      }

      public function executeDelete($request)
      {
        $this->forward404Unless($author = AuthorPeer::retrieveByPk($request->getParameter('id')));

        $author->delete();

        $this->redirect('author/index');
      }
    }

A task k�t template filet gener�l: `indexSuccess` �s `editSuccess`. Az `editSuccess` a `<?php echo $form ?>` haszn�lata n�lk�l j�n l�tre. A `--non-verbose-templates` opci�val m�dos�that� ez a viselked�s:

    $ ./symfony propel:generate-crud frontend author Author --non-verbose-templates

Ez az opci� a protot�pus k�sz�t�s f�zis�ban lehet hasznos (4-6 mell�klet).

4-6 mell�klet - A `editSuccess` template

    [php]
    // apps/frontend/modules/author/templates/editSuccess.class.php
    <?php $author = $form->getObject() ?>
    <h1><?php echo $author->isNew() ? 'New' : 'Edit' ?> Author</h1>

    <form action="<?php echo url_for('author/edit'.(!$author->isNew() ? '?id='.$author->getId() : '')) ?>" method="post" <?php $form->isMultipart() and print 'enctype="multipart/form-data" ' ?>>
      <table>
        <tfoot>
          <tr>
            <td colspan="2">
              &nbsp;<a href="<?php echo url_for('author/index') ?>">Cancel</a>
              <?php if (!$author->isNew()): ?>
                &nbsp;<?php echo link_to('Delete', 'author/delete?id='.$author->getId(), array('post' => true, 'confirm' => 'Are you sure?')) ?>
              <?php endif; ?>
              <input type="submit" value="Save" />
            </td>
          </tr>
        </tfoot>
        <tbody>
          <?php echo $form ?>
        </tbody>
      </table>
    </form>

>**TIP**
>A `--with-show` opci� seg�ts�g�vel gener�lt k�d tartalmaz egy `show` action is az objektum tartalm�nak megtekint�s�hez (csak olvashat�).

Most m�r megnyithatjuk az elk�sz�lt modult a b�ng�sz�ban, a 4-1 �s 4-2 �bra szerinti megjelen�st l�thatjuk. J�tszunk egy kicsit ezzel a fel�lettel. A l�trehozott modul seg�ts�g�vel list�zhatjuk a szerz�ket, �jakat vehet�nk fel, szerkeszthetj�k, m�dos�thatjuk �s t�r�lhetj�k �ket. Vegy�k �szre, hogy az �rv�nyes�t� szab�lyok is m�k�dnek.

4-1 �bra - Szerz�k list�ja

![Szerz�k list�ja](/images/forms_book/en/04_01.png "Szerz�k list�ja")

4-2 �bra - Egy szerz� szerkeszt�se mez� �rv�nyes�t�ssel

![Egy szerz� szerkeszt�se mez� �rv�nyes�t�ssel](/images/forms_book/en/04_02.png "Egy szerz� szerkeszt�se mez� �rv�nyes�t�ssel")

Most megism�telhetj�k a m�veletet az `Article` oszt�lyra is:

    $ ./symfony propel:generate-crud frontend article Article --non-verbose-templates --non-atomic-actions

A l�trej�tt k�d nagyon hasonl�t az `Author` oszt�lyhoz l�trehozottra, de ha �j cikket akarunk k�sz�teni, a 4-3 �br�n l�that� v�gzetes hib�val le�ll.

4-3 �bra - A kapcsolt t�bl�knak defini�lniuk kell a `__toString()` met�dust

![A kapcsolt t�bl�knak defini�lniuk kell a `__toString()` met�dust](/images/forms_book/en/04_03.png "A kapcsolt t�bl�knak defini�lniuk kell a `__toString()` met�dust")

Az `ArticleForm` �rlap az `sfWidgetFormPropelSelect` widgetet haszn�lja az `Article` �s az `Author` objektum k�z�tti kapcsolat reprezent�l�s�ra. Ez a widget a szerz�kb�l egy leg�rd�l� list�t k�sz�t. Megjelen�t�skor a szerz�i objektumokat karakterl�ncc� alak�tja a `__toString()` met�dus seg�ts�g�vel, amit defini�lni kell az `Author` oszt�lyban (4-7 mell�klet).

4-7 mell�klet - Az `Author` oszt�ly `__toString()` met�dusa

    [php]
    class Author extends BaseAuthor
    {
      public function __toString()
      {
        return $this->getFirstName().' '.$this->getLastName();
      }
    }

Az `Author` oszt�lyhoz hasonl�an elk�sz�thetj�k a t�bbi oszt�lyhoz (`Article`, `Category` �s `Tag`) is a `__toString()` met�dust.

>**Tip**
>Az `sfWidgetFormPropelSelect` widget `method` opci�j�val be�ll�that� az objektum konvert�l�shoz haszn�lt met�dusa.

The Figure 4-4 Shows how to create an article after having implemented the `__toString()` method.


4-4 �bra - Egy cikk l�trehoz�sa

![Egy cikk l�trehoz�sa](/images/forms_book/en/04_04.png "Egy cikk l�trehoz�sa")

Customizing the generated Forms
-------------------------------

The `propel:build-forms` and `propel:generate-crud` tasks let us create functional symfony modules to list, create, edit, and delete model objects. These modules are taking into account not only the validation rules of the model but also the relationships between tables. All of this happens without writing a single line of code!

The time has now come to customize the generated code. If the form classes are already considering many elements, some aspects will need to be customized.

### Configuring validators and widgets

Let's start with configuring the validators and widgets generated by default.

The `ArticleForm` form has a `slug` field. The slug is a string of characters that uniquely representing the article in the URL. For instance, the slug of an article whose title is "Optimize the developments with symfony" is `12-optimize-the-developments-with-symfony`, `12` being the article `id`. This field is usually automatically computed when the object is saved, depending on the `title`, but it has the potential to be explicitly overridden by the user. Even if this field is required in the schema, it can not be compulsory to the form. That is why we modify the validator and make it optional, as in Listing 4-8. We will also customize the `content` field increasing its size and forcing the user to type in at least five characters.

4-8 mell�klet - Customizing Validators and Widgets

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        // ...

        $this->validatorSchema['slug']->setOption('required', false);
        $this->validatorSchema['content']->setOption('min_length', 5);

        $this->widgetSchema['content']->setAttributes(array('rows' => 10, 'cols' => 40));
      }
    }

We use here the `validatorSchema` and `widgetSchema` objects as PHP arrays. These arrays are taking the name of a field as key and return respectively the validator object and the related widget object. We can then Customize individually fields and widgets.

>**Note**
>In order to allow the use of objects as PHP arrays, the `sfValidatorSchema` and `sfWidgetFormSchema` classes implement the `ArrayAccess` interface, available in PHP since version 5.

To make sure two articles can not have the same `slug`, a uniqueness constraint has been added in the schema definition. This constraint on the database level is reflected in the `ArticleForm` form using the `sfValidatorPropelUnique` validator. This validator can check the uniqueness of any form field. It is helpful among other things to check the uniqueness of an email address of a login for instance. Listing 4-9 shows how to use it in the `ArticleForm` form.

4-9 mell�klet - Using the `sfValidatorPropelUnique` validator to check the Uniqueness of a field

    [php]
    class BaseArticleForm extends BaseFormPropel
    {
      public function setup()
      {
        // ...

        $this->validatorSchema->setPostValidator(
          new sfValidatorPropelUnique(array('model' => 'Article', 'column' => array('slug')))
        );
      }
    }

The `sfValidatorPropelUnique` validator is a `postValidator` running on the whole data after the individual validation of each field. In order to validate the `slug` uniqueness, the validator must be able to access, not only the `slug` value, but also the value of the primary key(s). Validation rules are indeed different throughout the creation and the edition since the slug can stay the same during the update of an article.

Let's Customize now the `active` field of the `author` table, used to know if an author is active. Listing 4-10 shows how to exclude inactive authors from the `ArticleForm` form, modifying the `criteria` option of the `sfWidgetPropelSelect` widget connected to the `author_id` field. The `criteria` option accepts a Propel Criteria object, allowing to narrow down the list of available options in the rolling list.

4-10 mell�klet - Customizing the `sfWidgetPropelSelect` widget

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        // ...

        $authorCriteria = new Criteria();
        $authorCriteria->add(AuthorPeer::ACTIVE, true);

        $this->widgetSchema['author_id']->setOption('criteria', $authorCriteria);
      }
    }

Even if the widget customization can make us narrow down the list of available options, we must not forget to consider this narrowing on the validator level, as shown in Listing 4-11. Like the `sfWidgetProperSelect` widget, the `sfValidatorPropelChoice` validator accepts a `criteria` option to narrow down the options valid for a field.

4-11 mell�klet - Customizing the `sfValidatorPropelChoice` validator

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        // ...

        $authorCriteria = new Criteria();
        $authorCriteria->add(AuthorPeer::ACTIVE, true);

        $this->widgetSchema['author_id']->setOption('criteria', $authorCriteria);
        $this->validatorSchema['author_id']->setOption('criteria', $authorCriteria);
      }
    }

In the previous example we defined the `Criteria` object directly in the `configure()` method. In our project, this criteria will certainly be helpful in other circumstances, so it is better to create a `getActiveAuthorsCriteria()` method within the `AuthorPeer` class and to call this method from `ArticleForm` as Listing 4-12 shows.

4-12 mell�klet - Refactoring the `Criteria` in the Model

    [php]
    class AuthorPeer extends BaseAuthorPeer
    {
      static public function getActiveAuthorsCriteria()
      {
        $criteria = new Criteria();
        $criteria->add(AuthorPeer::ACTIVE, true);

        return $criteria;
      }
    }

    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        $authorCriteria = AuthorPeer::getActiveAuthorsCriteria();
        $this->widgetSchema['author_id']->setOption('criteria', $authorCriteria);
        $this->validatorSchema['author_id']->setOption('criteria', $authorCriteria);
      }
    }

>**TIP**
>Like the `sfWidgetPropelSelect` widget and the `sfValidatorPropelChoice` validator represent a 1-n relation between two tables, the `sfWidgetPropelSelectMany` and the `sfValidatorPropelChoiceMany` validator represent a n-n relation and accept the same options. In the `ArticleForm` form, these classes are used to represent a relation between the `article` table and the `tag` table.

### Changing validator

The `email` being defined as a `varchar(255)` in the schema, symfony created a `sfValidatorString()` validator restraining the maximum length to 255 characters. This field is also supposed to receive a valid email, Listing 4-14 replaces the generated validator with a `sfValidatorEmail` validator.

4-13 mell�klet - Changing the `email` field Validator of the `AuthorForm` class

    [php]
    class AuthorForm extends BaseAuthorForm
    {
      public function configure()
      {
        $this->validatorSchema['email'] = new sfValidatorEmail();
      }
    }

### Adding a validator

We observed in the previous chapter how to modify the generated validator. But in the case of the `email` field, it would be useful to keep the maximum length validation. In Listing 4-14, we use the `sfValidatorAnd` validator to guarantee the email validity and check the maximum length allowed for the field.

4-14 mell�klet - Using a multiple Validator

    [php]
    class AuthorForm extends BaseAuthorForm
    {
      public function configure()
      {
        $this->validatorSchema['email'] = new sfValidatorAnd(array(
          new sfValidatorString(array('max_length' => 255)),
          new sfValidatorEmail(),
        ));
      }
    }

The previous example is not perfect, because if we decide later to modify the length of the `email` field in the database schema, we will have to think about doing it also in the form. Instead of replacing the generated validator, it is better to add one, as shown in Listing 4-15.

4-15 mell�klet - Adding a Validator

    [php]
    class AuthorForm extends BaseAuthorForm
    {
      public function configure()
      {
        $this->validatorSchema['email'] = new sfValidatorAnd(array(
          $this->validatorSchema['email'],
          new sfValidatorEmail(),
        ));
      }
    }

### Changing widget

In the database schema, the `status` field of the `article` table stores the article status as a string of characters. The possible values were defined in the `ArticePeer` class, as shown in Listing 4-16.

4-16 mell�klet - Defining available Statuses in the `ArticlePeer` class

    [php]
    class ArticlePeer extends BaseArticlePeer
    {
      static protected $statuses = array('draft', 'online', 'offline');

      static public function getStatuses()
      {
        return self::$statuses;
      }

      // ...
    }

When editing an article, the `status` field must be represented as a drop-down list instead of a text field. To do so, let's change the widget we used, as shown in Listing 4-17.

4-17 mell�klet - Changing the Widget for the `status` field

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        $this->widgetSchema['status'] = new sfWidgetFormSelect(array('choices' => ArticlePeer::getStatuses()));
      }
    }

To be thorough we must also change the validator to make sure the chosen status actually belongs to the list of possible options (Listing 4-18).

4-18 mell�klet - Modifying the `status` Field Validator

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        $statuses = ArticlePeer::getStatuses();
        
        $this->widgetSchema['status'] = new sfWidgetFormSelect(array('choices' => $statuses));

        $this->validatorSchema['status'] = new sfValidatorChoice(array('choices' => array_keys($statuses)));
      }
    }

### Deleting a field

The `article` table has two special columns, `created_at` and `updated_at`, whose update is automatically handled by Propel. We must then delete them from the form as Listing 4-19 show, to prevent the user from modifying them.

4-19 mell�klet - Deleting a Field

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        unset($this->validatorSchema['created_at']);
        unset($this->widgetSchema['created_at']);

        unset($this->validatorSchema['updated_at']);
        unset($this->widgetSchema['updated_at']);
      }
    }

In order to delete a field, it is necessary to delete its validator and its widget. Listing 4-20 shows how it is also possible to delete both in one action, using the form as a PHP array.

4-20 mell�klet - Deleting a Field using the Form as a PHP Array

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        unset($this['created_at'], $this['updated_at']);
      }
    }

### Sum up

To sum up, Listing 4-21 and Listing 4-22 show the `ArticleForm` and `AuthorForm` forms as we customize them.

4-21 mell�klet - `ArticleForm` Form

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        $authorCriteria = AuthorPeer::getActiveAuthorsCriteria();

        // widgets
        $this->widgetSchema['content']->setAttributes(array('rows' => 10, 'cols' => 40));
        $this->widgetSchema['status'] = new sfWidgetFormSelect(array('choices' => ArticlePeer::getStatuses()));
        $this->widgetSchema['author_id']->setOption('criteria', $authorCriteria);

        // validators
        $this->validatorSchema['slug']->setOption('required', false);
        $this->validatorSchema['content']->setOption('min_length', 5);
        $this->validatorSchema['status'] = new sfValidatorChoice(array('choices' => array_keys(ArticlePeer::getStatuses())));
        $this->validatorSchema['author_id']->setOption('criteria', $authorCriteria);

        unset($this['created_at']);
        unset($this['updated_at']);
      }
    }

4-22 mell�klet - `AuthorForm` Form

    [php]
    class AuthorForm extends BaseAuthorForm
    {
      public function configure()
      {
        $this->validatorSchema['email'] = new sfValidatorAnd(array(
          $this->validatorSchema['email'],
          new sfValidatorEmail(),
        ));
      }
    }

Using the `propel:build-forms` allows to automatically generate most of the elements letting forms introspect the object model. This automatization is helpful for several reasons:

  * It makes the developer's life easier, saving him from a repetitive and redundant work. He can then focus on the validators and widget Customization according to the project's specific business rules .

  * Besides, when the database schema is updated, the generated forms will be automatically updated. The developer will just have to tune the customization they made.

The next section will describe the customization of actions and templates generated by the `propel:generate-crud` task.

Form Serialization
------------------

The previous section show us how to customize forms generated by the task `propel:build-forms`. In the current section, we will customize the life cycle of forms, starting from the code generated by the `propel:generate-crud` task.

### Default values

**A Propel form instance is always connected to a Propel object**. The linked Propel object always belongs to the class returned by the `getModelName()` method. For instance, the `AuthorForm` form can only be linked to objects belonging to the `Author` class. This object is either an empty object (a blank instance of the `Author` class), or the object sent to the constructor as first argument. Whereas the constructor of an "average" form takes an array of values as first argument, the constructor of a Propel form takes a Propel object. This object is used  to define each form field default value. The `getObject()` method returns the object related to the current instance and the `isNew()` method allows to know if the object was sent via the constructor:

    [php]
    // creating a new object
    $authorForm = new AuthorForm();

    print $authorForm->getObject()->getId(); // outputs null
    print $authorForm->isNew();              // outputs true

    // modifying an existing object
    $author = AuthorPeer::retrieveByPk(1);
    $authorForm = new AuthorForm($author);

    print $authorForm->getObject()->getId(); // outputs 1
    print $authorForm->isNew();              // outputs false

### Handling life cycle

As we observed at the beginning of the chapter, the `edit` action, shown in Listing 4-23, handles the form life cycle.

4-23 mell�klet - The `executeEdit` Method of the `author` Module

    [php]
    // apps/frontend/modules/author/actions/actions.class.php
    class authorActions extends sfActions
    {
      // ...

      public function executeEdit($request)
      {
        $author = AuthorPeer::retrieveByPk($request->getParameter('id'));
        $this->form = new AuthorForm($author);

        if ($request->isMethod('post'))
        {
          $this->form->bind($request->getParameter('author'));
          if ($this->form->isValid())
          {
            $author = $this->form->save();

            $this->redirect('author/edit?id='.$author->getId());
          }
        }
      }
    }

Even if the `edit` action looks like the actions we might have describe in the previous chapters, we can point a few differences:

  * A Propel object from the `Author` class is sent as first argument to the form constructor:

        [php]
        $author = AuthorPeer::retrieveByPk($request->getParameter('id'));
        $this->form = new AuthorForm($author);

  * The widgets `name` attribute format is automatically customized to allow the retrieval of the input data in a PHP array named after the related table (`author`):

        [php]
        $this->form->bind($request->getParameter('author'));

  * When the form is valid, a mere call to the `save()` method creates or updates the Propel object related to the form:

        [php]
        $author = $this->form->save();

### Creating and Modifying a Propel Object

Listing 4-23 code handles with a single method the creation and modification of objects from the `Author` class:

  * Creation of a new `Author` object:

      * The `index` action is called with no `id` parameter (`$request->getParameter('id')` is `null`)

      * The call to the `retrieveByPk()` therefore sends `null`

      * The `form` object is then linked to an empty `Author` Propel object

      * The `$this->form->save()` call creates consequently a new `Author` object when a valid form is submitted

  * Modification of an existing `Author` object:

      * The `index` action is called with an `id` parameter (`$request->getParameter('id')` standing for the primary key the `Author` object is to modify)

      * The call to the `retriveByPk()` method returns the `Author` object related to the primary key

      * The `form` object is therefore linked to the previously found object

      * The `$this->form->save()` call updates the `Author` object when a valid form is submitted

### The `save()` method

When a Propel form is valid, the `save()` method updates the related object and stores it in the database. This method actually stores not only the main object but also the potentially related objects. For instance, the `ArticleForm` form updates the tags connected to an article. The relation between the ` article` table and the `tag` table being a n-n relation, the tags related to an article are saved in the `article_tag` table (using the `saveArticleTagList()` generated method).

In order to certify a consistent serialization, the `save()` method includes every updates in one transaction.

>**Note**
>We will see in Chapter 9 that the `save()` method also automatically updates the internationalized tables.

>**SIDEBAR**
>Using the `bindAndSave()` method
>
>The `bindAndSave()` method binds the input data the user submitted to the form, validates this form and updates the related object in the database, all in one operation: 
>
>     [php]
>     class articleActions extends sfActions
>     {
>       public function executeCreate(sfWebRequest $request)
>       {
>         $this->form = new ArticleForm();
>
>         if ($request->isMethod('post') && $this->form->bindAndSave($request->getParameter('article')))
>         {
>           $this->redirect('article/created');
>         }
>       }
>     }

### Handling the files upload

The `save()` method automatically updates the Propel objects but can not handle the side elements as managing the file upload.

Let's see how to attach a file to each article. Files are stored in the `web/uploads` directory and a reference to the file path is kept in the `file` field of the `article` table, as shown in Listing 4-24.

4-24 mell�klet - Schema for the `article` Table with associated File

    [yml]
    // config/schema.yml
    propel:
      article:
        // ...
        file: varchar(255)

After every schema update, you need to update the object model, the database and the related forms:

    $ ./symfony propel:build-all

>**Caution**
>Do mind that the `propel:build-all` task deletes every schema tables to re-create them. The data inside the tables are therefore overwritten. That is why it is important to create test data (`fixtures`) you can download again at each model modification.

Listing 4-25 shows how to modify the `ArticleForm` class in order to link a widget and a validator to the `file` field.

4-25 mell�klet - Modifying the `file` Field of the `ArticleForm` form.

    [php]
    class ArticleForm extends BaseArticleForm
    {
      public function configure()
      {
        // ...

        $this->widgetSchema['file'] = new sfWidgetFormInputFile();
        $this->validatorSchema['file'] = new sfValidatorFile();
      }
    }

As for every form allowing to upload a file, does not forget to add also the `enctype` attribute to the `form` tag of the template (see Chapter 2 for further informations concerning file upload management).

Listing 4-26 shows the modifications to apply when saving the form to upload the file onto  the server and store its path in the `article` object.

4-26 mell�klet - Saving the `article` Object and the File uploaded in the Action

    [php]
    public function executeEdit($request)
    {
      $author = ArticlePeer::retrieveByPk($request->getParameter('id'));
      $this->form = new ArticleForm($author);

      if ($request->isMethod('post'))
      {
        $this->form->bind($request->getParameter('article'), $request->getFiles('article'));
        if ($this->form->isValid())
        {
          $file = $this->form->getValue('file');
          $filename = sha1($file->getOriginalName()).$file->getExtension($file->getOriginalExtension());
          $file->save(sfConfig::get('sf_upload_dir').'/'.$filename);

          $article = $this->form->save();

          $this->redirect('article/edit?id='.$article->getId());
        }
      }
    }

Saving the uploaded file on the filesystem allows the `sfValidatedFile` object to know the absolute path to the file. During the call to the `save()` method, the fields values are used to update the related object and, as for the `file` field, the `sfValidatedFile` object is converted in a character string thanks to the `__toString()` method, sending back the absolute path to the file. The `file` column of the `article` table will store this absolute path.

>**TIP**
>If you wish to store the path relative to the `sfConfig::get('sf_upload_dir')` directory, you can create a class inheriting from `sfValidatedFile` and use the `validated_file_class` option to send to the `sfValidatorFile` validator the name of the new class. The validator will then return an instance of your class. We will see in the rest of this chapter another approach, consisting in modifying the value of the `file` column before saving the object in database.

### Customizing the `save()` method

We observed in the previous section how to save the uploaded file in the `edit` action. One of the principles of the object oriented programming is the reusability of the code, thanks to its encapsulation in classes. Instead of duplicating the code used to save the file in each action using the `ArticleForm` form, it is better to move it in the `ArticleForm` class. Listing 4-27 shows how to override the `save()` method in order to also save the file and possibly to delete of an existing file.

4-27 mell�klet - Overriding the `save()` Method of the `ArticleForm` Class

    [php]
    class ArticleForm extends BaseFormPropel
    {
      // ...
     
      public function save($con = null)
      {
        if (file_exists($this->getObject()->getFile()))
        {
          unlink($this->getObject()->getFile());
        }
   
        $file = $this->getValue('file');
        $filename = sha1($file->getOriginalName()).$file->getExtension($file->getOriginalExtension());
        $file->save(sfConfig::get('sf_upload_dir').'/'.$filename);
   
        return parent::save($con);
      }
    }

After moving the code to the form, the `edit` action is identical to the code initially generated by the `propel:generate-crud` task.

>**SIDEBAR**
>Refactoring the Code in the Model of in the Form
>
>The actions generated by the `propel:generate-crud` task shouldn't usually be modified.
>
>The logic you could add in the `edit` action, especially during the form serialization, must usually be moved in the model classes or in the form class.
>
>We just went over an example of refactoring in the form class in order to consider a uploaded file storing. Let's take another example related to the model. The `ArticleForm` form has a `slug` field. We observed that this field should be automatically computed from the `title` field name that it should be potentially overridden by the user. This logic does not depend on the form. It belongs therefore to the model, as shown the following code:
>
>     [php]
>     class Article extends BaseArticle
>     {
>       public function save($con = null)
>       {
>         if (!$this->getSlug())
>         {
>           $this->setSlugFromTitle();
>         }
>
>         return parent::save($con);
>       }
>
>       protection function setSlugFromTitle()
>       {
>         // ...
>       }
>     }
>
>The main goal of those refactorings is to respect the separation in applicative layers, and especially the reusability of the developments.

### Customizing the `doSave()` method

We observed that the saving of an object was made within a transaction in order to guarantee that each operation related to the saving is processed correctly. When overriding the `save()`method as we did in the previous section in order to save the uploaded file, the executed code is independent from this transaction.

Listing 4-28 shows how to use the `doSave()` method to insert in the global transaction our code saving the uploaded file. 

4-28 mell�klet - Overriding the `doSave()` Method in the `ArticleForm` Form

    [php]
    class ArticleForm extends BaseFormPropel
    {
      // ...
     
      public function doSave($con = null)
      {
        if (file_exists($this->getObject()->getFile()))
        {
          unlink($this->getObject()->getFile());
        }

        $file = $this->getValue('file');
        $filename = sha1($file->getOriginalName()).$file->getExtension($file->getOriginalExtension());
        $file->save(sfConfig::get('sf_upload_dir').'/'.$filename);

        return parent::doSave($con);
      }
    }

The `doSave()` method being called in the transaction created by the `save()` method, if the call to the `save()` method of the `file()` object throws an exception, the object will not be saved.

### Customizing the `updateObject()` Method

It is sometimes necessary to modify the object connected to the form between the update and the saving in database. 

In our file upload example, instead of storing the absolute path to the uploaded file in the `file` column, we wish to store the path relative to the `sfConfig::get('sf_upload_dir')` directory.

Listing 4-29 shows how to override the `updateObject()` method of the `ArticleForm` form in order to change the value of the `file` column after the automatic update object but before it is saved.

4-29 mell�klet - Overriding the `updateObject()` Method and the `ArticleForm` Class

    [php]
    class ArticleForm extends BaseFormPropel
    {
      // ...

      public function updateObject()
      {
        $object = parent::updateObject();

        $object->setFile(str_replace(sfConfig::get('sf_upload_dir').'/', '', $object->getFile()));

        return $object;
      }
    }

The `updateObject()` method is called by the `doSave()` method before saving the object in database.
